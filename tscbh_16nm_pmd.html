<!------
/***************************************************************************
 *     Copyright (c) 1999-2017, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *
 * THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 * AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 * EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 * $brcm_Workfile: $
 * $brcm_Revision: $
 * $brcm_Date: $
 *
 * Module Description:
 *                     DO NOT EDIT THIS FILE DIRECTLY
 *
 * This module was generated magically with RDB from a source description
 * file. You must edit the source file for changes to be made to this file.
 *
 *
 * Date:           Generated on         Mon Oct  9 11:04:17 2017
 *                 MD5 Checksum         c876dacaaa4a07c41f87cdbc3eaf552e
 *
 * Compiled with:  RDB Utility          5.0
 *                 RDB Parser           3.0
 *                 rdb2html.pm          3.0
 *                 Perl Interpreter     5.014001
 *                 Operating System     linux
 *
 * Spec Versions:  ams_com_8x_pll2x_v1p01
 *                 ams_rx_8x_pll2x_v1p0 1
 *                 ams_tx_8x_pll2x_v1p0 1
 *                 core_pll_com_8x_pll2x_v1p01
 *                 dac_test_8x_pll2x_v1p01
 *                 dig_com_8x_pll2x_v1p01
 *                 dig_com_b_8x_pll2x_v1p01
 *                 dsc_a                1
 *                 dsc_afe1             1
 *                 dsc_afe2             1
 *                 dsc_afe3             1
 *                 dsc_b                1
 *                 dsc_c_8x_pll2x_v1p0  1
 *                 dsc_d                1
 *                 dsc_e                1
 *                 dsc_f                1
 *                 dsc_g                1
 *                 dsc_h                1
 *                 dsc_i_8x_pll2x_v1p0  1
 *                 linktrn_ieee_rx_8x_pll2x_v1p01
 *                 linktrn_ieee_tx_8x_pll2x_v1p01
 *                 linktrn_user_rx_8x_pll2x_v1p01
 *                 linktrn_user_tx_8x_pll2x_v1p01
 *                 mdio_mmdsel_aer_com  1
 *                 micro_a_rmi_8x_pll2x_v1p01
 *                 micro_b_rmi_8x_pll2x_v1p01
 *                 micro_c_rmi_8x_pll2x_v1p01
 *                 micro_d_rmi_8x_pll2x_v1p01
 *                 micro_e_rmi_8x_pll2x_v1p01
 *                 patt_gen_com         1
 *                 pll_cal_com_8x_pll2x_v1p01
 *                 rx_ckrst_ctrl_8x_pll2x_v1p01
 *                 rxcom_ckrst_ctrl_8x_pll2x_v1p01
 *                 rxtxcom_ckrst_ctrl_8x_pll2x_v1p01
 *                 sigdet               1
 *                 tlb_err_aggr_8x_pll2x_v1p01
 *                 tlb_rx_8x_pll2x_v1p0 1
 *                 tlb_rx_b_8x_pll2x_v1p01
 *                 tlb_rx_c_8x_pll2x_v1p01
 *                 tlb_tx_8x_pll2x_v1p0 1
 *                 tx_ckrst_ctrl_8x_pll2x_v1p01
 *                 tx_fed_8x_pll2x_v1p0 1
 *                 tx_pi_8x_pll2x_v1p0  1
 *                 tx_pi_b_8x_pll2x_v1p01
 *                 txcom_8x_pll2x_v1p0  1
 *                 txcom_ckrst_ctrl_8x_pll2x_v1p01
 *
 * RDB Files:  /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/blackhawk_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tx_pi_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tx_pi_b_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dig_com_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dig_com_b_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tlb_err_aggr_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tlb_tx_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tlb_rx_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tlb_rx_b_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tlb_rx_c_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/patt_gen_com.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/linktrn_user_rx_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/linktrn_user_tx_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/linktrn_ieee_tx_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/linktrn_ieee_rx_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/txcom_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/ams_com_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/pll_cal_com_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/core_pll_com_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/ams_tx_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tx_fed_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/ams_rx_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/sigdet.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_a.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_b.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_c_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_d.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_e.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_f.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_g.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_h.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_i_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_afe1.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_afe2.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dsc_afe3.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/rx_ckrst_ctrl_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/rxcom_ckrst_ctrl_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/tx_ckrst_ctrl_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/txcom_ckrst_ctrl_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/rxtxcom_ckrst_ctrl_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/dac_test_regs_8x_pll2x_v1p0.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/mdio_mmdsel_aer_com.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/micro_a_rmi_8x_pll2x_v1p0_regs.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/micro_b_rmi_8x_pll2x_v1p0_regs.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/micro_c_rmi_8x_pll2x_v1p0_regs.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/micro_d_rmi_8x_pll2x_v1p0_regs.rdb
 *             /projects/TSC_ext8/kbondali/TSCBH_16nm_cron/tscbh/dv/common/tbhmod/tbhmod_pmd_rdb/micro_e_rmi_8x_pll2x_v1p0_regs.rdb
 *
 * Revision History:
 *
 * $brcm_Log: $
 *
 ***************************************************************************/

!------>
Generated on Mon Oct  9 11:04:17 2017
<h1><a NAME="blackhawk_8x_pll2x_v1p0">blackhawk_8x_pll2x_v1p0 Registers Map</a></h1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=60%><b>Block       </b></td><td align=center width=20%><b>Start - End Offset</b></td><td align=center width=20%><b>Start - End Address</b></td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  Reserved</td><td align=center>0x0010 - 0x008f</td><td align=center>0x00000010 - 0x0000008f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>linktrn_ieee_blk</b></td><td align=center>0x0090 - 0x009f</td><td align=center>0x00000090 - 0x0000009f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#LINKTRN_IEEE_TX Registers">LINKTRN_IEEE_TX: per lane register block [8 copies]</A></td><td align=center>0x0090 - 0x009b</td><td align=center>0x00000090 - 0x0000009b</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#LINKTRN_IEEE_RX Registers">LINKTRN_IEEE_RX: per lane register block [8 copies]</A></td><td align=center>0x0090 - 0x0099</td><td align=center>0x00000090 - 0x00000099</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  Reserved</td><td align=center>0x00a0 - 0xcfff</td><td align=center>0x000000a0 - 0x0000cfff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>dsc_blk</b></td><td align=center>0xd000 - 0xd4ff</td><td align=center>0x0000d000 - 0x0000d4ff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_AFE1 Registers">DSC_AFE1: per lane register block [8 copies]</A></td><td align=center>0xd000 - 0xd00e</td><td align=center>0x0000d000 - 0x0000d00e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_AFE2 Registers">DSC_AFE2: per lane register block [8 copies]</A></td><td align=center>0xd010 - 0xd01e</td><td align=center>0x0000d010 - 0x0000d01e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_AFE3 Registers">DSC_AFE3: per lane register block [8 copies]</A></td><td align=center>0xd020 - 0xd02e</td><td align=center>0x0000d020 - 0x0000d02e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_A Registers">DSC_A: per lane register block [8 copies]</A></td><td align=center>0xd030 - 0xd03e</td><td align=center>0x0000d030 - 0x0000d03e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_B Registers">DSC_B: per lane register block [8 copies]</A></td><td align=center>0xd040 - 0xd04d</td><td align=center>0x0000d040 - 0x0000d04d</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_C Registers">DSC_C: per lane register block [8 copies]</A></td><td align=center>0xd050 - 0xd05e</td><td align=center>0x0000d050 - 0x0000d05e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_D Registers">DSC_D: per lane register block [8 copies]</A></td><td align=center>0xd060 - 0xd06e</td><td align=center>0x0000d060 - 0x0000d06e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_E Registers">DSC_E: per lane register block [8 copies]</A></td><td align=center>0xd070 - 0xd07e</td><td align=center>0x0000d070 - 0x0000d07e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd080 - 0xd0ef</td><td align=center>0x0000d080 - 0x0000d0ef</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_F Registers">DSC_F: per lane register block [8 copies]</A></td><td align=center>0xd0f0 - 0xd0fa</td><td align=center>0x0000d0f0 - 0x0000d0fa</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd100 - 0xd40f</td><td align=center>0x0000d100 - 0x0000d40f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_G Registers">DSC_G: per lane register block [8 copies]</A></td><td align=center>0xd410 - 0xd41d</td><td align=center>0x0000d410 - 0x0000d41d</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_H Registers">DSC_H: per lane register block [8 copies]</A></td><td align=center>0xd420 - 0xd42e</td><td align=center>0x0000d420 - 0x0000d42e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd430 - 0xd43f</td><td align=center>0x0000d430 - 0x0000d43f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DSC_I Registers">DSC_I: per lane register block [8 copies]</A></td><td align=center>0xd440 - 0xd44c</td><td align=center>0x0000d440 - 0x0000d44c</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>ckrst_ctrl_8x_pll2x_v1p0_blk</b></td><td align=center>0xd000 - 0xdfff</td><td align=center>0x0000d000 - 0x0000dfff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd010 - 0xd0af</td><td align=center>0x0000d010 - 0x0000d0af</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks.</A></td><td align=center>0xd0b0 - 0xd0be</td><td align=center>0x0000d0b0 - 0x0000d0be</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd0c0 - 0xd19f</td><td align=center>0x0000d0c0 - 0x0000d19f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]</A></td><td align=center>0xd1a0 - 0xd1ae</td><td align=center>0x0000d1a0 - 0x0000d1ae</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]</A></td><td align=center>0xd1b0 - 0xd1bd</td><td align=center>0x0000d1b0 - 0x0000d1bd</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]</A></td><td align=center>0xd1c0 - 0xd1ce</td><td align=center>0x0000d1c0 - 0x0000d1ce</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]</A></td><td align=center>0xd1d0 - 0xd1de</td><td align=center>0x0000d1d0 - 0x0000d1de</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>ams_blk</b></td><td align=center>0xd000 - 0xdfff</td><td align=center>0x0000d000 - 0x0000dfff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd010 - 0xd0bf</td><td align=center>0x0000d010 - 0x0000d0bf</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#AMS_RX Registers">AMS_RX: per lane register block [8 copies]</A></td><td align=center>0xd0c0 - 0xd0cc</td><td align=center>0x0000d0c0 - 0x0000d0cc</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#AMS_TX Registers">AMS_TX: per lane register block [8 copies]</A></td><td align=center>0xd0d0 - 0xd0d9</td><td align=center>0x0000d0d0 - 0x0000d0d9</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd0e0 - 0xd10f</td><td align=center>0x0000d0e0 - 0x0000d10f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#AMS_PLL_COM Registers">AMS_PLL_COM: common register block per PLL [2 copies]</A></td><td align=center>0xd110 - 0xd11c</td><td align=center>0x0000d110 - 0x0000d11c</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd120 - 0xd17f</td><td align=center>0x0000d120 - 0x0000d17f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#CORE_PLL_COM Registers">CORE_PLL_COM: common register block per PLL [2 copies]</A></td><td align=center>0xd180 - 0xd18e</td><td align=center>0x0000d180 - 0x0000d18e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>dig_com_blk</b></td><td align=center>0xd000 - 0xd19f</td><td align=center>0x0000d000 - 0x0000d19f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd010 - 0xd0ff</td><td align=center>0x0000d010 - 0x0000d0ff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DIG_COM Registers">DIG_COM: common register block for all lanes</A></td><td align=center>0xd100 - 0xd10e</td><td align=center>0x0000d100 - 0x0000d10e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd110 - 0xd18f</td><td align=center>0x0000d110 - 0x0000d18f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DIG_COM_B Registers">DIG_COM_B: common register block for all lanes</A></td><td align=center>0xd190 - 0xd19e</td><td align=center>0x0000d190 - 0x0000d19e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>linktrn_user_blk</b></td><td align=center>0xd080 - 0xd09f</td><td align=center>0x0000d080 - 0x0000d09f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#LINKTRN_USER_RX Registers">LINKTRN_USER_RX: per lane register block [8 copies]</A></td><td align=center>0xd080 - 0xd08e</td><td align=center>0x0000d080 - 0x0000d08e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#LINKTRN_USER_TX Registers">LINKTRN_USER_TX: per lane register block [8 copies]</A></td><td align=center>0xd090 - 0xd097</td><td align=center>0x0000d090 - 0x0000d097</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>tx_pi_8x_pll2x_v1p0_blk</b></td><td align=center>0xd0a0 - 0xd43f</td><td align=center>0x0000d0a0 - 0x0000d43f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TX_PI_8x_pll2x_v1p0 Registers">TX_PI_8x_pll2x_v1p0: per lane register block [8 copies]</A></td><td align=center>0xd0a0 - 0xd0ae</td><td align=center>0x0000d0a0 - 0x0000d0ae</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd0b0 - 0xd42f</td><td align=center>0x0000d0b0 - 0x0000d42f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TX_PI_B_8x_pll2x_v1p0 Registers">TX_PI_B_8x_pll2x_v1p0: per lane register block [8 copies]</A></td><td align=center>0xd430 - 0xd43e</td><td align=center>0x0000d430 - 0x0000d43e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>sigdet_blk</b></td><td align=center>0xd0e0 - 0xd0ef</td><td align=center>0x0000d0e0 - 0x0000d0ef</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#SIGDET Registers">SIGDET: per lane register block [8 copies]</A></td><td align=center>0xd0e0 - 0xd0ec</td><td align=center>0x0000d0e0 - 0x0000d0ec</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd0f0 - 0xd11f</td><td align=center>0x0000d0f0 - 0x0000d11f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>patt_gen_blk</b></td><td align=center>0xd120 - 0xd12f</td><td align=center>0x0000d120 - 0x0000d12f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#PATT_GEN_COM Registers">PATT_GEN_COM: common register block for all lanes</A></td><td align=center>0xd120 - 0xd12e</td><td align=center>0x0000d120 - 0x0000d12e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>tx_fed_blk</b></td><td align=center>0xd130 - 0xd13f</td><td align=center>0x0000d130 - 0x0000d13f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TX_FED Registers">TX_FED: per lane register block [8 copies]</A></td><td align=center>0xd130 - 0xd13e</td><td align=center>0x0000d130 - 0x0000d13e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>pll_cal_com_blk</b></td><td align=center>0xd140 - 0xd14f</td><td align=center>0x0000d140 - 0x0000d14f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#PLL_CAL_COM Registers">PLL_CAL_COM: common register block per PLL [2 copies]</A></td><td align=center>0xd140 - 0xd14a</td><td align=center>0x0000d140 - 0x0000d14a</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>txcom_blk</b></td><td align=center>0xd150 - 0xd15f</td><td align=center>0x0000d150 - 0x0000d15f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TXCOM Registers">TXCOM: common register block for all lanes</A></td><td align=center>0xd150 - 0xd155</td><td align=center>0x0000d150 - 0x0000d155</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>tlb_rx_blk</b></td><td align=center>0xd160 - 0xd16f</td><td align=center>0x0000d160 - 0x0000d16f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TLB_RX Registers">TLB_RX: per lane register block [8 copies]</A></td><td align=center>0xd160 - 0xd16e</td><td align=center>0x0000d160 - 0x0000d16e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>tlb_tx_blk</b></td><td align=center>0xd170 - 0xd17f</td><td align=center>0x0000d170 - 0x0000d17f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TLB_TX Registers">TLB_TX: per lane register block [8 copies]</A></td><td align=center>0xd170 - 0xd17e</td><td align=center>0x0000d170 - 0x0000d17e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd180 - 0xd1df</td><td align=center>0x0000d180 - 0x0000d1df</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>tlb_rx_bc_blk</b></td><td align=center>0xd1e0 - 0xd1ff</td><td align=center>0x0000d1e0 - 0x0000d1ff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TLB_RX_B Registers">TLB_RX_B: per lane register block [8 copies]</A></td><td align=center>0xd1e0 - 0xd1ee</td><td align=center>0x0000d1e0 - 0x0000d1ee</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TLB_RX_C Registers">TLB_RX_C: per lane register block [8 copies]</A></td><td align=center>0xd1f0 - 0xd1fe</td><td align=center>0x0000d1f0 - 0x0000d1fe</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>micro_blk</b></td><td align=center>0xd200 - 0xd22f</td><td align=center>0x0000d200 - 0x0000d22f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#MICRO_A Registers">MICRO_A: micro common register block for all lanes</A></td><td align=center>0xd200 - 0xd20e</td><td align=center>0x0000d200 - 0x0000d20e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#MICRO_B Registers">MICRO_B: micro common register block for all lanes</A></td><td align=center>0xd210 - 0xd21e</td><td align=center>0x0000d210 - 0x0000d21e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#MICRO_C Registers">MICRO_C: micro common register block for all lanes</A></td><td align=center>0xd220 - 0xd22e</td><td align=center>0x0000d220 - 0x0000d22e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#MICRO_D Registers">MICRO_D: micro common register block for all lanes</A></td><td align=center>0xd230 - 0xd233</td><td align=center>0x0000d230 - 0x0000d233</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#MICRO_E Registers">MICRO_E: micro core register block (separate for each micro)</A></td><td align=center>0xd240 - 0xd24e</td><td align=center>0x0000d240 - 0x0000d24e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd250 - 0xd2ff</td><td align=center>0x0000d250 - 0x0000d2ff</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>dac_test_blk</b></td><td align=center>0xd300 - 0xd30f</td><td align=center>0x0000d300 - 0x0000d30f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#DAC_TEST_COM Registers">DAC_TEST_COM: common register block for all lanes</A></td><td align=center>0xd300 - 0xd30b</td><td align=center>0x0000d300 - 0x0000d30b</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>tlb_err_aggr_blk</b></td><td align=center>0xd310 - 0xd31f</td><td align=center>0x0000d310 - 0x0000d31f</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#TLB_ERR_AGGR Registers">TLB_ERR_AGGR: common register block for all lanes</A></td><td align=center>0xd310 - 0xd31e</td><td align=center>0x0000d310 - 0x0000d31e</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  Reserved</td><td align=center>0xd320 - 0xffcf</td><td align=center>0x0000d320 - 0x0000ffcf</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp  <b>mdio</b></td><td align=center>0xffd0 - 0xffdf</td><td align=center>0x0000ffd0 - 0x0000ffdf</td></tr>
<tr>
<td align=left>&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp  <A HREF="#MDIO_MMDSEL_AER_COM Registers">MDIO_MMDSEL_AER_COM: common register block for all lanes</A></td><td align=center>0xffd0 - 0xffde</td><td align=center>0x0000ffd0 - 0x0000ffde</td></tr>
</table><p>
<H1><a NAME="LINKTRN_IEEE_TX Registers">LINKTRN_IEEE_TX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0x0096</td><td><A HREF="#LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_control_register_150">LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_control_register_150</A></td><td>BASE-R PMD control register 150</td></tr>
<tr>
<td align=center>0x0097</td><td><A HREF="#LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_status_register_151">LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_status_register_151</A></td><td>BASE-R PMD status register 151</td></tr>
<tr>
<td align=center>0x009a</td><td><A HREF="#LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_coeff_update_register_154">LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_coeff_update_register_154</A></td><td>BASE-R LD coeff update register 154</td></tr>
<tr>
<td align=center>0x009b</td><td><A HREF="#LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_status_report_register_155">LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_status_report_register_155</A></td><td>BASE-R LD status report register 155</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_control_register_150">LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_control_register_150 - BASE-R PMD control register 150</a></b><br>
Address Offset = 32'h0000_0096<br>
Physical Address = 32'h0000_0096<br>
Verilog CL45 Address = {`LINKTRN_IEEE_TX_A, `linktrnit_BASE_R_PMD_control_register_150_Adr}<br>
Verilog CL22 Address = {`LINKTRN_IEEE_TX_A, 4'h0}, `linktrnit_BASE_R_PMD_control_register_150_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_ieee_training_enable</td>
<td align=left>
1 = Enable the 10GBASE-KR start-up protocol <br>
0 = Disable the 10GBASE-KR start-up protocol <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>linktrn_ieee_restart_training</td>
<td align=left>
1 = Restart 10GBASE-KR linktrn training <br>
0 = Normal operation <br>
(self clearing) <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_IEEE_TX Registers">Return to LINKTRN_IEEE_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_status_register_151">LINKTRN_IEEE_TX_linktrnit_BASE_R_PMD_status_register_151 - BASE-R PMD status register 151</a></b><br>
Address Offset = 32'h0000_0097<br>
Physical Address = 32'h0000_0097<br>
Verilog CL45 Address = {`LINKTRN_IEEE_TX_A, `linktrnit_BASE_R_PMD_status_register_151_Adr}<br>
Verilog CL22 Address = {`LINKTRN_IEEE_TX_A, 4'h0}, `linktrnit_BASE_R_PMD_status_register_151_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_training_failure</td>
<td align=left>
1 = Training failure has been detected <br>
0 = Training failure has not been detected <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_training_status</td>
<td align=left>
1 = Start-up protocol in progress <br>
0 = Start-up protocol complete <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_frame_lock</td>
<td align=left>
1 = Training frame delineation detected <br>
0 = Training frame delineation not detected <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_receiver_status</td>
<td align=left>
1 = Receiver trained and ready to receive data <br>
0 = Receiver training <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_IEEE_TX Registers">Return to LINKTRN_IEEE_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_coeff_update_register_154">LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_coeff_update_register_154 - BASE-R LD coeff update register 154</a></b><br>
Address Offset = 32'h0000_009a<br>
Physical Address = 32'h0000_009a<br>
Verilog CL45 Address = {`LINKTRN_IEEE_TX_A, `linktrnit_BASE_R_LD_coeff_update_register_154_Adr}<br>
Verilog CL22 Address = {`LINKTRN_IEEE_TX_A, 4'h0}, `linktrnit_BASE_R_LD_coeff_update_register_154_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_ld_coeff_update</td>
<td align=left>
This register reflects the first 16-bit Word of the outgoing training frame <br>
sent by the Local Device <br>
This register is not writeable <br>
linktrn supports link training for IEEE/OIF/FC standards <br>
Please see the apprpopiate standards for register bit definitions. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_IEEE_TX Registers">Return to LINKTRN_IEEE_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_status_report_register_155">LINKTRN_IEEE_TX_linktrnit_BASE_R_LD_status_report_register_155 - BASE-R LD status report register 155</a></b><br>
Address Offset = 32'h0000_009b<br>
Physical Address = 32'h0000_009b<br>
Verilog CL45 Address = {`LINKTRN_IEEE_TX_A, `linktrnit_BASE_R_LD_status_report_register_155_Adr}<br>
Verilog CL22 Address = {`LINKTRN_IEEE_TX_A, 4'h0}, `linktrnit_BASE_R_LD_status_report_register_155_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_ld_status_report</td>
<td align=left>
This register reflects the second 16-bit Word of the outgoing training frame <br>
most recently recieived from the Link Partner <br>
linktrn supports link training for IEEE/OIF/FC standards <br>
Please see the apprpopiate standards for register bit definitions. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_IEEE_TX Registers">Return to LINKTRN_IEEE_TX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="LINKTRN_IEEE_RX Registers">LINKTRN_IEEE_RX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0x0098</td><td><A HREF="#LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_coeff_update_register_152">LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_coeff_update_register_152</A></td><td>BASE-R LP coeff update register 152</td></tr>
<tr>
<td align=center>0x0099</td><td><A HREF="#LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_status_report_register_153">LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_status_report_register_153</A></td><td>BASE-R LP status report register 153</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_coeff_update_register_152">LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_coeff_update_register_152 - BASE-R LP coeff update register 152</a></b><br>
Address Offset = 32'h0000_0098<br>
Physical Address = 32'h0000_0098<br>
Verilog CL45 Address = {`LINKTRN_IEEE_RX_A, `linktrnir_BASE_R_LP_coeff_update_register_152_Adr}<br>
Verilog CL22 Address = {`LINKTRN_IEEE_RX_A, 4'h0}, `linktrnir_BASE_R_LP_coeff_update_register_152_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_lp_coeff_update</td>
<td align=left>
This register reflects the first 16-bit Word of the training frame <br>
most recently recieived from the Link Partner <br>
This register is not writeable when linktrn training is disabled as <br>
indicated in the IEEE standard <br>
linktrn supports link training for IEEE/OIF/FC standards <br>
Please see the apprpopiate standards for register bit definitions. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_IEEE_RX Registers">Return to LINKTRN_IEEE_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_status_report_register_153">LINKTRN_IEEE_RX_linktrnir_BASE_R_LP_status_report_register_153 - BASE-R LP status report register 153</a></b><br>
Address Offset = 32'h0000_0099<br>
Physical Address = 32'h0000_0099<br>
Verilog CL45 Address = {`LINKTRN_IEEE_RX_A, `linktrnir_BASE_R_LP_status_report_register_153_Adr}<br>
Verilog CL22 Address = {`LINKTRN_IEEE_RX_A, 4'h0}, `linktrnir_BASE_R_LP_status_report_register_153_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_ieee_lp_status_report</td>
<td align=left>
This register reflects the second 16-bit Word of the training frame <br>
most recently recieived from the Link Partner <br>
linktrn supports link training for IEEE/OIF/FC standards <br>
Please see the apprpopiate standards for register bit definitions. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_IEEE_RX Registers">Return to LINKTRN_IEEE_RX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_AFE1 Registers">DSC_AFE1: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd005</td><td><A HREF="#DSC_AFE1_rxa_slicer_offset_adj_1">DSC_AFE1_rxa_slicer_offset_adj_1</A></td><td>rxa_slicer_offset_1 register.</td></tr>
<tr>
<td align=center>0xd006</td><td><A HREF="#DSC_AFE1_rxa_slicer_offset_adj_2">DSC_AFE1_rxa_slicer_offset_adj_2</A></td><td>rxa_slicer_offset_2 register.</td></tr>
<tr>
<td align=center>0xd007</td><td><A HREF="#DSC_AFE1_rxa_slicer_offset_adj_3">DSC_AFE1_rxa_slicer_offset_adj_3</A></td><td>rxa_slicer_offset_3 register.</td></tr>
<tr>
<td align=center>0xd008</td><td><A HREF="#DSC_AFE1_rxa_slicer_offset_adj_4">DSC_AFE1_rxa_slicer_offset_adj_4</A></td><td>rxa_slicer_offset_4 register.</td></tr>
<tr>
<td align=center>0xd009</td><td><A HREF="#DSC_AFE1_rxa_slicer_offset_adj_5">DSC_AFE1_rxa_slicer_offset_adj_5</A></td><td>rxa_slicer_offset_5 register.</td></tr>
<tr>
<td align=center>0xd00a</td><td><A HREF="#DSC_AFE1_rxb_slicer_offset_adj_1">DSC_AFE1_rxb_slicer_offset_adj_1</A></td><td>rxb_slicer_offset_1 register.</td></tr>
<tr>
<td align=center>0xd00b</td><td><A HREF="#DSC_AFE1_rxb_slicer_offset_adj_2">DSC_AFE1_rxb_slicer_offset_adj_2</A></td><td>rxb_slicer_offset_2 register.</td></tr>
<tr>
<td align=center>0xd00c</td><td><A HREF="#DSC_AFE1_rxb_slicer_offset_adj_3">DSC_AFE1_rxb_slicer_offset_adj_3</A></td><td>rxb_slicer_offset_3 register.</td></tr>
<tr>
<td align=center>0xd00d</td><td><A HREF="#DSC_AFE1_rxb_slicer_offset_adj_4">DSC_AFE1_rxb_slicer_offset_adj_4</A></td><td>rxb_slicer_offset_4 register.</td></tr>
<tr>
<td align=center>0xd00e</td><td><A HREF="#DSC_AFE1_rxb_slicer_offset_adj_5">DSC_AFE1_rxb_slicer_offset_adj_5</A></td><td>rxb_slicer_offset_5 register.</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_AFE1_rxa_slicer_offset_adj_1">DSC_AFE1_rxa_slicer_offset_adj_1 - rxa_slicer_offset_1 register.</a></b><br>
Address Offset = 32'h0000_d005<br>
Physical Address = 32'h0000_d005<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxa_slicer_offset_adj_1_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxa_slicer_offset_adj_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_d5</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, p4, NRZ-DFE <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_d4</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, p3 only<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxa_slicer_offset_adj_2">DSC_AFE1_rxa_slicer_offset_adj_2 - rxa_slicer_offset_2 register.</a></b><br>
Address Offset = 32'h0000_d006<br>
Physical Address = 32'h0000_d006<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxa_slicer_offset_adj_2_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxa_slicer_offset_adj_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_d3</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, p1 only<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_d2</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, m1, NS <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxa_slicer_offset_adj_3">DSC_AFE1_rxa_slicer_offset_adj_3 - rxa_slicer_offset_3 register.</a></b><br>
Address Offset = 32'h0000_d007<br>
Physical Address = 32'h0000_d007<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxa_slicer_offset_adj_3_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxa_slicer_offset_adj_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_d1</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, m3, NS <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_d0</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxa_slicer_offset_adj_4">DSC_AFE1_rxa_slicer_offset_adj_4 - rxa_slicer_offset_4 register.</a></b><br>
Address Offset = 32'h0000_d008<br>
Physical Address = 32'h0000_d008<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxa_slicer_offset_adj_4_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxa_slicer_offset_adj_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_p2</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, NS, NRZ-DFE<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_p1</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, NS<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxa_slicer_offset_adj_5">DSC_AFE1_rxa_slicer_offset_adj_5 - rxa_slicer_offset_5 register.</a></b><br>
Address Offset = 32'h0000_d009<br>
Physical Address = 32'h0000_d009<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxa_slicer_offset_adj_5_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxa_slicer_offset_adj_5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_p0</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_slicer_offset_adj_cal_lms</td>
<td align=left>
signed 2's complement rxa slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxb_slicer_offset_adj_1">DSC_AFE1_rxb_slicer_offset_adj_1 - rxb_slicer_offset_1 register.</a></b><br>
Address Offset = 32'h0000_d00a<br>
Physical Address = 32'h0000_d00a<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxb_slicer_offset_adj_1_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxb_slicer_offset_adj_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_d5</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, p4, NRZ-DFE <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_d4</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, p3 only<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxb_slicer_offset_adj_2">DSC_AFE1_rxb_slicer_offset_adj_2 - rxb_slicer_offset_2 register.</a></b><br>
Address Offset = 32'h0000_d00b<br>
Physical Address = 32'h0000_d00b<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxb_slicer_offset_adj_2_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxb_slicer_offset_adj_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_d3</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, p1 only<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_d2</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, m1, NS <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxb_slicer_offset_adj_3">DSC_AFE1_rxb_slicer_offset_adj_3 - rxb_slicer_offset_3 register.</a></b><br>
Address Offset = 32'h0000_d00c<br>
Physical Address = 32'h0000_d00c<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxb_slicer_offset_adj_3_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxb_slicer_offset_adj_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_d1</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, m3, NS <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_d0</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxb_slicer_offset_adj_4">DSC_AFE1_rxb_slicer_offset_adj_4 - rxb_slicer_offset_4 register.</a></b><br>
Address Offset = 32'h0000_d00d<br>
Physical Address = 32'h0000_d00d<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxb_slicer_offset_adj_4_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxb_slicer_offset_adj_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_p2</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, NS, NRZ-DFE<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_p1</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, NS<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE1_rxb_slicer_offset_adj_5">DSC_AFE1_rxb_slicer_offset_adj_5 - rxb_slicer_offset_5 register.</a></b><br>
Address Offset = 32'h0000_d00e<br>
Physical Address = 32'h0000_d00e<br>
Verilog CL45 Address = {`DSC_AFE1_A, `rxb_slicer_offset_adj_5_Adr}<br>
Verilog CL22 Address = {`DSC_AFE1_A, 4'h0}, `rxb_slicer_offset_adj_5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_p0</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_slicer_offset_adj_cal_lms</td>
<td align=left>
signed 2's complement rxb slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE1 Registers">Return to DSC_AFE1: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_AFE2 Registers">DSC_AFE2: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd013</td><td><A HREF="#DSC_AFE2_rx_dfe_tap4_ab">DSC_AFE2_rx_dfe_tap4_ab</A></td><td>rx_dfe_tap4_ab register.</td></tr>
<tr>
<td align=center>0xd014</td><td><A HREF="#DSC_AFE2_rx_dfe_tap4_cd">DSC_AFE2_rx_dfe_tap4_cd</A></td><td>rx_dfe_tap4_cd register.</td></tr>
<tr>
<td align=center>0xd015</td><td><A HREF="#DSC_AFE2_rx_dfe_tap5_abcd">DSC_AFE2_rx_dfe_tap5_abcd</A></td><td>rx_dfe_tap5_abcd register.</td></tr>
<tr>
<td align=center>0xd016</td><td><A HREF="#DSC_AFE2_rx_dfe_tap6_abcd">DSC_AFE2_rx_dfe_tap6_abcd</A></td><td>rx_dfe_tap6_abcd register.</td></tr>
<tr>
<td align=center>0xd017</td><td><A HREF="#DSC_AFE2_rx_dfe_tap7_abcd">DSC_AFE2_rx_dfe_tap7_abcd</A></td><td>rx_dfe_tap7_abcd register.</td></tr>
<tr>
<td align=center>0xd018</td><td><A HREF="#DSC_AFE2_rx_dfe_tap8_abcd">DSC_AFE2_rx_dfe_tap8_abcd</A></td><td>rx_dfe_tap8_abcd register.</td></tr>
<tr>
<td align=center>0xd019</td><td><A HREF="#DSC_AFE2_rx_dfe_tap9_abcd">DSC_AFE2_rx_dfe_tap9_abcd</A></td><td>rx_dfe_tap9_abcd register.</td></tr>
<tr>
<td align=center>0xd01a</td><td><A HREF="#DSC_AFE2_rxc_slicer_offset_adj_1">DSC_AFE2_rxc_slicer_offset_adj_1</A></td><td>rxc_slicer_offset_1 register.</td></tr>
<tr>
<td align=center>0xd01b</td><td><A HREF="#DSC_AFE2_rxc_slicer_offset_adj_2">DSC_AFE2_rxc_slicer_offset_adj_2</A></td><td>rxc_slicer_offset_2 register.</td></tr>
<tr>
<td align=center>0xd01c</td><td><A HREF="#DSC_AFE2_rxc_slicer_offset_adj_3">DSC_AFE2_rxc_slicer_offset_adj_3</A></td><td>rxc_slicer_offset_3 register.</td></tr>
<tr>
<td align=center>0xd01d</td><td><A HREF="#DSC_AFE2_rxc_slicer_offset_adj_4">DSC_AFE2_rxc_slicer_offset_adj_4</A></td><td>rxc_slicer_offset_4 register.</td></tr>
<tr>
<td align=center>0xd01e</td><td><A HREF="#DSC_AFE2_rxc_slicer_offset_adj_5">DSC_AFE2_rxc_slicer_offset_adj_5</A></td><td>rxc_slicer_offset_5 register.</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap4_ab">DSC_AFE2_rx_dfe_tap4_ab - rx_dfe_tap4_ab register.</a></b><br>
Address Offset = 32'h0000_d013<br>
Physical Address = 32'h0000_d013<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap4_ab_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap4_ab_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap4</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap4</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap4_cd">DSC_AFE2_rx_dfe_tap4_cd - rx_dfe_tap4_cd register.</a></b><br>
Address Offset = 32'h0000_d014<br>
Physical Address = 32'h0000_d014<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap4_cd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap4_cd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap4</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap4</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap5_abcd">DSC_AFE2_rx_dfe_tap5_abcd - rx_dfe_tap5_abcd register.</a></b><br>
Address Offset = 32'h0000_d015<br>
Physical Address = 32'h0000_d015<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap5_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap5_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap5</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap5</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap5</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap5</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap6_abcd">DSC_AFE2_rx_dfe_tap6_abcd - rx_dfe_tap6_abcd register.</a></b><br>
Address Offset = 32'h0000_d016<br>
Physical Address = 32'h0000_d016<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap6_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap6_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap6</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap6</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap6</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap6</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap7_abcd">DSC_AFE2_rx_dfe_tap7_abcd - rx_dfe_tap7_abcd register.</a></b><br>
Address Offset = 32'h0000_d017<br>
Physical Address = 32'h0000_d017<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap7_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap7_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap7</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap7</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap7</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap7</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap8_abcd">DSC_AFE2_rx_dfe_tap8_abcd - rx_dfe_tap8_abcd register.</a></b><br>
Address Offset = 32'h0000_d018<br>
Physical Address = 32'h0000_d018<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap8_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap8_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap8</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap8</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap8</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap8</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rx_dfe_tap9_abcd">DSC_AFE2_rx_dfe_tap9_abcd - rx_dfe_tap9_abcd register.</a></b><br>
Address Offset = 32'h0000_d019<br>
Physical Address = 32'h0000_d019<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rx_dfe_tap9_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rx_dfe_tap9_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap9</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap9</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap9</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap9</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rxc_slicer_offset_adj_1">DSC_AFE2_rxc_slicer_offset_adj_1 - rxc_slicer_offset_1 register.</a></b><br>
Address Offset = 32'h0000_d01a<br>
Physical Address = 32'h0000_d01a<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rxc_slicer_offset_adj_1_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rxc_slicer_offset_adj_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_d5</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, p4, NRZ-DFE <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_d4</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, p3 only<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rxc_slicer_offset_adj_2">DSC_AFE2_rxc_slicer_offset_adj_2 - rxc_slicer_offset_2 register.</a></b><br>
Address Offset = 32'h0000_d01b<br>
Physical Address = 32'h0000_d01b<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rxc_slicer_offset_adj_2_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rxc_slicer_offset_adj_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_d3</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, p1 only<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_d2</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, m1, NS <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rxc_slicer_offset_adj_3">DSC_AFE2_rxc_slicer_offset_adj_3 - rxc_slicer_offset_3 register.</a></b><br>
Address Offset = 32'h0000_d01c<br>
Physical Address = 32'h0000_d01c<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rxc_slicer_offset_adj_3_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rxc_slicer_offset_adj_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_d1</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, m3, NS <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_d0</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rxc_slicer_offset_adj_4">DSC_AFE2_rxc_slicer_offset_adj_4 - rxc_slicer_offset_4 register.</a></b><br>
Address Offset = 32'h0000_d01d<br>
Physical Address = 32'h0000_d01d<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rxc_slicer_offset_adj_4_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rxc_slicer_offset_adj_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_p2</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, NS, NRZ-DFE<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_p1</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, NS<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE2_rxc_slicer_offset_adj_5">DSC_AFE2_rxc_slicer_offset_adj_5 - rxc_slicer_offset_5 register.</a></b><br>
Address Offset = 32'h0000_d01e<br>
Physical Address = 32'h0000_d01e<br>
Verilog CL45 Address = {`DSC_AFE2_A, `rxc_slicer_offset_adj_5_Adr}<br>
Verilog CL22 Address = {`DSC_AFE2_A, 4'h0}, `rxc_slicer_offset_adj_5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_p0</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_slicer_offset_adj_cal_lms</td>
<td align=left>
signed 2's complement rxc slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE2 Registers">Return to DSC_AFE2: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_AFE3 Registers">DSC_AFE3: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd020</td><td><A HREF="#DSC_AFE3_rx_dfe_tap10_abcd">DSC_AFE3_rx_dfe_tap10_abcd</A></td><td>rx_dfe_tap10_abcd register.</td></tr>
<tr>
<td align=center>0xd021</td><td><A HREF="#DSC_AFE3_rx_dfe_tap11_abcd">DSC_AFE3_rx_dfe_tap11_abcd</A></td><td>rx_dfe_tap11_abcd register.</td></tr>
<tr>
<td align=center>0xd022</td><td><A HREF="#DSC_AFE3_rx_dfe_tap12_abcd">DSC_AFE3_rx_dfe_tap12_abcd</A></td><td>rx_dfe_tap12_abcd register.</td></tr>
<tr>
<td align=center>0xd023</td><td><A HREF="#DSC_AFE3_rx_dfe_tap13_abcd">DSC_AFE3_rx_dfe_tap13_abcd</A></td><td>rx_dfe_tap13_abcd register.</td></tr>
<tr>
<td align=center>0xd024</td><td><A HREF="#DSC_AFE3_rx_dfe_tap14_abcd">DSC_AFE3_rx_dfe_tap14_abcd</A></td><td>rx_dfe_tap14_abcd register.</td></tr>
<tr>
<td align=center>0xd025</td><td><A HREF="#DSC_AFE3_rx_dfe_tap7_8_mux_abcd">DSC_AFE3_rx_dfe_tap7_8_mux_abcd</A></td><td>rx_dfe_tap7_8_mux_abcd register.</td></tr>
<tr>
<td align=center>0xd026</td><td><A HREF="#DSC_AFE3_rx_dfe_tap9_10_mux_abcd">DSC_AFE3_rx_dfe_tap9_10_mux_abcd</A></td><td>rx_dfe_tap9_10_mux_abcd register.</td></tr>
<tr>
<td align=center>0xd027</td><td><A HREF="#DSC_AFE3_rx_dfe_tap11_12_mux_abcd">DSC_AFE3_rx_dfe_tap11_12_mux_abcd</A></td><td>rx_dfe_tap11_12_mux_abcd register.</td></tr>
<tr>
<td align=center>0xd028</td><td><A HREF="#DSC_AFE3_rx_dfe_tap13_14_mux_abcd">DSC_AFE3_rx_dfe_tap13_14_mux_abcd</A></td><td>rx_dfe_tap13_14_mux_abcd register.</td></tr>
<tr>
<td align=center>0xd029</td><td><A HREF="#DSC_AFE3_load_presets">DSC_AFE3_load_presets</A></td><td>load_presets.</td></tr>
<tr>
<td align=center>0xd02a</td><td><A HREF="#DSC_AFE3_rxd_slicer_offset_adj_1">DSC_AFE3_rxd_slicer_offset_adj_1</A></td><td>rxd_slicer_offset_1 register.</td></tr>
<tr>
<td align=center>0xd02b</td><td><A HREF="#DSC_AFE3_rxd_slicer_offset_adj_2">DSC_AFE3_rxd_slicer_offset_adj_2</A></td><td>rxd_slicer_offset_2 register.</td></tr>
<tr>
<td align=center>0xd02c</td><td><A HREF="#DSC_AFE3_rxd_slicer_offset_adj_3">DSC_AFE3_rxd_slicer_offset_adj_3</A></td><td>rxd_slicer_offset_3 register.</td></tr>
<tr>
<td align=center>0xd02d</td><td><A HREF="#DSC_AFE3_rxd_slicer_offset_adj_4">DSC_AFE3_rxd_slicer_offset_adj_4</A></td><td>rxd_slicer_offset_4 register.</td></tr>
<tr>
<td align=center>0xd02e</td><td><A HREF="#DSC_AFE3_rxd_slicer_offset_adj_5">DSC_AFE3_rxd_slicer_offset_adj_5</A></td><td>rxd_slicer_offset_5 register.</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap10_abcd">DSC_AFE3_rx_dfe_tap10_abcd - rx_dfe_tap10_abcd register.</a></b><br>
Address Offset = 32'h0000_d020<br>
Physical Address = 32'h0000_d020<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap10_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap10_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap10</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap10</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap10</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap10</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap11_abcd">DSC_AFE3_rx_dfe_tap11_abcd - rx_dfe_tap11_abcd register.</a></b><br>
Address Offset = 32'h0000_d021<br>
Physical Address = 32'h0000_d021<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap11_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap11_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap11</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap11</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap11</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap11</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap12_abcd">DSC_AFE3_rx_dfe_tap12_abcd - rx_dfe_tap12_abcd register.</a></b><br>
Address Offset = 32'h0000_d022<br>
Physical Address = 32'h0000_d022<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap12_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap12_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap12</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap12</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap12</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap12</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap13_abcd">DSC_AFE3_rx_dfe_tap13_abcd - rx_dfe_tap13_abcd register.</a></b><br>
Address Offset = 32'h0000_d023<br>
Physical Address = 32'h0000_d023<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap13_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap13_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap13</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap13</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap13</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap13</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap14_abcd">DSC_AFE3_rx_dfe_tap14_abcd - rx_dfe_tap14_abcd register.</a></b><br>
Address Offset = 32'h0000_d024<br>
Physical Address = 32'h0000_d024<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap14_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap14_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap14</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap14</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap14</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap14</td>
<td align=left>
signed 2's complement +/-7, 1 LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap7_8_mux_abcd">DSC_AFE3_rx_dfe_tap7_8_mux_abcd - rx_dfe_tap7_8_mux_abcd register.</a></b><br>
Address Offset = 32'h0000_d025<br>
Physical Address = 32'h0000_d025<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap7_8_mux_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap7_8_mux_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap7_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap8_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap7_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap8_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap7_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap8_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap7_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap8_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap9_10_mux_abcd">DSC_AFE3_rx_dfe_tap9_10_mux_abcd - rx_dfe_tap9_10_mux_abcd register.</a></b><br>
Address Offset = 32'h0000_d026<br>
Physical Address = 32'h0000_d026<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap9_10_mux_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap9_10_mux_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap9_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap10_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap9_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap10_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap9_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap10_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap9_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap10_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap11_12_mux_abcd">DSC_AFE3_rx_dfe_tap11_12_mux_abcd - rx_dfe_tap11_12_mux_abcd register.</a></b><br>
Address Offset = 32'h0000_d027<br>
Physical Address = 32'h0000_d027<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap11_12_mux_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap11_12_mux_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap11_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap12_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap11_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap12_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap11_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap12_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap11_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap12_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rx_dfe_tap13_14_mux_abcd">DSC_AFE3_rx_dfe_tap13_14_mux_abcd - rx_dfe_tap13_14_mux_abcd register.</a></b><br>
Address Offset = 32'h0000_d028<br>
Physical Address = 32'h0000_d028<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rx_dfe_tap13_14_mux_abcd_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rx_dfe_tap13_14_mux_abcd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap13_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap14_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap13_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap14_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap13_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap14_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap13_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap14_mux</td>
<td align=left>
tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_load_presets">DSC_AFE3_load_presets - load_presets.</a></b><br>
Address Offset = 32'h0000_d029<br>
Physical Address = 32'h0000_d029<br>
Verilog CL45 Address = {`DSC_AFE3_A, `load_presets_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `load_presets_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>preset_afe</td>
<td align=left>
Load presets for analog interface Registers<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rxd_slicer_offset_adj_1">DSC_AFE3_rxd_slicer_offset_adj_1 - rxd_slicer_offset_1 register.</a></b><br>
Address Offset = 32'h0000_d02a<br>
Physical Address = 32'h0000_d02a<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rxd_slicer_offset_adj_1_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rxd_slicer_offset_adj_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_d5</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, p4, NRZ-DFE <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_d4</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, p3 only<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rxd_slicer_offset_adj_2">DSC_AFE3_rxd_slicer_offset_adj_2 - rxd_slicer_offset_2 register.</a></b><br>
Address Offset = 32'h0000_d02b<br>
Physical Address = 32'h0000_d02b<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rxd_slicer_offset_adj_2_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rxd_slicer_offset_adj_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_d3</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, p1 only<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_d2</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, m1, NS <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rxd_slicer_offset_adj_3">DSC_AFE3_rxd_slicer_offset_adj_3 - rxd_slicer_offset_3 register.</a></b><br>
Address Offset = 32'h0000_d02c<br>
Physical Address = 32'h0000_d02c<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rxd_slicer_offset_adj_3_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rxd_slicer_offset_adj_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_d1</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, m3, NS <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_d0</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, m5, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rxd_slicer_offset_adj_4">DSC_AFE3_rxd_slicer_offset_adj_4 - rxd_slicer_offset_4 register.</a></b><br>
Address Offset = 32'h0000_d02d<br>
Physical Address = 32'h0000_d02d<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rxd_slicer_offset_adj_4_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rxd_slicer_offset_adj_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_p2</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, NS, NRZ-DFE<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_p1</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, NS<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_AFE3_rxd_slicer_offset_adj_5">DSC_AFE3_rxd_slicer_offset_adj_5 - rxd_slicer_offset_5 register.</a></b><br>
Address Offset = 32'h0000_d02e<br>
Physical Address = 32'h0000_d02e<br>
Verilog CL45 Address = {`DSC_AFE3_A, `rxd_slicer_offset_adj_5_Adr}<br>
Verilog CL22 Address = {`DSC_AFE3_A, 4'h0}, `rxd_slicer_offset_adj_5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_p0</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_slicer_offset_adj_cal_lms</td>
<td align=left>
signed 2's complement rxd slicer offset adjust for ES, NS, NRZ-DFE, NRZ-VSR<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_AFE3 Registers">Return to DSC_AFE3: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_A Registers">DSC_A: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd030</td><td><A HREF="#DSC_A_trnsum_pat_ctrl_0a">DSC_A_trnsum_pat_ctrl_0a</A></td><td>trnsum pattern control 0a register.</td></tr>
<tr>
<td align=center>0xd031</td><td><A HREF="#DSC_A_trnsum_pat_ctrl_0b">DSC_A_trnsum_pat_ctrl_0b</A></td><td>trnsum pattern control 0b register.</td></tr>
<tr>
<td align=center>0xd032</td><td><A HREF="#DSC_A_trnsum_pat_ctrl_1a">DSC_A_trnsum_pat_ctrl_1a</A></td><td>trnsum pattern control 1a register.</td></tr>
<tr>
<td align=center>0xd033</td><td><A HREF="#DSC_A_trnsum_pat_ctrl_1b">DSC_A_trnsum_pat_ctrl_1b</A></td><td>trnsum pattern control 1b register.</td></tr>
<tr>
<td align=center>0xd034</td><td><A HREF="#DSC_A_trnsum_pat_ctrl_2a">DSC_A_trnsum_pat_ctrl_2a</A></td><td>trnsum pattern control 2a register.</td></tr>
<tr>
<td align=center>0xd035</td><td><A HREF="#DSC_A_trnsum_pat_ctrl_2b">DSC_A_trnsum_pat_ctrl_2b</A></td><td>trnsum pattern control 2b register.</td></tr>
<tr>
<td align=center>0xd036</td><td><A HREF="#DSC_A_blw_ctrl_1">DSC_A_blw_ctrl_1</A></td><td>BLW canceller control register 1.</td></tr>
<tr>
<td align=center>0xd037</td><td><A HREF="#DSC_A_blw_ctrl_2">DSC_A_blw_ctrl_2</A></td><td>BLW canceller control register 2.</td></tr>
<tr>
<td align=center>0xd038</td><td><A HREF="#DSC_A_blw_ctrl_3">DSC_A_blw_ctrl_3</A></td><td>BLW canceller control register 3.</td></tr>
<tr>
<td align=center>0xd039</td><td><A HREF="#DSC_A_blw_ctrl_4">DSC_A_blw_ctrl_4</A></td><td>BLW canceller control register 4.</td></tr>
<tr>
<td align=center>0xd03a</td><td><A HREF="#DSC_A_blw_ctrl_5">DSC_A_blw_ctrl_5</A></td><td>BLW canceller control register 5.</td></tr>
<tr>
<td align=center>0xd03b</td><td><A HREF="#DSC_A_blw_status_1_type">DSC_A_blw_status_1_type</A></td><td>BLW canceller status register 1</td></tr>
<tr>
<td align=center>0xd03c</td><td><A HREF="#DSC_A_blw_status_2_type">DSC_A_blw_status_2_type</A></td><td>BLW canceller status register 2</td></tr>
<tr>
<td align=center>0xd03d</td><td><A HREF="#DSC_A_dsc_uc_ctrl">DSC_A_dsc_uc_ctrl</A></td><td>DSC uC Control</td></tr>
<tr>
<td align=center>0xd03e</td><td><A HREF="#DSC_A_dsc_scratch">DSC_A_dsc_scratch</A></td><td>DSC uC Scratch</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_A_trnsum_pat_ctrl_0a">DSC_A_trnsum_pat_ctrl_0a - trnsum pattern control 0a register.</a></b><br>
Address Offset = 32'h0000_d030<br>
Physical Address = 32'h0000_d030<br>
Verilog CL45 Address = {`DSC_A_A, `trnsum_pat_ctrl_0a_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `trnsum_pat_ctrl_0a_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_inv_pattern_en</td>
<td align=left>
enables inverted pattern matching.<br>
This mode is only supported in NRZ modes.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_edge_pattern_en</td>
<td align=left>
enables pattern matching on edges {-6,-5,-4,-3,-2,-1,data,0,1,2}.<br>
 where a number (eg: -4) represents an edge between d[-4] and d[-3].<br>
This mode is only supported in NRZ modes.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_full_check_off</td>
<td align=left>
one symbol location per interleave is enabled every rclk20. <br>
 locations enabled [2,7,12,17] <> interleave [c, d, a, b]<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_0</td>
<td align=left>
Related to the pattern based conditioning of trnsum.<br>
Pattern Match sel | pattern0 | pattern1 | pattern2 <br>
-------------------------------------------------- <br>
nrz						&nbsp &nbsp&nbsp | rx data&nbsp | {*1}&nbsp &nbsp&nbsp | {*2}&nbsp &nbsp&nbsp <br>
pam4						&nbsp &nbsp&nbsp | lsb/bit0 | msb/bit1 | {*2}&nbsp &nbsp&nbsp <br>
pam4 tbd&nbsp symbols 				&nbsp &nbsp&nbsp | lsb/bit0 | bit1&nbsp &nbsp&nbsp | bit2 (msb of the symbol)&nbsp &nbsp&nbsp <br>
pam4 tbd dfe data 				&nbsp &nbsp&nbsp | lsb&nbsp &nbsp &nbsp | msb&nbsp &nbsp &nbsp | {*2}&nbsp &nbsp&nbsp <br>
lms&nbsp &nbsp &nbsp &nbsp &nbsp 					&nbsp &nbsp&nbsp | lms&nbsp &nbsp &nbsp | {*1}&nbsp &nbsp&nbsp | {*2}&nbsp &nbsp&nbsp <br>
{*1}: set trnsum_pattern_1_bit_en to 0. <br>
{*2}: set trnsum_pattern_2_bit_en to 0. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_trnsum_pat_ctrl_0b">DSC_A_trnsum_pat_ctrl_0b - trnsum pattern control 0b register.</a></b><br>
Address Offset = 32'h0000_d031<br>
Physical Address = 32'h0000_d031<br>
Verilog CL45 Address = {`DSC_A_A, `trnsum_pat_ctrl_0b_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `trnsum_pat_ctrl_0b_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_0_bit_en</td>
<td align=left>
pattern mask 0 - corresponds to pattern_0See desciption of trnsum_pattern_0<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_trnsum_pat_ctrl_1a">DSC_A_trnsum_pat_ctrl_1a - trnsum pattern control 1a register.</a></b><br>
Address Offset = 32'h0000_d032<br>
Physical Address = 32'h0000_d032<br>
Verilog CL45 Address = {`DSC_A_A, `trnsum_pat_ctrl_1a_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `trnsum_pat_ctrl_1a_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_1</td>
<td align=left>
pattern to be compared.<br>
See desciption of trnsum_pattern_0<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_trnsum_pat_ctrl_1b">DSC_A_trnsum_pat_ctrl_1b - trnsum pattern control 1b register.</a></b><br>
Address Offset = 32'h0000_d033<br>
Physical Address = 32'h0000_d033<br>
Verilog CL45 Address = {`DSC_A_A, `trnsum_pat_ctrl_1b_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `trnsum_pat_ctrl_1b_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_1_bit_en</td>
<td align=left>
pattern mask&nbsp 1 - corresponds to pattern 1<br>
See desciption of trnsum_pattern_0<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_trnsum_pat_ctrl_2a">DSC_A_trnsum_pat_ctrl_2a - trnsum pattern control 2a register.</a></b><br>
Address Offset = 32'h0000_d034<br>
Physical Address = 32'h0000_d034<br>
Verilog CL45 Address = {`DSC_A_A, `trnsum_pat_ctrl_2a_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `trnsum_pat_ctrl_2a_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_2</td>
<td align=left>
pattern to be compared. See desciption of trnsum_pattern_0<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_trnsum_pat_ctrl_2b">DSC_A_trnsum_pat_ctrl_2b - trnsum pattern control 2b register.</a></b><br>
Address Offset = 32'h0000_d035<br>
Physical Address = 32'h0000_d035<br>
Verilog CL45 Address = {`DSC_A_A, `trnsum_pat_ctrl_2b_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `trnsum_pat_ctrl_2b_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_2_bit_en</td>
<td align=left>
pattern mask 2 - corresponds to pattern 2<br>
See desciption of trnsum_pattern_0<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_ctrl_1">DSC_A_blw_ctrl_1 - BLW canceller control register 1.</a></b><br>
Address Offset = 32'h0000_d036<br>
Physical Address = 32'h0000_d036<br>
Verilog CL45 Address = {`DSC_A_A, `blw_ctrl_1_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_ctrl_1_A<br>
Reset Value = 16'h4296<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_en</td>
<td align=left>
 BLW Canceller enable. 1'b1 will enable the BLW canceller and 1'b0 will disable it. When BLW block is disabled then BLW output will be forced to 1'b0.
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_gain_frz</td>
<td align=left>
 Freeze gain adaptation and maintain a constant value. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_phase_slicer_invert</td>
<td align=left>
 Invert the polarity of the phase slicer data from the CDR. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_output_invert</td>
<td align=left>
 Invert the polarity of the BLW canceller output. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_reset</td>
<td align=left>
 Active high reset control. Reset the internal state of the entire BLW canceller block. Should be asserted while blw_en=0. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_max_amp_sel</td>
<td align=left>
 Select bit for blw_max_amp status sources. 0 -> blw_max_amp status field will report the peak detctor output. 1 -> blw_max_amp status field will report
the peak detector input (i.e. 8 bits dc_corr post saturation) <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_lpf_coef_exp</td>
<td align=left>
Pole frequency tuning coefficient exponent (2-bit selector) <br>
&nbsp 00 (shift right by 14) <br>
&nbsp 01 (shift right by 15) <br>
&nbsp 10 (shift right by 16) <br>
&nbsp 11 (shift right by 17) <br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_spare_cntl_0</td>
<td align=left>
 Spare control registers. Reserved for future use.<br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_lpf_coef_mant</td>
<td align=left>
Pole frequency tuning coefficient mantissa (6-bit unsigned number).<br>
Reset value is 0x16.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_ctrl_2">DSC_A_blw_ctrl_2 - BLW canceller control register 2.</a></b><br>
Address Offset = 32'h0000_d037<br>
Physical Address = 32'h0000_d037<br>
Verilog CL45 Address = {`DSC_A_A, `blw_ctrl_2_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_ctrl_2_A<br>
Reset Value = 16'h1002<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_dac_8b_en</td>
<td align=left>
 Saturate the BLW output to either 7-bits (1'b0) or 8-bits (1'b1).<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_dac_integ_en</td>
<td align=left>
 Enable the integrator at the interface with the DC offset DAC.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_gain_scale</td>
<td align=left>
Programmable truncation after the gain gets registered ("G" in the system diagram above)<br>
00 (truncate by 8) <br>
01 (truncate by 9) <br>
10 (truncate by 10) <br>
11 (truncate by 11) <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_lms_mu</td>
<td align=left>
"Step-size (mu) for the LMS gain adaptation loop. ("M" in the system diagram above)<br>
00 (no truncation) <br>
01 (truncate by 1) <br>
10 (truncate by 2) <br>
11 (truncate by 3) <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_mu_dly_mode</td>
<td align=left>
 Control for blw_mu dly.<br>
 00 - no delay.<br>
 01 - 1 to 2 ms delay.<br>
 10 - 2 to 3 ms delay.<br>
 11 - reserved.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_2x_mode</td>
<td align=left>
 Enable OFFSET DAC 2x MODE by lowering the output BLW correction to half. blw_output_scale and blw_2x_mode are added (unsigned) together for Truncation
of the BLW correction.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">blw_max_amp_clr</td>
<td align=left>
 Clear the max amplitude register and re-start from zero. Self-clear register field.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_trnsum_sel</td>
<td align=left>
 Select a particular signal within the BLW block to send to the TRNSUM block for accumulation. Refer to section 4.1 for more details. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_int_read_en</td>
<td align=left>
 Read status select in the status field dc_offset_bin. 1 -> read the internal DC offset status, 0 -> read the final DC offset value goig to the analog<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_output_scale</td>
<td align=left>
 Programmable truncation for the BLW output. <br>
 blw_output_scale and blw_2x_mode are added (unsigned) together to create "L" in the system diagram above. <br>
 000 (shift right by 6)&nbsp&nbsp <br>
 001 (shift right by 7)&nbsp&nbsp <br>
 010 (shift right by 8)&nbsp&nbsp <br>
 011 (shift right by 9)&nbsp&nbsp <br>
 100 (shift right by 10)&nbsp <br>
 101 (shift right by 11)&nbsp <br>
 110 (shift right by 12)&nbsp <br>
 111 (shift right by 13)&nbsp <br>
Reset value is 0x2.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_ctrl_3">DSC_A_blw_ctrl_3 - BLW canceller control register 3.</a></b><br>
Address Offset = 32'h0000_d038<br>
Physical Address = 32'h0000_d038<br>
Verilog CL45 Address = {`DSC_A_A, `blw_ctrl_3_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_ctrl_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">blw_gain_frc</td>
<td align=left>
 Enable/force writing to the adaptive gain register. This is a self-clear register.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_gain_frc_val</td>
<td align=left>
 Write/force value to the adaptive gain register in 2's complement signed format. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_ctrl_4">DSC_A_blw_ctrl_4 - BLW canceller control register 4.</a></b><br>
Address Offset = 32'h0000_d039<br>
Physical Address = 32'h0000_d039<br>
Verilog CL45 Address = {`DSC_A_A, `blw_ctrl_4_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_ctrl_4_A<br>
Reset Value = 16'h7fff<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_gain_sat_high</td>
<td align=left>
 Upper saturation limit for the adaptive gain loop in 2's complement signed format. Valid value 0 to 2^15 - 1 (decimal).<br>
Reset value is 0x7fff.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_ctrl_5">DSC_A_blw_ctrl_5 - BLW canceller control register 5.</a></b><br>
Address Offset = 32'h0000_d03a<br>
Physical Address = 32'h0000_d03a<br>
Verilog CL45 Address = {`DSC_A_A, `blw_ctrl_5_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_ctrl_5_A<br>
Reset Value = 16'h8000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">blw_gain_sat_low</td>
<td align=left>
 Lower saturation limit for the adaptive gain loop in 2's complement signed format. Valid value of -1 to -2^15 (decimal).<br>
Reset value is 0x8000.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_status_1_type">DSC_A_blw_status_1_type - BLW canceller status register 1</a></b><br>
Address Offset = 32'h0000_d03b<br>
Physical Address = 32'h0000_d03b<br>
Verilog CL45 Address = {`DSC_A_A, `blw_status_1_type_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_status_1_type_A<br>
Reset Value = 16'h0020<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">blw_gain</td>
<td align=left>
Status of the instantaneous value of the adaptive gain in 2's complement signed format.<br>
Reset value is 0x20.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_blw_status_2_type">DSC_A_blw_status_2_type - BLW canceller status register 2</a></b><br>
Address Offset = 32'h0000_d03c<br>
Physical Address = 32'h0000_d03c<br>
Verilog CL45 Address = {`DSC_A_A, `blw_status_2_type_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `blw_status_2_type_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">blw_max_amp</td>
<td align=left>
The maximum amplitude encountered at the output of the BLW block since the last reset or clear. Can be positive or negative.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_dsc_uc_ctrl">DSC_A_dsc_uc_ctrl - DSC uC Control</a></b><br>
Address Offset = 32'h0000_d03d<br>
Physical Address = 32'h0000_d03d<br>
Verilog CL45 Address = {`DSC_A_A, `dsc_uc_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `dsc_uc_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_dsc_supp_info</td>
<td align=left>
 Supplemental information. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_dsc_ready_for_cmd</td>
<td align=left>
 Ready for command. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_dsc_error_found</td>
<td align=left>
 Error Found. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_dsc_gp_uc_req</td>
<td align=left>
 gp_uc request <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_A_dsc_scratch">DSC_A_dsc_scratch - DSC uC Scratch</a></b><br>
Address Offset = 32'h0000_d03e<br>
Physical Address = 32'h0000_d03e<br>
Verilog CL45 Address = {`DSC_A_A, `dsc_scratch_Adr}<br>
Verilog CL22 Address = {`DSC_A_A, 4'h0}, `dsc_scratch_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_dsc_scratch</td>
<td align=left>
 DSC scratch register.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_A Registers">Return to DSC_A: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_B Registers">DSC_B: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd040</td><td><A HREF="#DSC_B_trnsum_a_low">DSC_B_trnsum_a_low</A></td><td>trnsum a low register.</td></tr>
<tr>
<td align=center>0xd041</td><td><A HREF="#DSC_B_trnsum_a">DSC_B_trnsum_a</A></td><td>trnsum a register.</td></tr>
<tr>
<td align=center>0xd042</td><td><A HREF="#DSC_B_trnsum_b_low">DSC_B_trnsum_b_low</A></td><td>trnsum b low register.</td></tr>
<tr>
<td align=center>0xd043</td><td><A HREF="#DSC_B_trnsum_b">DSC_B_trnsum_b</A></td><td>trnsum b register.</td></tr>
<tr>
<td align=center>0xd044</td><td><A HREF="#DSC_B_trnsum_c_low">DSC_B_trnsum_c_low</A></td><td>trnsum c low register.</td></tr>
<tr>
<td align=center>0xd045</td><td><A HREF="#DSC_B_trnsum_c">DSC_B_trnsum_c</A></td><td>trnsum c register.</td></tr>
<tr>
<td align=center>0xd046</td><td><A HREF="#DSC_B_trnsum_d_low">DSC_B_trnsum_d_low</A></td><td>trnsum d low register.</td></tr>
<tr>
<td align=center>0xd047</td><td><A HREF="#DSC_B_trnsum_d">DSC_B_trnsum_d</A></td><td>trnsum d register.</td></tr>
<tr>
<td align=center>0xd048</td><td><A HREF="#DSC_B_trnsum_low">DSC_B_trnsum_low</A></td><td>trnsum low register.</td></tr>
<tr>
<td align=center>0xd049</td><td><A HREF="#DSC_B_trnsum">DSC_B_trnsum</A></td><td>trnsum register.</td></tr>
<tr>
<td align=center>0xd04a</td><td><A HREF="#DSC_B_vga_phase_thresh_status">DSC_B_vga_phase_thresh_status</A></td><td>phase1 and phase02 threshold status register</td></tr>
<tr>
<td align=center>0xd04b</td><td><A HREF="#DSC_B_vga_data_thresh_status">DSC_B_vga_data_thresh_status</A></td><td>data14 and data05 threshold status register</td></tr>
<tr>
<td align=center>0xd04c</td><td><A HREF="#DSC_B_dc_offset_status">DSC_B_dc_offset_status</A></td><td>dc offset status register</td></tr>
<tr>
<td align=center>0xd04d</td><td><A HREF="#DSC_B_vga_d_thresh_status">DSC_B_vga_d_thresh_status</A></td><td>vga gain and data1 threshold status register.</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_B_trnsum_a_low">DSC_B_trnsum_a_low - trnsum a low register.</a></b><br>
Address Offset = 32'h0000_d040<br>
Physical Address = 32'h0000_d040<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_a_low_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_a_low_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_a_low</td>
<td align=left>
Trnsum interleave 'a' LSB result (7:0)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_a">DSC_B_trnsum_a - trnsum a register.</a></b><br>
Address Offset = 32'h0000_d041<br>
Physical Address = 32'h0000_d041<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_a_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_a_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_a</td>
<td align=left>
Trnsum interleave 'a' result (23:8)<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_b_low">DSC_B_trnsum_b_low - trnsum b low register.</a></b><br>
Address Offset = 32'h0000_d042<br>
Physical Address = 32'h0000_d042<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_b_low_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_b_low_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_b_low</td>
<td align=left>
Trnsum interleave 'b' LSB result (7:0)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_b">DSC_B_trnsum_b - trnsum b register.</a></b><br>
Address Offset = 32'h0000_d043<br>
Physical Address = 32'h0000_d043<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_b_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_b_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_b</td>
<td align=left>
Trnsum interleave 'b' result (23:8)<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_c_low">DSC_B_trnsum_c_low - trnsum c low register.</a></b><br>
Address Offset = 32'h0000_d044<br>
Physical Address = 32'h0000_d044<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_c_low_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_c_low_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_c_low</td>
<td align=left>
Trnsum interleave 'c' LSB result (7:0)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_c">DSC_B_trnsum_c - trnsum c register.</a></b><br>
Address Offset = 32'h0000_d045<br>
Physical Address = 32'h0000_d045<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_c_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_c_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_c</td>
<td align=left>
Trnsum interleave 'c' result (23:8)<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_d_low">DSC_B_trnsum_d_low - trnsum d low register.</a></b><br>
Address Offset = 32'h0000_d046<br>
Physical Address = 32'h0000_d046<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_d_low_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_d_low_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_d_low</td>
<td align=left>
Trnsum interleave 'd' LSB result (7:0)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_d">DSC_B_trnsum_d - trnsum d register.</a></b><br>
Address Offset = 32'h0000_d047<br>
Physical Address = 32'h0000_d047<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_d_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_d_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_d</td>
<td align=left>
Trnsum interleave 'd' result (15:8)<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum_low">DSC_B_trnsum_low - trnsum low register.</a></b><br>
Address Offset = 32'h0000_d048<br>
Physical Address = 32'h0000_d048<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_low_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_low_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum_low</td>
<td align=left>
Trnsum&nbsp LSB result (9:0)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_trnsum">DSC_B_trnsum - trnsum register.</a></b><br>
Address Offset = 32'h0000_d049<br>
Physical Address = 32'h0000_d049<br>
Verilog CL45 Address = {`DSC_B_A, `trnsum_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `trnsum_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">trnsum</td>
<td align=left>
Trnsum result (25:10)<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_vga_phase_thresh_status">DSC_B_vga_phase_thresh_status - phase1 and phase02 threshold status register</a></b><br>
Address Offset = 32'h0000_d04a<br>
Physical Address = 32'h0000_d04a<br>
Verilog CL45 Address = {`DSC_B_A, `vga_phase_thresh_status_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `vga_phase_thresh_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_phase1_status</td>
<td align=left>
Read out of the phase1 Slicer threshold in 2's complement signed format.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_phase02_status</td>
<td align=left>
Read out of the phase02 Slicer threshold in 2's complement signed format.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_vga_data_thresh_status">DSC_B_vga_data_thresh_status - data14 and data05 threshold status register</a></b><br>
Address Offset = 32'h0000_d04b<br>
Physical Address = 32'h0000_d04b<br>
Verilog CL45 Address = {`DSC_B_A, `vga_data_thresh_status_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `vga_data_thresh_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_data14_status</td>
<td align=left>
Read out of the Data14 Slicer threshold in 2's complement signed format.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_data05_status</td>
<td align=left>
Read out of the Data05 Slicer threshold in 2's complement signed format.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_dc_offset_status">DSC_B_dc_offset_status - dc offset status register</a></b><br>
Address Offset = 32'h0000_d04c<br>
Physical Address = 32'h0000_d04c<br>
Verilog CL45 Address = {`DSC_B_A, `dc_offset_status_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `dc_offset_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dc_offset_bin</td>
<td align=left>
rx dc offset<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_B_vga_d_thresh_status">DSC_B_vga_d_thresh_status - vga gain and data1 threshold status register.</a></b><br>
Address Offset = 32'h0000_d04d<br>
Physical Address = 32'h0000_d04d<br>
Verilog CL45 Address = {`DSC_B_A, `vga_d_thresh_status_Adr}<br>
Verilog CL22 Address = {`DSC_B_A, 4'h0}, `vga_d_thresh_status_A<br>
Reset Value = 16'h2700<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_vga_status</td>
<td align=left>
Read out of the VGA control. <br>
Reset value is 0x27.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_data23_status</td>
<td align=left>
Read out of the Data23 Slicer threshold in 2's complement signed format.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_B Registers">Return to DSC_B: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_C Registers">DSC_C: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd050</td><td><A HREF="#DSC_C_cdr_control_0">DSC_C_cdr_control_0</A></td><td>cdr control register 0.</td></tr>
<tr>
<td align=center>0xd051</td><td><A HREF="#DSC_C_cdr_control_1">DSC_C_cdr_control_1</A></td><td>cdr control register 1.</td></tr>
<tr>
<td align=center>0xd052</td><td><A HREF="#DSC_C_cdr_control_2">DSC_C_cdr_control_2</A></td><td>cdr control register 2</td></tr>
<tr>
<td align=center>0xd053</td><td><A HREF="#DSC_C_rx_pi_control">DSC_C_rx_pi_control</A></td><td>rx pi control register.</td></tr>
<tr>
<td align=center>0xd054</td><td><A HREF="#DSC_C_trnsum_control2">DSC_C_trnsum_control2</A></td><td>trnsum control 2 register.</td></tr>
<tr>
<td align=center>0xd055</td><td><A HREF="#DSC_C_trnsum_control">DSC_C_trnsum_control</A></td><td>trnsum control register.</td></tr>
<tr>
<td align=center>0xd056</td><td><A HREF="#DSC_C_trnsum_tap_ctrl">DSC_C_trnsum_tap_ctrl</A></td><td>trnsum tap control register.</td></tr>
<tr>
<td align=center>0xd057</td><td><A HREF="#DSC_C_trnsum_tdt_ctl">DSC_C_trnsum_tdt_ctl</A></td><td>trnsum tdt control register</td></tr>
<tr>
<td align=center>0xd058</td><td><A HREF="#DSC_C_trnsum_misc">DSC_C_trnsum_misc</A></td><td>trnsum misc register</td></tr>
<tr>
<td align=center>0xd05b</td><td><A HREF="#DSC_C_slicers_write_ctrl">DSC_C_slicers_write_ctrl</A></td><td>slicers override write control register.</td></tr>
<tr>
<td align=center>0xd05d</td><td><A HREF="#DSC_C_lms_thresh_control">DSC_C_lms_thresh_control</A></td><td>lms threshold control register</td></tr>
<tr>
<td align=center>0xd05e</td><td><A HREF="#DSC_C_dc_offset_control">DSC_C_dc_offset_control</A></td><td>dc offset control register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_C_cdr_control_0">DSC_C_cdr_control_0 - cdr control register 0.</a></b><br>
Address Offset = 32'h0000_d050<br>
Physical Address = 32'h0000_d050<br>
Verilog CL45 Address = {`DSC_C_A, `cdr_control_0_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `cdr_control_0_A<br>
Reset Value = 16'h0009<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pam4_es_mode</td>
<td align=left>
PAM4 mode select control and it is only applicable to the PAM4 RX datapath. <br>
1: PAM4 ES (Extended Slicer) mode. <br>
0: PAM4 NS (Normal Slicer)&nbsp&nbsp mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_nrz_vsr_mode</td>
<td align=left>
NRZ mode select control and it is only applicable to the NRZ RX datapath. <br>
1: NRZ VSR mode. <br>
0: NRZ DFE mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pam4es_prec_disabled</td>
<td align=left>
 <br>
1: PAM4 ES - precoder off @ transmit. <br>
0: PAM4 ES - precoder on @ transmit. <br>
For PAM4 NS - This bit is dont-care. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>phase_err_offset_mult2</td>
<td align=left>
0: phase error offset is within this range: [-8:7] <br>
0: phase error offset is multiplied by 2. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_cdr_prop_bw_ext</td>
<td align=left>
{pam4_cdr_prop_bw_ext, prop gain from SM} Effective proportional gain <br>
{0,0} *1 <br>
{0,1} *2 <br>
{1,0} *2 <br>
{1,1} *4 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_zero_polarity</td>
<td align=left>
inverts the phase slicer information before the phase detector<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_freq_override_en</td>
<td align=left>
1:override integ Register with cdr_freq_override_val<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_integ_sat_sel</td>
<td align=left>
0:(-24576, 24575), 1:(-16384, 16383)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_phase_err_frz</td>
<td align=left>
1: override phase error to be 0<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_integ_reg_clr</td>
<td align=left>
clear integ Register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_hs_freeze</td>
<td align=left>
0: HS CDR inc/dec sent to PI<br>
1: HS CDR inc/dec blocked (But manual strobe and dig loopback are allowed)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_freq_en</td>
<td align=left>
1: 2nd order loop output to contribute<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>br_pd_en</td>
<td align=left>
0: (refer to os_all_edges) 1: use 011/100 patterns should not be used in PAM4 modes/ lower os modes (os ration > 4).<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>os_pattern_enhanced</td>
<td align=left>
NRZ: when 1, selects 001/110 and also 010/101 from 4 locations {n,n+1, n+9, n+10}.<br>
PAM4NS: this one-hot control maps to pd_mode[1], which enables the BR mode phase detector. <br>
PAM4ES: this one-hot control maps to pd_mode[1], which enables the 7-level symbol based phase detector. <br>
For PAM4 modes, refer to documentation for os_all_edges.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>os_all_edges</td>
<td align=left>
NRZ: 0: 001/110 (and os_pattern_enhanced ==0 and br_pd_en ==0) , 1: x01/x10 patterns. <br>
PAM4NS: this one-hot control maps to pd_mode[0], which enables the OS mode phase detector. <br>
PAM4ES: this one-hot control maps to pd_mode[0], which enables the dfe_data based phase detector. <br>
For PAM4 modes, refer to documentation for os_pattern_enhanced.<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_cdr_control_1">DSC_C_cdr_control_1 - cdr control register 1.</a></b><br>
Address Offset = 32'h0000_d051<br>
Physical Address = 32'h0000_d051<br>
Verilog CL45 Address = {`DSC_C_A, `cdr_control_1_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `cdr_control_1_A<br>
Reset Value = 16'h0007<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_freq_override_val</td>
<td align=left>
Gets loaded into the integ reg @ reset. Also, see alternate use in description of cdr_freq_override_en&nbsp Program round(ppm_required * 83.89/32) to this
register <br>
 ppm_required = 200 if 200e-6 frequency offset is needed <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_power_opt_clock_gate_en</td>
<td align=left>
When enabled it enables the clock gating signal in kslice_hs_dMux block <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_phase_sel</td>
<td align=left>
[2], [1], [0] correspond to enabling phase information from pp2, p0, pn2<br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_cdr_control_2">DSC_C_cdr_control_2 - cdr control register 2</a></b><br>
Address Offset = 32'h0000_d052<br>
Physical Address = 32'h0000_d052<br>
Verilog CL45 Address = {`DSC_C_A, `cdr_control_2_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `cdr_control_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_phase_sat_ctrl</td>
<td align=left>
Only for PAM4 CDR, the nrz cdr saturates to +/-10. <br>
1'b0: saturate the 1st order path to be within -16:16 <br>
1'b1: saturate the 1st order path to be within -10:10 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_phase_sum_acc_mode</td>
<td align=left>
3'b000: osr-mode dependent scaling of rx pi phase steps <br>
3'b001: sum over 16 cycles and divide by 4 <br>
3'b010: sum over 20 cycles and divide by 5 <br>
others: un-supported&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_prop_bw_extend</td>
<td align=left>
When 1, the proportional BW is increased by 2 <br>
{cdr_prop_bw_extend, cdr_bwsel_prop_[norm/acqcdr]}: Gain <br>
=============================================== <br>
 0, 0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp :&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp *1&nbsp&nbsp <br>
 0, 1&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp :&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp *2&nbsp&nbsp <br>
 1, 0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp :&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp *3&nbsp&nbsp <br>
 1, 1&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp :&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp *4&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>cdr_1g_manual_strobe</td>
<td align=left>
Manual Strobe for the 1G CDR. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_1g_manual_mode</td>
<td align=left>
Puts the 1G CDR in manual mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>phs_sum_ignore_dsc_lock</td>
<td align=left>
Normally the phase summer waits for dsc lock. This bit overrides that wait. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_loop_timing_src_sel</td>
<td align=left>
Needs to be 1 in order to gate the phase sum on. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_1g_force_en</td>
<td align=left>
Forces the enable on the 1g logic. Else it should be enabled with osr mode setting to correct value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_1g_swap_pz</td>
<td align=left>
When 1, this will swap the peaks and zeros going out as the DME data. It will still use the original peaks and zeros for data recovery. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_lm_thr_sel</td>
<td align=left>
cdr lock monitor looks for integ reg to be within sat level - (cdr_lm_thr_sel +1)*512 in magnitude <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_rx_pi_control">DSC_C_rx_pi_control - rx pi control register.</a></b><br>
Address Offset = 32'h0000_d053<br>
Physical Address = 32'h0000_d053<br>
Verilog CL45 Address = {`DSC_C_A, `rx_pi_control_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `rx_pi_control_A<br>
Reset Value = 16'h1000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pi_phase_step_dir</td>
<td align=left>
0: left shift, 1: right shift<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pi_disp_msb_status</td>
<td align=left>
0: register reads of the pi counters are the lower 8 bits.<br>
 1: register reads of the pi counters are the upper 8 bits.<br>
 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pi_step_size</td>
<td align=left>
0: pi steps by 1<br>
 1: pi steps by 2<br>
 Only applicable to NRZ modes. Do not set in PAM4 modes.<br>
 In NRZ (other than fractional osr) modes, setting this bit doubles the step size of the CDR inc/decs. The other manual mode/ext mode do not double.<br>
 <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rx_pi_manual_strobe</td>
<td align=left>
perform a manual override over specified number of clocks<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pi_manual_mode</td>
<td align=left>
0: normal, 1:disconnect all PI's from CDR when enabled<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pi_phase_step_cnt</td>
<td align=left>
# of steps to adjust: 0..15: [1, 92, 104, 116, 128, 140, 152, 168, <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 46,52,&nbsp 58,&nbsp 64,&nbsp 70,&nbsp 76,&nbsp 84, 2] <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pi_slicers_en</td>
<td align=left>
bit-vector representing which PI's to adjust: [0] d, [1] dq, [2] p, [3] pq, [4] l, [5] lq<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_trnsum_control2">DSC_C_trnsum_control2 - trnsum control 2 register.</a></b><br>
Address Offset = 32'h0000_d054<br>
Physical Address = 32'h0000_d054<br>
Verilog CL45 Address = {`DSC_C_A, `trnsum_control2_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `trnsum_control2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_mode_sel</td>
<td align=left>
 This field needs to be set to configure the trnsum to correctly select the data during different modes of operation. <br>
 Specifically, used when trnsum_data_sel == {0, 1, 2, 3} or when trnsum_err_sel == {2} or when trnsum_pattern_match_sel == {5} or trnsum_eyec_sel == {1,2,3}&nbsp
or when trnsum_multi_level_isi=={1}. <br>
 2'b00: NRZ mode.<br>
 2'b01: PAM4 NS mode.<br>
 2'b10: PAM4 ES mode.<br>
 2'b11: unsupported. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_alt_path_en</td>
<td align=left>
 When 00, sum the trnsum error.<br>
 When 01, sum the blw path&nbsp into the accumulators.<br>
 When 10, sum the phase error<br>
 When 11, sum the 1g cdr phase steps<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_7lvl_en</td>
<td align=left>
 This is a limited application mode. <br>
 Only use this when pattern match sel selects dfe_data in ES mode. <br>
 pattern_2[2:0] are compared to current 7 level symbol.&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_eye_closure_err_sel</td>
<td align=left>
When trnsum_eye_closure_en is set, this field determines what is compared against d slicer. d!=error_selected , where error_selected is:<br>
1'b0: emux<br>
1'b1: expected prbs<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_eye_close_prev_en</td>
<td align=left>
 When 1, the first eye close event after previous 6 non-eye closure events is picked. The eye close condition settings need to be turned on for this setting
to work.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:02</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_pattern_match_sel</td>
<td align=left>
&nbsp &nbsp 0: NRZ<br>
&nbsp &nbsp 1: pam4ns<br>
&nbsp &nbsp 2: pam4es symbols<br>
&nbsp &nbsp 3: pam4es dfe_data<br>
&nbsp &nbsp 4: lms<br>
&nbsp &nbsp 5: Expected PRBS. (Needs fec_fdbk_en = 1 & fec_fdbk_data_sel = 1) <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_disable_sm_clear</td>
<td align=left>
When asserted,a pulse on uc_trnsum_en no longer clears the accumulator. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">trnsum_clr_sc</td>
<td align=left>
Self Clearing bit <br>
When asserted, the trnsum accumulator clears. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_trnsum_control">DSC_C_trnsum_control - trnsum control register.</a></b><br>
Address Offset = 32'h0000_d055<br>
Physical Address = 32'h0000_d055<br>
Verilog CL45 Address = {`DSC_C_A, `trnsum_control_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `trnsum_control_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_en</td>
<td align=left>
Training sum enable<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_eye_closure_en</td>
<td align=left>
When enabled this ands another term to the&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp condition. d[n] != emux[n]<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_random_tapsel_disable</td>
<td align=left>
Disables randomizing logic for tap&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp selection. Enables sequential selection.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_qphase_mult_en</td>
<td align=left>
Enables cdr phase error to weigh the&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp correlator output<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_cor_sel</td>
<td align=left>
00: normal; 01: all 1s instead of emux; 10:&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp count number of emux!= data; 11: all
1s instead of d[n-delay]<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_tap_range_sel</td>
<td align=left>
Taps -32 to 4 are broken into groups of 8 and&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp this selects the range<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_gain</td>
<td align=left>
bit-vector representing the gain to be applied: [0] 1, [1] 2, [2] 4, [3] 8<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_trnsum_tap_ctrl">DSC_C_trnsum_tap_ctrl - trnsum tap control register.</a></b><br>
Address Offset = 32'h0000_d056<br>
Physical Address = 32'h0000_d056<br>
Verilog CL45 Address = {`DSC_C_A, `trnsum_tap_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `trnsum_tap_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_tap_sign</td>
<td align=left>
Sign of the 8 taps in the group<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_tap_en</td>
<td align=left>
Training taps enabled (either randomize over&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp them or not)<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_trnsum_tdt_ctl">DSC_C_trnsum_tdt_ctl - trnsum tdt control register</a></b><br>
Address Offset = 32'h0000_d057<br>
Physical Address = 32'h0000_d057<br>
Verilog CL45 Address = {`DSC_C_A, `trnsum_tdt_ctl_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `trnsum_tdt_ctl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">trnsum_tdt_slip</td>
<td align=left>
Self clearing. The tdt counter subtracts a 1, hence overflows 1 UI later. Hence the TDT slips to the next UI.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:01</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_tdt_count</td>
<td align=left>
valid range is unsigned decimal 20:8191&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">tdt_trnsum_en</td>
<td align=left>
enables the tdt feature&nbsp <br>
At no point should this be disabled in the middle of collecting data over multiple locations. <br>
The counters which figure out which cycle to select while this bit is 1.&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_trnsum_misc">DSC_C_trnsum_misc - trnsum misc register</a></b><br>
Address Offset = 32'h0000_d058<br>
Physical Address = 32'h0000_d058<br>
Verilog CL45 Address = {`DSC_C_A, `trnsum_misc_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `trnsum_misc_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_eyec_sel</td>
<td align=left>
trsnum eye close data selector (with appropriate trnsum_mode_sel)&nbsp <br>
The slicer representation {d0:d5} does not map to the analog slicer numbering. Refer to block diagram for trnsum for details. <br>
 0: rx data sign; <br>
 1: nrz data/ d0 <br>
 [2:6] : [d1:d5] <br>
 7: LMS <br>
 8: 1 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_multi_level_isi</td>
<td align=left>
trsnum multi level mode enable <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_err_sel</td>
<td align=left>
trsnum error selector&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">dc_offs_write_en</td>
<td align=left>
self clearing dc offset write strobe <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_rnd_free_running</td>
<td align=left>
When 1, the randomizer runs continuously in the multi level isi mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:02</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_data_sel</td>
<td align=left>
trsnum data selector&nbsp&nbsp <br>
 0: dfe_data (2 bit). Pam4 modes <br>
 1: nrz rx_data/ d0 <br>
 [2:6]: [d1:d5] <br>
 7: lms <br>
 8: 1 <br>
 9: 3 bit symbol <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">uc_trnsum_en</td>
<td align=left>
 1'b1 will move the state from UC_TUNE to MEASURE. This is a self-clear register bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">tdt_prbs_slip</td>
<td align=left>
Reserved bit (unused) <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_slicers_write_ctrl">DSC_C_slicers_write_ctrl - slicers override write control register.</a></b><br>
Address Offset = 32'h0000_d05b<br>
Physical Address = 32'h0000_d05b<br>
Verilog CL45 Address = {`DSC_C_A, `slicers_write_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `slicers_write_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rx_afe_override_write</td>
<td align=left>
strobe to write slicer values <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_afe_override_val</td>
<td align=left>
override val of slicersthis value is binary. It is converted to gray before it is routed to AFE<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_afe_override_sel</td>
<td align=left>
Based on this value, an override can be applied to one of the data, phase or lms slicers<br>
0 - Invalid; 1 - data23 slicer; 2 - data14 slicer; 3 - data05 slicer; 4 - phase1 slicer; 5 - phase02 slicer; 6 - dfe taps 2 or 3; 8 - lms threshold; 15
- Dont use (used in lms threshold readout).<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_lms_thresh_control">DSC_C_lms_thresh_control - lms threshold control register</a></b><br>
Address Offset = 32'h0000_d05d<br>
Physical Address = 32'h0000_d05d<br>
Verilog CL45 Address = {`DSC_C_A, `lms_thresh_control_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `lms_thresh_control_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_blw_phase_sel</td>
<td align=left>
when 1, the dc offset loop runs on the phase selected from the CDR<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_acc_clr</td>
<td align=left>
Clears the internal state except for the final tap <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:05</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_gain</td>
<td align=left>
multiplies the +-40 error by 2^{0,1,2,3} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_gradient_invert</td>
<td align=left>
Inverts the sense of the update (inc,dec swap)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_hys_mag</td>
<td align=left>
0: 11th bit <<7; 1: 11th bit <<5 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_hys_en</td>
<td align=left>
Needs to be 1 for hysteresis to be on <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_en</td>
<td align=left>
Enables DC Offset tap for adaptation (still needs trnsum to be un-frozen) <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_C_dc_offset_control">DSC_C_dc_offset_control - dc offset control register</a></b><br>
Address Offset = 32'h0000_d05e<br>
Physical Address = 32'h0000_d05e<br>
Verilog CL45 Address = {`DSC_C_A, `dc_offset_control_Adr}<br>
Verilog CL22 Address = {`DSC_C_A, 4'h0}, `dc_offset_control_A<br>
Reset Value = 16'h0010<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_write_val</td>
<td align=left>
write value for the dc offset in override modeThe logic walks to this value @ the start of automatic adaptation<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_acc_clr</td>
<td align=left>
Clears the internal state except for the final tap <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:05</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_gain</td>
<td align=left>
multiplies the +-40 error by 2^{0,1,2,3} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_gradient_invert</td>
<td align=left>
1: Default mode. The input is a measure of the DC-level, which needs to be subtracted (inverted + added) to the DCO control .<br>
0: This does not invert the sense of the input .<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_hys_mag</td>
<td align=left>
0: 11th bit <<7; 1: 11th bit <<5 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_hys_en</td>
<td align=left>
Needs to be 1 for hysteresis to be on <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">dc_offs_write_frc_en</td>
<td align=left>
self clearing dc offset force write strobe <br>
This is simply an override to everything. This write gets sign gray converted and written to the dc_offset register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">dc_offs_en</td>
<td align=left>
Enables DC Offset tap for adaptation (still needs trnsum to be un-frozen) <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_C Registers">Return to DSC_C: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_D Registers">DSC_D: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd060</td><td><A HREF="#DSC_D_dsc_sm_ctrl_0">DSC_D_dsc_sm_ctrl_0</A></td><td>DSC STATE MACHINE CONTROL 0</td></tr>
<tr>
<td align=center>0xd061</td><td><A HREF="#DSC_D_dsc_sm_ctrl_1">DSC_D_dsc_sm_ctrl_1</A></td><td>DSC STATE MACHINE CONTROL 1</td></tr>
<tr>
<td align=center>0xd062</td><td><A HREF="#DSC_D_dsc_sm_ctrl_2">DSC_D_dsc_sm_ctrl_2</A></td><td>DSC STATE MACHINE CONTROL 2</td></tr>
<tr>
<td align=center>0xd063</td><td><A HREF="#DSC_D_dsc_sm_ctrl_3">DSC_D_dsc_sm_ctrl_3</A></td><td>DSC STATE MACHINE CONTROL 3</td></tr>
<tr>
<td align=center>0xd064</td><td><A HREF="#DSC_D_dsc_sm_ctrl_4">DSC_D_dsc_sm_ctrl_4</A></td><td>DSC STATE MACHINE CONTROL 4</td></tr>
<tr>
<td align=center>0xd065</td><td><A HREF="#DSC_D_dsc_sm_ctrl_5">DSC_D_dsc_sm_ctrl_5</A></td><td>DSC STATE MACHINE CONTROL 5</td></tr>
<tr>
<td align=center>0xd066</td><td><A HREF="#DSC_D_dsc_sm_ctrl_6">DSC_D_dsc_sm_ctrl_6</A></td><td>DSC STATE MACHINE CONTROL 6</td></tr>
<tr>
<td align=center>0xd067</td><td><A HREF="#DSC_D_dsc_sm_ctrl_7">DSC_D_dsc_sm_ctrl_7</A></td><td>DSC STATE MACHINE CONTROL 7</td></tr>
<tr>
<td align=center>0xd068</td><td><A HREF="#DSC_D_dsc_sm_ctrl_8">DSC_D_dsc_sm_ctrl_8</A></td><td>DSC STATE MACHINE CONTROL 8</td></tr>
<tr>
<td align=center>0xd069</td><td><A HREF="#DSC_D_dsc_sm_ctrl_9">DSC_D_dsc_sm_ctrl_9</A></td><td>DSC STATE MACHINE CONTROL 9</td></tr>
<tr>
<td align=center>0xd06a</td><td><A HREF="#DSC_D_dsc_sm_status_dsc_lock">DSC_D_dsc_sm_status_dsc_lock</A></td><td>DSC STATE MACHINE DSC_LOCK STATUS</td></tr>
<tr>
<td align=center>0xd06b</td><td><A HREF="#DSC_D_dsc_sm_status_dsc_state_one_hot">DSC_D_dsc_sm_status_dsc_state_one_hot</A></td><td>DSC STATE MACHINE STATUS ONE HOT</td></tr>
<tr>
<td align=center>0xd06c</td><td><A HREF="#DSC_D_dsc_sm_status_dsc_state_eee_one_hot">DSC_D_dsc_sm_status_dsc_state_eee_one_hot</A></td><td>DSC STATE MACHINE STATUS EEE ONE HOT</td></tr>
<tr>
<td align=center>0xd06d</td><td><A HREF="#DSC_D_dsc_sm_status_restart">DSC_D_dsc_sm_status_restart</A></td><td>DSC STATE MACHINE STATUS RESTART</td></tr>
<tr>
<td align=center>0xd06e</td><td><A HREF="#DSC_D_dsc_sm_status_dsc_state">DSC_D_dsc_sm_status_dsc_state</A></td><td>DSC STATE MACHINE STATUS</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_0">DSC_D_dsc_sm_ctrl_0 - DSC STATE MACHINE CONTROL 0</a></b><br>
Address Offset = 32'h0000_d060<br>
Physical Address = 32'h0000_d060<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_0_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_0_A<br>
Reset Value = 16'h0008<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>set_meas_incomplete</td>
<td align=left>
 1'b1 will force meas_incomplete to be 1'b1 to start a new measurement in EEE mode. This is a self-clear bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_dsc_config</td>
<td align=left>
 1'b1 will enable the CONFIG to WAIT_FOR_SIG transition. This is a self-clear bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_dsc_restart</td>
<td align=left>
 1'b1 will enable the RESTART to CONFIG transition. This is a self-clear bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_dsc_eee_done</td>
<td align=left>
 1'b1 will enable the EEE_DONE to DONE transition. This is a self-clear bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_measure_en</td>
<td align=left>
 1'b1 Enables the measurement during EEE_MEASURE.&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>hw_tune_en</td>
<td align=left>
 Should be 1'b1 along with uc_tune_en==1'b1 to move from UC_TUNE to HW_TUNE state.&nbsp This is a self-clear register bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_tune_en</td>
<td align=left>
 uc_tune_en is used to move in and out of UC_TUNE state. Look for DSC SM state diagram for more details.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cl72_timer_en</td>
<td align=left>
 If enabled to 1'b1 then LFSR is loaded with 0x01CD else it is loaded with 0x1C1E for all non-EEE and non-MEASURE states.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ignore_rx_mode</td>
<td align=left>
 If set to 1'b1 then pmd_rx_mode input will be ignored in DSC SM. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_quiet_rx_afe_pwrdwn_val</td>
<td align=left>
 1'b1 will enable the RX AFE powerdown in EEE_QUIET mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_mode_en</td>
<td align=left>
 1'b1 will enable the EEE mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_1">DSC_D_dsc_sm_ctrl_1 - DSC STATE MACHINE CONTROL 1</a></b><br>
Address Offset = 32'h0000_d061<br>
Physical Address = 32'h0000_d061<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_1_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_1_A<br>
Reset Value = 16'h0200<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>trnsum_clr_frc_val</td>
<td align=left>
 raining Sum freeze force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>trnsum_clr_frc</td>
<td align=left>
 Training Sum freeze force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_frz_frc_val</td>
<td align=left>
 CDR Freeze force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_frz_frc</td>
<td align=left>
 CDR Freeze force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>freq_upd_en_frc_val</td>
<td align=left>
 Frequency update force value. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>freq_upd_en_frc</td>
<td align=left>
 Frequency update force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>timer_done_frc_val</td>
<td align=left>
 If timer_done_frc is set to 1'b1 and DSC SM is in HW_TUNE or MEASURE states then setting this bit to 1 will move the state to next state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>timer_done_frc</td>
<td align=left>
 Can be forced to 1'b1 which will disable the H/W timer in HW_TUNE and MEASURE states.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>trnsum_frz_frc_val</td>
<td align=left>
 raining Sum freeze force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>trnsum_frz_frc</td>
<td align=left>
 Training Sum freeze force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dsc_clr_frc_val</td>
<td align=left>
 DSC clear force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dsc_clr_frc</td>
<td align=left>
 DSC clear force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_dsc_lock_frc_val</td>
<td align=left>
 rx_dsc_lock force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_dsc_lock_frc</td>
<td align=left>
 rx_dsc_lock force. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_2">DSC_D_dsc_sm_ctrl_2 - DSC STATE MACHINE CONTROL 2</a></b><br>
Address Offset = 32'h0000_d062<br>
Physical Address = 32'h0000_d062<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_2_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_2_A<br>
Reset Value = 16'h0087<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dsc_timeout_mult</td>
<td align=left>
 DSC timer multiplication ratio. <br>
 0: 1x&nbsp&nbsp 1: 2x&nbsp&nbsp 2: 4x&nbsp&nbsp 3: 8x&nbsp&nbsp 4:16x&nbsp&nbsp 5:32x <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_lfsr_cnt</td>
<td align=left>
 LFSR timer start value for all EEE timers except EEE_MEASURE. <br>
Reset value is 0x87.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_3">DSC_D_dsc_sm_ctrl_3 - DSC STATE MACHINE CONTROL 3</a></b><br>
Address Offset = 32'h0000_d063<br>
Physical Address = 32'h0000_d063<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_3_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_3_A<br>
Reset Value = 16'h1c1e<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>measure_lfsr_cnt</td>
<td align=left>
 LFSR timer start value for MEASURE and EEE_MEASURE state timers. <br>
Reset value is 0x1c1e.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_4">DSC_D_dsc_sm_ctrl_4 - DSC STATE MACHINE CONTROL 4</a></b><br>
Address Offset = 32'h0000_d064<br>
Physical Address = 32'h0000_d064<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_4_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>hw_tune_timeout</td>
<td align=left>
 Defines timeout value for the HW_TUNE state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_settle_timeout</td>
<td align=left>
 Defines timeout value for the CDR_SETTLE state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>acq_cdr_timeout</td>
<td align=left>
 Defines timeout value for the ACQ_CDR state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_5">DSC_D_dsc_sm_ctrl_5 - DSC STATE MACHINE CONTROL 5</a></b><br>
Address Offset = 32'h0000_d065<br>
Physical Address = 32'h0000_d065<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_5_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_5_A<br>
Reset Value = 16'h35ad<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_cdr_settle_timeout</td>
<td align=left>
 Defines timeout value for the EEE_CDR_SETTLE state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0xd.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_acq_cdr_timeout</td>
<td align=left>
 Defines timeout value for the EEE_ACQ_CDR state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0xd.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>measure_timeout</td>
<td align=left>
 Defines timeout value for the MEASURE state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0xd.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_6">DSC_D_dsc_sm_ctrl_6 - DSC STATE MACHINE CONTROL 6</a></b><br>
Address Offset = 32'h0000_d066<br>
Physical Address = 32'h0000_d066<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_6_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_6_A<br>
Reset Value = 16'h340d<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_ana_pwr_timeout</td>
<td align=left>
 Defines timeout value for the EEE_ANA_PWR state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0xd.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_hw_tune_timeout</td>
<td align=left>
 Defines timeout value for the EEE_HW_TUNE state timer.&nbsp Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.<br>
Reset value is 0xd.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_7">DSC_D_dsc_sm_ctrl_7 - DSC STATE MACHINE CONTROL 7</a></b><br>
Address Offset = 32'h0000_d067<br>
Physical Address = 32'h0000_d067<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_7_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_7_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_bwsel_prop_norm</td>
<td align=left>
 CDR Proportional Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states. <br>
&nbsp {0, 1} map to {2^0, 2^1} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_bwsel_prop_acqcdr</td>
<td align=left>
&nbsp CDR Proportional Bandwidth select for ACQ_CDR state. <br>
&nbsp {0, 1} map to {2^0, 2^1} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_bwsel_integ_norm</td>
<td align=left>
 CDR 2nd Order Loop Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states. <br>
&nbsp {0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_bwsel_integ_eee_acqcdr</td>
<td align=left>
 CDR 2nd Order Loop Bandwidth select for EEE_ACQ_CDR state. <br>
&nbsp {0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_bwsel_integ_acqcdr</td>
<td align=left>
 CDR 2nd Order Loop Bandwidth select for ACQ_CDR state. <br>
&nbsp {0, 1,2,3} map to {2^0, 2^1, 2^2, 2^-1} <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_8">DSC_D_dsc_sm_ctrl_8 - DSC STATE MACHINE CONTROL 8</a></b><br>
Address Offset = 32'h0000_d068<br>
Physical Address = 32'h0000_d068<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_8_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_8_A<br>
Reset Value = 16'h0011<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cdr_bwsel_prop_eee_acqcdr</td>
<td align=left>
 CDR Proportional Bandwidth select for EEE_ACQ_CDR state. <br>
&nbsp {0, 1} map to {2^0, 2^1} <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_phase_err_offset_en</td>
<td align=left>
 Phase Error Offset Enable for EEE_ACQ_CDR state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>phase_err_offset_en</td>
<td align=left>
 Phase Error Offset Enable for non-EEE_ACQ_CDR states. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>eee_phase_err_offset</td>
<td align=left>
 Phase Error Offset for EEE_ACQ_CDR state. Signed value. Valid range is -8 to 7.&nbsp <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>phase_err_offset</td>
<td align=left>
 Phase Error Offset for non-EEE_ACQ_CDR states. Signed value. Valid range is -8 to 7. This translates to either -8/2 to 7/2 or -8/4 to 7/4, depending on
how rg_phase_err_offset_mult_2 is set. By default is is -8/4 to 7/4 adding into VCO reg. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_ctrl_9">DSC_D_dsc_sm_ctrl_9 - DSC STATE MACHINE CONTROL 9</a></b><br>
Address Offset = 32'h0000_d069<br>
Physical Address = 32'h0000_d069<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_ctrl_9_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_ctrl_9_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_restart_pmd_hold</td>
<td align=left>
 1: restarts the RX PMD and holds it in RESTART state until this bit is cleared. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rx_restart_pmd</td>
<td align=left>
 1: restarts the RX PMD. This is a self-clear register bit. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_status_dsc_lock">DSC_D_dsc_sm_status_dsc_lock - DSC STATE MACHINE DSC_LOCK STATUS</a></b><br>
Address Offset = 32'h0000_d06a<br>
Physical Address = 32'h0000_d06a<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_status_dsc_lock_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_status_dsc_lock_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>eee_measure_cnt</td>
<td align=left>
 Indicates the eee_measure_cnt status. This is a debug register. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>meas_incomplete</td>
<td align=left>
 1 indicates that measurement is incomplete. 0 indicates that measurement is complete. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_dsc_lock</td>
<td align=left>
 1 indicates that DSC is locked. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_status_dsc_state_one_hot">DSC_D_dsc_sm_status_dsc_state_one_hot - DSC STATE MACHINE STATUS ONE HOT</a></b><br>
Address Offset = 32'h0000_d06b<br>
Physical Address = 32'h0000_d06b<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_status_dsc_state_one_hot_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_status_dsc_state_one_hot_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dsc_state_one_hot</td>
<td align=left>
 Sticky one-hot coded states. These registers are cleared on read. <br>
&nbsp&nbsp RESET&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 0&nbsp&nbsp <br>
&nbsp&nbsp RESTART&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 1&nbsp&nbsp <br>
&nbsp&nbsp CONFIG&nbsp &nbsp &nbsp &nbsp &nbsp =&nbsp 2&nbsp&nbsp <br>
&nbsp&nbsp WAIT_FOR_SIG&nbsp &nbsp =&nbsp 3&nbsp&nbsp <br>
&nbsp&nbsp ACQ_CDR&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 4&nbsp&nbsp <br>
&nbsp&nbsp CDR_SETTLE&nbsp &nbsp &nbsp =&nbsp 5&nbsp&nbsp <br>
&nbsp&nbsp HW_TUNE&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 6&nbsp&nbsp <br>
&nbsp&nbsp UC_TUNE&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 7&nbsp&nbsp <br>
&nbsp&nbsp MEASURE&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 8&nbsp&nbsp <br>
&nbsp&nbsp DONE&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp =&nbsp 9&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_status_dsc_state_eee_one_hot">DSC_D_dsc_sm_status_dsc_state_eee_one_hot - DSC STATE MACHINE STATUS EEE ONE HOT</a></b><br>
Address Offset = 32'h0000_d06c<br>
Physical Address = 32'h0000_d06c<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_status_dsc_state_eee_one_hot_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_status_dsc_state_eee_one_hot_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dsc_state_eee_one_hot</td>
<td align=left>
 Sticky one-hot coded EEE state . These registers are cleared on read. <br>
&nbsp&nbsp EEE_QUIET&nbsp &nbsp &nbsp&nbsp =&nbsp 0&nbsp <br>
&nbsp&nbsp EEE_ANA_PWR&nbsp &nbsp&nbsp =&nbsp 1&nbsp <br>
&nbsp&nbsp EEE_ACQ_CDR&nbsp &nbsp&nbsp =&nbsp 2&nbsp <br>
&nbsp&nbsp EEE_CDR_SETTLE&nbsp =&nbsp 3&nbsp <br>
&nbsp&nbsp EEE_HW_TUNE&nbsp &nbsp&nbsp =&nbsp 4&nbsp <br>
&nbsp&nbsp EEE_MEASURE&nbsp &nbsp&nbsp =&nbsp 5&nbsp <br>
&nbsp&nbsp EEE_DONE&nbsp &nbsp &nbsp &nbsp =&nbsp 6&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_status_restart">DSC_D_dsc_sm_status_restart - DSC STATE MACHINE STATUS RESTART</a></b><br>
Address Offset = 32'h0000_d06d<br>
Physical Address = 32'h0000_d06d<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_status_restart_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_status_restart_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>eee_quiet_from_eee_states</td>
<td align=left>
 Indicates when SM moves from any EEE states to EEE_QUIET state. This is clear on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>restart_pmd_restart</td>
<td align=left>
 Indicates when SM moves to RESTART state due to assertion of pmd_restart to 1'b1. This is clear on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>restart_sigdet</td>
<td align=left>
&nbsp Indicates when SM moves to RESTART state due to sigdet==0 and eee_mode_en register is 1'b0. This is clear on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>restart_pi_ext_mode</td>
<td align=left>
 Indicates when SM moves to RESTART state due to enabling of RX_PI external control (i.e. digital loopback enable). This is clear on read. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_D_dsc_sm_status_dsc_state">DSC_D_dsc_sm_status_dsc_state - DSC STATE MACHINE STATUS</a></b><br>
Address Offset = 32'h0000_d06e<br>
Physical Address = 32'h0000_d06e<br>
Verilog CL45 Address = {`DSC_D_A, `dsc_sm_status_dsc_state_Adr}<br>
Verilog CL22 Address = {`DSC_D_A, 4'h0}, `dsc_sm_status_dsc_state_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dsc_state</td>
<td align=left>
 Live DSC SM state. Following are the state encodings. <br>
&nbsp&nbsp RESET&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 0&nbsp&nbsp <br>
&nbsp&nbsp RESTART&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 1&nbsp&nbsp <br>
&nbsp&nbsp CONFIG&nbsp &nbsp &nbsp &nbsp &nbsp =&nbsp 2&nbsp&nbsp <br>
&nbsp&nbsp WAIT_FOR_SIG&nbsp &nbsp =&nbsp 3&nbsp&nbsp <br>
&nbsp&nbsp ACQ_CDR&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 4&nbsp&nbsp <br>
&nbsp&nbsp CDR_SETTLE&nbsp &nbsp &nbsp =&nbsp 5&nbsp&nbsp <br>
&nbsp&nbsp HW_TUNE&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 6&nbsp&nbsp <br>
&nbsp&nbsp UC_TUNE&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 7&nbsp&nbsp <br>
&nbsp&nbsp MEASURE&nbsp &nbsp &nbsp &nbsp&nbsp =&nbsp 8&nbsp&nbsp <br>
&nbsp&nbsp DONE&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp =&nbsp 9&nbsp&nbsp <br>
&nbsp&nbsp EEE_QUIET&nbsp &nbsp &nbsp&nbsp =&nbsp 10&nbsp <br>
&nbsp&nbsp EEE_ANA_PWR&nbsp &nbsp&nbsp =&nbsp 11&nbsp <br>
&nbsp&nbsp EEE_ACQ_CDR&nbsp &nbsp&nbsp =&nbsp 12&nbsp <br>
&nbsp&nbsp EEE_CDR_SETTLE&nbsp =&nbsp 13&nbsp <br>
&nbsp&nbsp EEE_HW_TUNE&nbsp &nbsp&nbsp =&nbsp 14&nbsp <br>
&nbsp&nbsp EEE_MEASURE&nbsp &nbsp&nbsp =&nbsp 15&nbsp <br>
&nbsp&nbsp EEE_DONE&nbsp &nbsp &nbsp &nbsp =&nbsp 16&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dsc_sm_scratch</td>
<td align=left>
&nbsp 3 bits of dsc_scratch <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dsc_sm_gp_uc_req</td>
<td align=left>
 gp_uc_req. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dsc_sm_ready_for_cmd</td>
<td align=left>
 Ready for Command. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_D Registers">Return to DSC_D: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_E Registers">DSC_E: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd070</td><td><A HREF="#DSC_E_rx_pi_cnt_bin_pd">DSC_E_rx_pi_cnt_bin_pd</A></td><td>rx_pi status register, both p and d.</td></tr>
<tr>
<td align=center>0xd071</td><td><A HREF="#DSC_E_rx_pi_cnt_bin_ld">DSC_E_rx_pi_cnt_bin_ld</A></td><td>rx_pi status register, both l and d.</td></tr>
<tr>
<td align=center>0xd072</td><td><A HREF="#DSC_E_rx_data_15_to_0">DSC_E_rx_data_15_to_0</A></td><td>rx data bits 15 to 0.</td></tr>
<tr>
<td align=center>0xd073</td><td><A HREF="#DSC_E_rx_data_35_to_20">DSC_E_rx_data_35_to_20</A></td><td>rx data bits 35 to 20.</td></tr>
<tr>
<td align=center>0xd074</td><td><A HREF="#DSC_E_cdr_status_phase_error">DSC_E_cdr_status_phase_error</A></td><td>cdr status register.</td></tr>
<tr>
<td align=center>0xd075</td><td><A HREF="#DSC_E_rx_pi_cnt_bin_d">DSC_E_rx_pi_cnt_bin_d</A></td><td>rx_pi status register.</td></tr>
<tr>
<td align=center>0xd076</td><td><A HREF="#DSC_E_rx_pi_cnt_bin_p">DSC_E_rx_pi_cnt_bin_p</A></td><td>rx_pi status register.</td></tr>
<tr>
<td align=center>0xd077</td><td><A HREF="#DSC_E_rx_pi_cnt_bin_l">DSC_E_rx_pi_cnt_bin_l</A></td><td>rx_pi status register.</td></tr>
<tr>
<td align=center>0xd078</td><td><A HREF="#DSC_E_cdr_status_integ_reg">DSC_E_cdr_status_integ_reg</A></td><td>cdr status register.</td></tr>
<tr>
<td align=center>0xd079</td><td><A HREF="#DSC_E_cdr_1g_status">DSC_E_cdr_1g_status</A></td><td>1g cdr status reg</td></tr>
<tr>
<td align=center>0xd07a</td><td><A HREF="#DSC_E_rx_pi_cntr_phase_err">DSC_E_rx_pi_cntr_phase_err</A></td><td>rxpi counter and phase error</td></tr>
<tr>
<td align=center>0xd07b</td><td><A HREF="#DSC_E_rx_dfe_tap2_status">DSC_E_rx_dfe_tap2_status</A></td><td>rx_dfe_tap2_status register.</td></tr>
<tr>
<td align=center>0xd07c</td><td><A HREF="#DSC_E_rx_dfe_tap2_3_status">DSC_E_rx_dfe_tap2_3_status</A></td><td>rx_dfe_tap2_3_status register.</td></tr>
<tr>
<td align=center>0xd07d</td><td><A HREF="#DSC_E_rx_dfe_tap3_status">DSC_E_rx_dfe_tap3_status</A></td><td>rx_dfe_tap3_status register.</td></tr>
<tr>
<td align=center>0xd07e</td><td><A HREF="#DSC_E_preset_reg">DSC_E_preset_reg</A></td><td>preset register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_E_rx_pi_cnt_bin_pd">DSC_E_rx_pi_cnt_bin_pd - rx_pi status register, both p and d.</a></b><br>
Address Offset = 32'h0000_d070<br>
Physical Address = 32'h0000_d070<br>
Verilog CL45 Address = {`DSC_E_A, `rx_pi_cnt_bin_pd_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_pi_cnt_bin_pd_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_d_pd</td>
<td align=left>
PI counter value for phase quadrature slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_p_pd</td>
<td align=left>
PI counter value for phase slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_pi_cnt_bin_ld">DSC_E_rx_pi_cnt_bin_ld - rx_pi status register, both l and d.</a></b><br>
Address Offset = 32'h0000_d071<br>
Physical Address = 32'h0000_d071<br>
Verilog CL45 Address = {`DSC_E_A, `rx_pi_cnt_bin_ld_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_pi_cnt_bin_ld_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_d_ld</td>
<td align=left>
PI counter value for LMS quadrature slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_l_ld</td>
<td align=left>
PI counter value for LMS slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_data_15_to_0">DSC_E_rx_data_15_to_0 - rx data bits 15 to 0.</a></b><br>
Address Offset = 32'h0000_d072<br>
Physical Address = 32'h0000_d072<br>
Verilog CL45 Address = {`DSC_E_A, `rx_data_15_to_0_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_data_15_to_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_data_15_to_0</td>
<td align=left>
Rx data is 40 bit wide in rclk40 domain. These are bits 15 to 0.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_data_35_to_20">DSC_E_rx_data_35_to_20 - rx data bits 35 to 20.</a></b><br>
Address Offset = 32'h0000_d073<br>
Physical Address = 32'h0000_d073<br>
Verilog CL45 Address = {`DSC_E_A, `rx_data_35_to_20_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_data_35_to_20_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_data_35_to_20</td>
<td align=left>
Rx data is 40 bit wide in rclk40 domain. These are bits 35 to 20.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_cdr_status_phase_error">DSC_E_cdr_status_phase_error - cdr status register.</a></b><br>
Address Offset = 32'h0000_d074<br>
Physical Address = 32'h0000_d074<br>
Verilog CL45 Address = {`DSC_E_A, `cdr_status_phase_error_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `cdr_status_phase_error_A<br>
Reset Value = 16'h0100<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cdr_vco_reg</td>
<td align=left>
 shadowed version of cdr_vco_reg[3:0]<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cdr_lm_outoflock</td>
<td align=left>
 CDR Lock Monitor loss of lock (1 implies a potential loss of lock). This bit sets itself on register read. <br>
 And if the cdr_integ_reg is within bounds it clears itself in the next cycle from which it detects within bounds. Note: Set on read <br>
 The valid bounds on the cdr_integ_reg are programmed using cdr_lm_thr_sel <br>
 Has more meaning after rx_dsc_lock is asserted.<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cdr_phase_error</td>
<td align=left>
 shadowed version of phase error value<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_pi_cnt_bin_d">DSC_E_rx_pi_cnt_bin_d - rx_pi status register.</a></b><br>
Address Offset = 32'h0000_d075<br>
Physical Address = 32'h0000_d075<br>
Verilog CL45 Address = {`DSC_E_A, `rx_pi_cnt_bin_d_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_pi_cnt_bin_d_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_dq</td>
<td align=left>
PI counter value for data quadrature slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_d</td>
<td align=left>
PI counter value for data slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_pi_cnt_bin_p">DSC_E_rx_pi_cnt_bin_p - rx_pi status register.</a></b><br>
Address Offset = 32'h0000_d076<br>
Physical Address = 32'h0000_d076<br>
Verilog CL45 Address = {`DSC_E_A, `rx_pi_cnt_bin_p_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_pi_cnt_bin_p_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_pq</td>
<td align=left>
PI counter value for phase quadrature slicer.<br>
When rx_pi_disp_msb_status is 0, the lower 8 bits of the 9 bit pointer are read..<br>
When rx_pi_disp_msb_status is 1, the upper 8 bits of the 9 bit pointer are read..<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_p</td>
<td align=left>
PI counter value for phase slicer<br>
see description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_pi_cnt_bin_l">DSC_E_rx_pi_cnt_bin_l - rx_pi status register.</a></b><br>
Address Offset = 32'h0000_d077<br>
Physical Address = 32'h0000_d077<br>
Verilog CL45 Address = {`DSC_E_A, `rx_pi_cnt_bin_l_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_pi_cnt_bin_l_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_lq</td>
<td align=left>
PI counter value for LMS quadrature slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_l</td>
<td align=left>
PI counter value for LMS slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_cdr_status_integ_reg">DSC_E_cdr_status_integ_reg - cdr status register.</a></b><br>
Address Offset = 32'h0000_d078<br>
Physical Address = 32'h0000_d078<br>
Verilog CL45 Address = {`DSC_E_A, `cdr_status_integ_reg_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `cdr_status_integ_reg_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cdr_integ_reg</td>
<td align=left>
 Divide this by 83.886 to get the approximate ppm frequency offset the CDR is tracking. (The CDR must settle first - rx_dsc_lock asserted high).<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_cdr_1g_status">DSC_E_cdr_1g_status - 1g cdr status reg</a></b><br>
Address Offset = 32'h0000_d079<br>
Physical Address = 32'h0000_d079<br>
Verilog CL45 Address = {`DSC_E_A, `cdr_1g_status_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `cdr_1g_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cdr_1g_phase_pointer</td>
<td align=left>
 1G phase pointer <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_pi_cntr_phase_err">DSC_E_rx_pi_cntr_phase_err - rxpi counter and phase error</a></b><br>
Address Offset = 32'h0000_d07a<br>
Physical Address = 32'h0000_d07a<br>
Verilog CL45 Address = {`DSC_E_A, `rx_pi_cntr_phase_err_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_pi_cntr_phase_err_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cnt_bin_d_perr</td>
<td align=left>
PI counter value for data slicersee description of cnt_bin_pq<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cdr_phase_err_picnt</td>
<td align=left>
 shadowed version of phase error value<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_dfe_tap2_status">DSC_E_rx_dfe_tap2_status - rx_dfe_tap2_status register.</a></b><br>
Address Offset = 32'h0000_d07b<br>
Physical Address = 32'h0000_d07b<br>
Verilog CL45 Address = {`DSC_E_A, `rx_dfe_tap2_status_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_dfe_tap2_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxa_dfe_tap2_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxb_dfe_tap2_status</td>
<td align=left>
signed 2's complement&nbsp +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxc_dfe_tap2_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_dfe_tap2_3_status">DSC_E_rx_dfe_tap2_3_status - rx_dfe_tap2_3_status register.</a></b><br>
Address Offset = 32'h0000_d07c<br>
Physical Address = 32'h0000_d07c<br>
Verilog CL45 Address = {`DSC_E_A, `rx_dfe_tap2_3_status_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_dfe_tap2_3_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxd_dfe_tap2_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxa_dfe_tap3_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxb_dfe_tap3_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_rx_dfe_tap3_status">DSC_E_rx_dfe_tap3_status - rx_dfe_tap3_status register.</a></b><br>
Address Offset = 32'h0000_d07d<br>
Physical Address = 32'h0000_d07d<br>
Verilog CL45 Address = {`DSC_E_A, `rx_dfe_tap3_status_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `rx_dfe_tap3_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxc_dfe_tap3_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rxd_dfe_tap3_status</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_E_preset_reg">DSC_E_preset_reg - preset register</a></b><br>
Address Offset = 32'h0000_d07e<br>
Physical Address = 32'h0000_d07e<br>
Verilog CL45 Address = {`DSC_E_A, `preset_reg_Adr}<br>
Verilog CL22 Address = {`DSC_E_A, 4'h0}, `preset_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_dfe_taps_2_3</td>
<td align=left>
 Preset bit 9. Hooked up to dfe taps 2 and 3<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_slicers</td>
<td align=left>
 Preset bit 8. Hooked up to data and phase slicers<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_i</td>
<td align=left>
 Preset bit 7. Hooked up to gen purpose bank i<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_h</td>
<td align=left>
 Preset bit 6. Hooked up to gen purpose bank h<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_g</td>
<td align=left>
 Preset bit 5. Hooked up to gen purpose bank g<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_f</td>
<td align=left>
 Preset bit 4. Hooked up to gen purpose bank f<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_a</td>
<td align=left>
 Preset bit 3. Hooked up to gen purpose bank a<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_d</td>
<td align=left>
 Preset bit 2. Hooked up to CDR trnsum bank<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">preset_c</td>
<td align=left>
 Preset bit 1. Hooked up to dsc_sm bank<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_E Registers">Return to DSC_E: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_F Registers">DSC_F: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd0f0</td><td><A HREF="#DSC_F_rx_hoffs_jitgen_reg">DSC_F_rx_hoffs_jitgen_reg</A></td><td>rx horiz offset jitter generator register.</td></tr>
<tr>
<td align=center>0xd0f1</td><td><A HREF="#DSC_F_lms_thresh_random1_reg">DSC_F_lms_thresh_random1_reg</A></td><td>rx trnsum lms random threshold values1</td></tr>
<tr>
<td align=center>0xd0f2</td><td><A HREF="#DSC_F_lms_thresh_random2_reg">DSC_F_lms_thresh_random2_reg</A></td><td>rx trnsum lms random threshold values2</td></tr>
<tr>
<td align=center>0xd0f3</td><td><A HREF="#DSC_F_lms_thresh_random3_reg">DSC_F_lms_thresh_random3_reg</A></td><td>rx trnsum lms random threshold values3</td></tr>
<tr>
<td align=center>0xd0f4</td><td><A HREF="#DSC_F_lms_thresh_random4_reg">DSC_F_lms_thresh_random4_reg</A></td><td>rx trnsum lms random threshold values3</td></tr>
<tr>
<td align=center>0xd0f5</td><td><A HREF="#DSC_F_lms_thresh_random5_reg">DSC_F_lms_thresh_random5_reg</A></td><td>rx trnsum lms random threshold values3</td></tr>
<tr>
<td align=center>0xd0f6</td><td><A HREF="#DSC_F_lms_thresh_random6_reg">DSC_F_lms_thresh_random6_reg</A></td><td>rx trnsum lms random threshold values3</td></tr>
<tr>
<td align=center>0xd0f7</td><td><A HREF="#DSC_F_lms_threshold_offs_reg">DSC_F_lms_threshold_offs_reg</A></td><td>lms threshold offset register.</td></tr>
<tr>
<td align=center>0xd0f8</td><td><A HREF="#DSC_F_lms_thresh_sts_reg">DSC_F_lms_thresh_sts_reg</A></td><td>Internal lms threshold status register.</td></tr>
<tr>
<td align=center>0xd0f9</td><td><A HREF="#DSC_F_lms_thresh_sts2_reg">DSC_F_lms_thresh_sts2_reg</A></td><td>AFE lms threshold status register.</td></tr>
<tr>
<td align=center>0xd0fa</td><td><A HREF="#DSC_F_trnsum_inl_meas_reg">DSC_F_trnsum_inl_meas_reg</A></td><td>Trnsum INL measurement register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_F_rx_hoffs_jitgen_reg">DSC_F_rx_hoffs_jitgen_reg - rx horiz offset jitter generator register.</a></b><br>
Address Offset = 32'h0000_d0f0<br>
Physical Address = 32'h0000_d0f0<br>
Verilog CL45 Address = {`DSC_F_A, `rx_hoffs_jitgen_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `rx_hoffs_jitgen_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">hoffs_jgen_jit_amp</td>
<td align=left>
 Jitter Generator Amplification Factor. Valid values are 0 to 63. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">hoffs_jgen_en</td>
<td align=left>
 Jitter Generator Enable <br>
 CDR's phase error offset should be 0 when this is enabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">hoffs_jgen_jit_freq_idx</td>
<td align=left>
 Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator
parameters. <br>
 In SJ&nbsp mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_random1_reg">DSC_F_lms_thresh_random1_reg - rx trnsum lms random threshold values1</a></b><br>
Address Offset = 32'h0000_d0f1<br>
Physical Address = 32'h0000_d0f1<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_random1_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_random1_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh2</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 1<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh1</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 1<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_random2_reg">DSC_F_lms_thresh_random2_reg - rx trnsum lms random threshold values2</a></b><br>
Address Offset = 32'h0000_d0f2<br>
Physical Address = 32'h0000_d0f2<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_random2_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_random2_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh4</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 2<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh3</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 2<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_random3_reg">DSC_F_lms_thresh_random3_reg - rx trnsum lms random threshold values3</a></b><br>
Address Offset = 32'h0000_d0f3<br>
Physical Address = 32'h0000_d0f3<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_random3_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_random3_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh6</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 3<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh5</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 3<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_random4_reg">DSC_F_lms_thresh_random4_reg - rx trnsum lms random threshold values3</a></b><br>
Address Offset = 32'h0000_d0f4<br>
Physical Address = 32'h0000_d0f4<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_random4_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_random4_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh8</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 4<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh7</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 4<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_random5_reg">DSC_F_lms_thresh_random5_reg - rx trnsum lms random threshold values3</a></b><br>
Address Offset = 32'h0000_d0f5<br>
Physical Address = 32'h0000_d0f5<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_random5_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_random5_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh10</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 5<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh9</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 5<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_random6_reg">DSC_F_lms_thresh_random6_reg - rx trnsum lms random threshold values3</a></b><br>
Address Offset = 32'h0000_d0f6<br>
Physical Address = 32'h0000_d0f6<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_random6_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_random6_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh12</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 6<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_rnd_thresh11</td>
<td align=left>
Random threshold level for lms_rnd_eyec_sel = 6<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_threshold_offs_reg">DSC_F_lms_threshold_offs_reg - lms threshold offset register.</a></b><br>
Address Offset = 32'h0000_d0f7<br>
Physical Address = 32'h0000_d0f7<br>
Verilog CL45 Address = {`DSC_F_A, `lms_threshold_offs_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_threshold_offs_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">lms_thresh_offs</td>
<td align=left>
This offset term is scaled and added to the lms threshold adaptation loop.<br>
Signed 2's complement. Range: -8191:8191.<br>
This gets divided by 512 and added to trnsum_error. <br>
Example of usage:&nbsp <br>
&nbsp&nbsp x = offset (1e-2 for example) needed such that 1-x occurences are above the steady state level. <br>
&nbsp&nbsp ((1-x)(1) + x(-1))*P(pattern)*20 + offset = 0 <br>
&nbsp &nbsp offset = (2x-1)*P(pattern)*20. <br>
&nbsp&nbsp reg_offset = round(offset * 512).<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_sts_reg">DSC_F_lms_thresh_sts_reg - Internal lms threshold status register.</a></b><br>
Address Offset = 32'h0000_d0f8<br>
Physical Address = 32'h0000_d0f8<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_sts_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_sts_reg_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>lms_thresh_bin</td>
<td align=left>
bits [9:2]:&nbsp signed 2's complement; +/-127*4. 127=300mV<br>
It reads out the hardware loop high resolution lms threshold/ override value left shifted by 2 (with lower two bits as 0).<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_lms_thresh_sts2_reg">DSC_F_lms_thresh_sts2_reg - AFE lms threshold status register.</a></b><br>
Address Offset = 32'h0000_d0f9<br>
Physical Address = 32'h0000_d0f9<br>
Verilog CL45 Address = {`DSC_F_A, `lms_thresh_sts2_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `lms_thresh_sts2_reg_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">afe_lms_thresh_bin</td>
<td align=left>
LMS threshold value applied to the analog. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_F_trnsum_inl_meas_reg">DSC_F_trnsum_inl_meas_reg - Trnsum INL measurement register</a></b><br>
Address Offset = 32'h0000_d0fa<br>
Physical Address = 32'h0000_d0fa<br>
Verilog CL45 Address = {`DSC_F_A, `trnsum_inl_meas_reg_Adr}<br>
Verilog CL22 Address = {`DSC_F_A, 4'h0}, `trnsum_inl_meas_reg_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">SC</td>
<td align=left valign=top style="color: red">trnsum_prbs_precoder_load_seed</td>
<td align=left>
Self Clearing signal. This is intended to be used when the expected PRBS stream is used either for pattern matching or eye closure.' <br>
When asserted, this kicks off a hunt for 8 rclk20 cycles to be error free. On the 8th cycle, the local precoder is seeded with the correct value - if trnsum_prbs_precoder_load_zero
== 0, else it loads 0. ' <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_prbs_precoder_autoseed</td>
<td align=left>
When 1, a rising edge on either trnsum_en or prbs_lock will kick off the load seed function. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_prbs_precoder_load_zero</td>
<td align=left>
See trnsum_prbs_precoder_load_seed <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_prbs_dp_invert</td>
<td align=left>
This should be set when the data path needs inversion<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:01</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_inl_phs_ptr</td>
<td align=left>
Lower 7 bits of the PI code for which the INL metric is to be measured. Refer to 'trnsum_inl_meas_en' <br>
Trnsum accumulators A/B/C/D will accumulate for different 2 MSB bits. <br>
Eg: if 7'd1 is used, trnsum_A will accumulate for 9'd1, trnsum_B for 9'd129, C for 9'd257 and D for 9'd389<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">trnsum_inl_meas_en</td>
<td align=left>
When 1: trnsum is configured to sum phase error for {D PI code == trnsum_inl_phs_ptr}. <br>
Set trnsum_alt_path_en to 'h2 for this feature.<br>
Set this field before enabling trnsum<br>
.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_F Registers">Return to DSC_F: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_G Registers">DSC_G: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd410</td><td><A HREF="#DSC_G_rxa_ffe_tap">DSC_G_rxa_ffe_tap</A></td><td>rx_ffe_tap register.</td></tr>
<tr>
<td align=center>0xd411</td><td><A HREF="#DSC_G_rxb_ffe_tap">DSC_G_rxb_ffe_tap</A></td><td>rx_ffe_tap register.</td></tr>
<tr>
<td align=center>0xd412</td><td><A HREF="#DSC_G_rxc_ffe_tap">DSC_G_rxc_ffe_tap</A></td><td>rx_ffe_tap register.</td></tr>
<tr>
<td align=center>0xd413</td><td><A HREF="#DSC_G_rxd_ffe_tap">DSC_G_rxd_ffe_tap</A></td><td>rx_ffe_tap register.</td></tr>
<tr>
<td align=center>0xd414</td><td><A HREF="#DSC_G_rx_dfe_tap2_ctrl">DSC_G_rx_dfe_tap2_ctrl</A></td><td>rx_dfe_tap2_ctrl register.</td></tr>
<tr>
<td align=center>0xd415</td><td><A HREF="#DSC_G_rx_dfe_tap2_3_ctrl">DSC_G_rx_dfe_tap2_3_ctrl</A></td><td>rx_dfe_tap2_3_ctrl register.</td></tr>
<tr>
<td align=center>0xd416</td><td><A HREF="#DSC_G_rx_dfe_tap3_ctrl">DSC_G_rx_dfe_tap3_ctrl</A></td><td>rx_dfe_tap3_ctrl register.</td></tr>
<tr>
<td align=center>0xd417</td><td><A HREF="#DSC_G_rx_auto_rate_mod_dfe_tap2_ab">DSC_G_rx_auto_rate_mod_dfe_tap2_ab</A></td><td>rx_dfe_tap2_ab rate change</td></tr>
<tr>
<td align=center>0xd418</td><td><A HREF="#DSC_G_rx_auto_rate_mod_dfe_tap2_cd">DSC_G_rx_auto_rate_mod_dfe_tap2_cd</A></td><td>rx_dfe_tap2_cd rate change</td></tr>
<tr>
<td align=center>0xd419</td><td><A HREF="#DSC_G_rx_auto_rate_mod_dfe_tap3_ab">DSC_G_rx_auto_rate_mod_dfe_tap3_ab</A></td><td>rx_dfe_tap3_ab rate change</td></tr>
<tr>
<td align=center>0xd41a</td><td><A HREF="#DSC_G_rx_auto_rate_mod_dfe_tap3_cd">DSC_G_rx_auto_rate_mod_dfe_tap3_cd</A></td><td>rx_dfe_tap3_cd rate change</td></tr>
<tr>
<td align=center>0xd41b</td><td><A HREF="#DSC_G_rx_auto_rate_mod_data23_14">DSC_G_rx_auto_rate_mod_data23_14</A></td><td>rx_data23_14 rate change</td></tr>
<tr>
<td align=center>0xd41c</td><td><A HREF="#DSC_G_rx_auto_rate_mod_phase02_1">DSC_G_rx_auto_rate_mod_phase02_1</A></td><td>rx_phase02_1 rate change</td></tr>
<tr>
<td align=center>0xd41d</td><td><A HREF="#DSC_G_rx_auto_rate_mod_data05">DSC_G_rx_auto_rate_mod_data05</A></td><td>rx_data05 rate change</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_G_rxa_ffe_tap">DSC_G_rxa_ffe_tap - rx_ffe_tap register.</a></b><br>
Address Offset = 32'h0000_d410<br>
Physical Address = 32'h0000_d410<br>
Verilog CL45 Address = {`DSC_G_A, `rxa_ffe_tap_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rxa_ffe_tap_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_ffe_tap1_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_ffe_tap2_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rxb_ffe_tap">DSC_G_rxb_ffe_tap - rx_ffe_tap register.</a></b><br>
Address Offset = 32'h0000_d411<br>
Physical Address = 32'h0000_d411<br>
Verilog CL45 Address = {`DSC_G_A, `rxb_ffe_tap_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rxb_ffe_tap_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_ffe_tap1_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_ffe_tap2_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rxc_ffe_tap">DSC_G_rxc_ffe_tap - rx_ffe_tap register.</a></b><br>
Address Offset = 32'h0000_d412<br>
Physical Address = 32'h0000_d412<br>
Verilog CL45 Address = {`DSC_G_A, `rxc_ffe_tap_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rxc_ffe_tap_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_ffe_tap1_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_ffe_tap2_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rxd_ffe_tap">DSC_G_rxd_ffe_tap - rx_ffe_tap register.</a></b><br>
Address Offset = 32'h0000_d413<br>
Physical Address = 32'h0000_d413<br>
Verilog CL45 Address = {`DSC_G_A, `rxd_ffe_tap_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rxd_ffe_tap_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_ffe_tap1_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_ffe_tap2_val</td>
<td align=left>
+/-31. where 1 lsb = 0.25*tap0/32 This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_dfe_tap2_ctrl">DSC_G_rx_dfe_tap2_ctrl - rx_dfe_tap2_ctrl register.</a></b><br>
Address Offset = 32'h0000_d414<br>
Physical Address = 32'h0000_d414<br>
Verilog CL45 Address = {`DSC_G_A, `rx_dfe_tap2_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_dfe_tap2_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxa_dfe_tap2_write</td>
<td align=left>
write strobe for writing to rxa_dfe_tap2<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap2_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap2_val</td>
<td align=left>
signed 2's complement&nbsp +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap2_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_dfe_tap2_3_ctrl">DSC_G_rx_dfe_tap2_3_ctrl - rx_dfe_tap2_3_ctrl register.</a></b><br>
Address Offset = 32'h0000_d415<br>
Physical Address = 32'h0000_d415<br>
Verilog CL45 Address = {`DSC_G_A, `rx_dfe_tap2_3_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_dfe_tap2_3_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxd_dfe_tap2_write</td>
<td align=left>
write strobe for writing to rxd_dfe_tap2<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap2_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxa_dfe_tap3_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxb_dfe_tap3_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_dfe_tap3_ctrl">DSC_G_rx_dfe_tap3_ctrl - rx_dfe_tap3_ctrl register.</a></b><br>
Address Offset = 32'h0000_d416<br>
Physical Address = 32'h0000_d416<br>
Verilog CL45 Address = {`DSC_G_A, `rx_dfe_tap3_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_dfe_tap3_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxb_dfe_tap2_write</td>
<td align=left>
write strobe for writing to rxb_dfe_tap2<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxc_dfe_tap2_write</td>
<td align=left>
write strobe for writing to rxc_dfe_tap2<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxa_dfe_tap3_write</td>
<td align=left>
write strobe for writing to rxa_dfe_tap3<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxb_dfe_tap3_write</td>
<td align=left>
write strobe for writing to rxb_dfe_tap3<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxc_dfe_tap3_write</td>
<td align=left>
write strobe for writing to rxc_dfe_tap3<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rxd_dfe_tap3_write</td>
<td align=left>
write strobe for writing to rxd_dfe_tap3<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxc_dfe_tap3_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rxd_dfe_tap3_val</td>
<td align=left>
signed 2's complement +/-15, 1LSB=150mV/64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_dfe_tap2_ab">DSC_G_rx_auto_rate_mod_dfe_tap2_ab - rx_dfe_tap2_ab rate change</a></b><br>
Address Offset = 32'h0000_d417<br>
Physical Address = 32'h0000_d417<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_dfe_tap2_ab_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_dfe_tap2_ab_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap2_left_num_change</td>
<td align=left>
if this bit is set, rxa_dfe_tap2 rate change update will occur after the update count has reached floor(rxa_dfe_tap2_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap2_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap2_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap2_left_num_change</td>
<td align=left>
if this bit is set, rxb_dfe_tap2 rate change update will occur after the update count has reached floor(rxb_dfe_tap2_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap2_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap2_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_dfe_tap2_cd">DSC_G_rx_auto_rate_mod_dfe_tap2_cd - rx_dfe_tap2_cd rate change</a></b><br>
Address Offset = 32'h0000_d418<br>
Physical Address = 32'h0000_d418<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_dfe_tap2_cd_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_dfe_tap2_cd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap2_left_num_change</td>
<td align=left>
if this bit is set, rxc_dfe_tap2 rate change update will occur after the update count has reached floor(rxc_dfe_tap2_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap2_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap2_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap2_left_num_change</td>
<td align=left>
if this bit is set, rxd_dfe_tap2 rate change update will occur after the update count has reached floor(rxd_dfe_tap2_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap2_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap2_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_dfe_tap3_ab">DSC_G_rx_auto_rate_mod_dfe_tap3_ab - rx_dfe_tap3_ab rate change</a></b><br>
Address Offset = 32'h0000_d419<br>
Physical Address = 32'h0000_d419<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_dfe_tap3_ab_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_dfe_tap3_ab_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap3_left_num_change</td>
<td align=left>
if this bit is set, rxa_dfe_tap3 rate change update will occur after the update count has reached floor(rxa_dfe_tap3_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap3_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap3_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap3_left_num_change</td>
<td align=left>
if this bit is set, rxb_dfe_tap3 rate change update will occur after the update count has reached floor(rxb_dfe_tap3_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap3_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap3_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_dfe_tap3_cd">DSC_G_rx_auto_rate_mod_dfe_tap3_cd - rx_dfe_tap3_cd rate change</a></b><br>
Address Offset = 32'h0000_d41a<br>
Physical Address = 32'h0000_d41a<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_dfe_tap3_cd_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_dfe_tap3_cd_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap3_left_num_change</td>
<td align=left>
if this bit is set, rxc_dfe_tap3 rate change update will occur after the update count has reached floor(rxc_dfe_tap3_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap3_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap3_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap3_left_num_change</td>
<td align=left>
if this bit is set, rxd_dfe_tap3 rate change update will occur after the update count has reached floor(rxd_dfe_tap3_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap3_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap3_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_data23_14">DSC_G_rx_auto_rate_mod_data23_14 - rx_data23_14 rate change</a></b><br>
Address Offset = 32'h0000_d41b<br>
Physical Address = 32'h0000_d41b<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_data23_14_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_data23_14_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data23_left_num_change</td>
<td align=left>
if this bit is set, data23 rate change update will occur after the update count has reached floor(rx_data23_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data23_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_data23_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data14_left_num_change</td>
<td align=left>
if this bit is set, data14 rate change update will occur after the update count has reached floor(rx_data14_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data14_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_data14_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_phase02_1">DSC_G_rx_auto_rate_mod_phase02_1 - rx_phase02_1 rate change</a></b><br>
Address Offset = 32'h0000_d41c<br>
Physical Address = 32'h0000_d41c<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_phase02_1_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_phase02_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase1_left_num_change</td>
<td align=left>
if this bit is set, phase1 rate change update will occur after the update count has reached floor(rx_phase1_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:07</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase1_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxc_phase1_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase02_left_num_change</td>
<td align=left>
if this bit is set, phase02 rate change update will occur after the update count has reached floor(rx_phase02_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase02_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxd_phase02_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_G_rx_auto_rate_mod_data05">DSC_G_rx_auto_rate_mod_data05 - rx_data05 rate change</a></b><br>
Address Offset = 32'h0000_d41d<br>
Physical Address = 32'h0000_d41d<br>
Verilog CL45 Address = {`DSC_G_A, `rx_auto_rate_mod_data05_Adr}<br>
Verilog CL22 Address = {`DSC_G_A, 4'h0}, `rx_auto_rate_mod_data05_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data05_left_num_change</td>
<td align=left>
if this bit is set, data05 rate change update will occur after the update count has reached floor(rx_data05_thresh_step_size/2) else ceil()<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data05_numerator2</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_data05_numerator2 rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_G Registers">Return to DSC_G: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_H Registers">DSC_H: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd420</td><td><A HREF="#DSC_H_auto_data23_update_ctrl">DSC_H_auto_data23_update_ctrl</A></td><td>data23 auto update register</td></tr>
<tr>
<td align=center>0xd421</td><td><A HREF="#DSC_H_auto_data14_update_ctrl">DSC_H_auto_data14_update_ctrl</A></td><td>data14 auto update register</td></tr>
<tr>
<td align=center>0xd422</td><td><A HREF="#DSC_H_auto_data05_update_ctrl">DSC_H_auto_data05_update_ctrl</A></td><td>data05 auto update register</td></tr>
<tr>
<td align=center>0xd423</td><td><A HREF="#DSC_H_auto_phase1_update_ctrl">DSC_H_auto_phase1_update_ctrl</A></td><td>phase1 auto update register</td></tr>
<tr>
<td align=center>0xd424</td><td><A HREF="#DSC_H_auto_phase02_update_ctrl">DSC_H_auto_phase02_update_ctrl</A></td><td>phase02 auto update register</td></tr>
<tr>
<td align=center>0xd425</td><td><A HREF="#DSC_H_auto_rxa_dfe_tap2_update_ctrl">DSC_H_auto_rxa_dfe_tap2_update_ctrl</A></td><td>rxa_dfe_tap2 auto update register</td></tr>
<tr>
<td align=center>0xd426</td><td><A HREF="#DSC_H_auto_rxb_dfe_tap2_update_ctrl">DSC_H_auto_rxb_dfe_tap2_update_ctrl</A></td><td>rxb_dfe_tap2 auto update register</td></tr>
<tr>
<td align=center>0xd427</td><td><A HREF="#DSC_H_auto_rxc_dfe_tap2_update_ctrl">DSC_H_auto_rxc_dfe_tap2_update_ctrl</A></td><td>rxc_dfe_tap2 auto update register</td></tr>
<tr>
<td align=center>0xd428</td><td><A HREF="#DSC_H_auto_rxd_dfe_tap2_update_ctrl">DSC_H_auto_rxd_dfe_tap2_update_ctrl</A></td><td>rxd_dfe_tap2 auto update register</td></tr>
<tr>
<td align=center>0xd429</td><td><A HREF="#DSC_H_auto_rxa_dfe_tap3_update_ctrl">DSC_H_auto_rxa_dfe_tap3_update_ctrl</A></td><td>rxa_dfe_tap3 auto update register</td></tr>
<tr>
<td align=center>0xd42a</td><td><A HREF="#DSC_H_auto_rxb_dfe_tap3_update_ctrl">DSC_H_auto_rxb_dfe_tap3_update_ctrl</A></td><td>rxb_dfe_tap3 auto update register</td></tr>
<tr>
<td align=center>0xd42b</td><td><A HREF="#DSC_H_auto_rxc_dfe_tap3_update_ctrl">DSC_H_auto_rxc_dfe_tap3_update_ctrl</A></td><td>rxc_dfe_tap3 auto update register</td></tr>
<tr>
<td align=center>0xd42c</td><td><A HREF="#DSC_H_auto_rxd_dfe_tap3_update_ctrl">DSC_H_auto_rxd_dfe_tap3_update_ctrl</A></td><td>rxd_dfe_tap3 auto update register</td></tr>
<tr>
<td align=center>0xd42d</td><td><A HREF="#DSC_H_slicer_dfe_taps_ctrl">DSC_H_slicer_dfe_taps_ctrl</A></td><td>slicer and dfe ctrls</td></tr>
<tr>
<td align=center>0xd42e</td><td><A HREF="#DSC_H_rx_pf_ctrl_dc_offset_and_vga">DSC_H_rx_pf_ctrl_dc_offset_and_vga</A></td><td>rx_pf_ctrl_dc_offset_and_vga register.</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_H_auto_data23_update_ctrl">DSC_H_auto_data23_update_ctrl - data23 auto update register</a></b><br>
Address Offset = 32'h0000_d420<br>
Physical Address = 32'h0000_d420<br>
Verilog CL45 Address = {`DSC_H_A, `auto_data23_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_data23_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data23_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the slicer data23 value will change after (rx_data23_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data23_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold data23<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data23_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_data23_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_data14_update_ctrl">DSC_H_auto_data14_update_ctrl - data14 auto update register</a></b><br>
Address Offset = 32'h0000_d421<br>
Physical Address = 32'h0000_d421<br>
Verilog CL45 Address = {`DSC_H_A, `auto_data14_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_data14_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data14_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the slicer data14 value will change after (rx_data14_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data14_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold data14<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data14_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_data14_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_data05_update_ctrl">DSC_H_auto_data05_update_ctrl - data05 auto update register</a></b><br>
Address Offset = 32'h0000_d422<br>
Physical Address = 32'h0000_d422<br>
Verilog CL45 Address = {`DSC_H_A, `auto_data05_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_data05_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data05_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the slicer data05 value will change after (rx_data05_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data05_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold data05<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_data05_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_data05_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_phase1_update_ctrl">DSC_H_auto_phase1_update_ctrl - phase1 auto update register</a></b><br>
Address Offset = 32'h0000_d423<br>
Physical Address = 32'h0000_d423<br>
Verilog CL45 Address = {`DSC_H_A, `auto_phase1_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_phase1_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase1_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the slicer phase1 value will change after (rx_phase1_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase1_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold phase1<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase1_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_phase1_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_phase02_update_ctrl">DSC_H_auto_phase02_update_ctrl - phase02 auto update register</a></b><br>
Address Offset = 32'h0000_d424<br>
Physical Address = 32'h0000_d424<br>
Verilog CL45 Address = {`DSC_H_A, `auto_phase02_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_phase02_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase02_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the slicer phase02 value will change after (rx_phase02_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase02_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold phase02<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_phase02_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rx_phase02_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxa_dfe_tap2_update_ctrl">DSC_H_auto_rxa_dfe_tap2_update_ctrl - rxa_dfe_tap2 auto update register</a></b><br>
Address Offset = 32'h0000_d425<br>
Physical Address = 32'h0000_d425<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxa_dfe_tap2_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxa_dfe_tap2_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap2_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxa_dfe_tap2 value will change after (rxa_dfe_tap2_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap2_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxa_dfe_tap2_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap2_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap2_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxb_dfe_tap2_update_ctrl">DSC_H_auto_rxb_dfe_tap2_update_ctrl - rxb_dfe_tap2 auto update register</a></b><br>
Address Offset = 32'h0000_d426<br>
Physical Address = 32'h0000_d426<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxb_dfe_tap2_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxb_dfe_tap2_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap2_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxb_dfe_tap2 value will change after (rxb_dfe_tap2_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap2_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxb_dfe_tap2_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap2_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap2_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxc_dfe_tap2_update_ctrl">DSC_H_auto_rxc_dfe_tap2_update_ctrl - rxc_dfe_tap2 auto update register</a></b><br>
Address Offset = 32'h0000_d427<br>
Physical Address = 32'h0000_d427<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxc_dfe_tap2_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxc_dfe_tap2_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap2_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxc_dfe_tap2 value will change after (rxc_dfe_tap2_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap2_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxc_dfe_tap2_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap2_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap2_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxd_dfe_tap2_update_ctrl">DSC_H_auto_rxd_dfe_tap2_update_ctrl - rxd_dfe_tap2 auto update register</a></b><br>
Address Offset = 32'h0000_d428<br>
Physical Address = 32'h0000_d428<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxd_dfe_tap2_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxd_dfe_tap2_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap2_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxd_dfe_tap2 value will change after (rxd_dfe_tap2_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap2_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxd_dfe_tap2_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap2_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap2_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxa_dfe_tap3_update_ctrl">DSC_H_auto_rxa_dfe_tap3_update_ctrl - rxa_dfe_tap3 auto update register</a></b><br>
Address Offset = 32'h0000_d429<br>
Physical Address = 32'h0000_d429<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxa_dfe_tap3_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxa_dfe_tap3_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap3_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxa_dfe_tap3 value will change after (rxa_dfe_tap3_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap3_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxa_dfe_tap3_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxa_dfe_tap3_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxa_dfe_tap3_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxb_dfe_tap3_update_ctrl">DSC_H_auto_rxb_dfe_tap3_update_ctrl - rxb_dfe_tap3 auto update register</a></b><br>
Address Offset = 32'h0000_d42a<br>
Physical Address = 32'h0000_d42a<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxb_dfe_tap3_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxb_dfe_tap3_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap3_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxb_dfe_tap3 value will change after (rxb_dfe_tap3_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap3_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxb_dfe_tap3_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxb_dfe_tap3_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxb_dfe_tap3_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxc_dfe_tap3_update_ctrl">DSC_H_auto_rxc_dfe_tap3_update_ctrl - rxc_dfe_tap3 auto update register</a></b><br>
Address Offset = 32'h0000_d42b<br>
Physical Address = 32'h0000_d42b<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxc_dfe_tap3_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxc_dfe_tap3_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap3_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxc_dfe_tap3 value will change after (rxc_dfe_tap3_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap3_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxc_dfe_tap3_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxc_dfe_tap3_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxc_dfe_tap3_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_auto_rxd_dfe_tap3_update_ctrl">DSC_H_auto_rxd_dfe_tap3_update_ctrl - rxd_dfe_tap3 auto update register</a></b><br>
Address Offset = 32'h0000_d42c<br>
Physical Address = 32'h0000_d42c<br>
Verilog CL45 Address = {`DSC_H_A, `auto_rxd_dfe_tap3_update_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `auto_rxd_dfe_tap3_update_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap3_init_phase</td>
<td align=left>
 When the front end signals that require auto slicer adjustment change, the rxd_dfe_tap3 value will change after (rxd_dfe_tap3_init_phase+2) rclk cycles
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap3_thresh_step_size</td>
<td align=left>
-15 to 15 where the top bit is the sign and the lower 4 bits the offset value for the auto increment step size for threshold rxd_dfe_tap3_numerator<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rxd_dfe_tap3_numerator</td>
<td align=left>
 the value of slicer will update at rx_slicer_denominator/rxd_dfe_tap3_numerator rclk cycles on average <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_slicer_dfe_taps_ctrl">DSC_H_slicer_dfe_taps_ctrl - slicer and dfe ctrls</a></b><br>
Address Offset = 32'h0000_d42d<br>
Physical Address = 32'h0000_d42d<br>
Verilog CL45 Address = {`DSC_H_A, `slicer_dfe_taps_ctrl_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `slicer_dfe_taps_ctrl_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_slicer_denominator</td>
<td align=left>
 delta sigma denominator that makes the update of slicers on fractional rclk on average <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">ana_timer_t2</td>
<td align=left>
ANA timed write. Wait for&nbsp (1,2, ...32,64) cyclesThis timer is used to set the values of vga, ffe_taps, dfe taps2,3 and pf_ctrls and rx_ctrl[175:160]
(ana_timer_t2+1) rclk cycles after the value is written<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_H_rx_pf_ctrl_dc_offset_and_vga">DSC_H_rx_pf_ctrl_dc_offset_and_vga - rx_pf_ctrl_dc_offset_and_vga register.</a></b><br>
Address Offset = 32'h0000_d42e<br>
Physical Address = 32'h0000_d42e<br>
Verilog CL45 Address = {`DSC_H_A, `rx_pf_ctrl_dc_offset_and_vga_Adr}<br>
Verilog CL22 Address = {`DSC_H_A, 4'h0}, `rx_pf_ctrl_dc_offset_and_vga_A<br>
Reset Value = 16'h0027<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pf_ctrl_val</td>
<td align=left>
Main Peaking Filter This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pf2_ctrl_val</td>
<td align=left>
DC cut (Low PF),&nbsp This value is written to the final value after t2+1 cycles that is set by the ana_t2_timer<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_vga_thresh_sel</td>
<td align=left>
this is the value of vga that sets the final vga value<br>
Reset value is 0x27.</td></tr>
</table><p>
<A HREF="#DSC_H Registers">Return to DSC_H: per lane register block [8 copies] Table</A><p>
<H1><a NAME="DSC_I Registers">DSC_I: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd440</td><td><A HREF="#DSC_I_rx_pi_b_control_0">DSC_I_rx_pi_b_control_0</A></td><td>RXPI INLC Control 0</td></tr>
<tr>
<td align=center>0xd441</td><td><A HREF="#DSC_I_rx_pi_b_control_1">DSC_I_rx_pi_b_control_1</A></td><td>RXPI INLC Control 1</td></tr>
<tr>
<td align=center>0xd442</td><td><A HREF="#DSC_I_rx_pi_b_control_2">DSC_I_rx_pi_b_control_2</A></td><td>RXPI INLC Control 2</td></tr>
<tr>
<td align=center>0xd443</td><td><A HREF="#DSC_I_rx_pi_b_control_3">DSC_I_rx_pi_b_control_3</A></td><td>RXPI INLC Control 3</td></tr>
<tr>
<td align=center>0xd444</td><td><A HREF="#DSC_I_rx_pi_b_control_4">DSC_I_rx_pi_b_control_4</A></td><td>RXPI INLC Control 4</td></tr>
<tr>
<td align=center>0xd445</td><td><A HREF="#DSC_I_rx_pi_b_control_5">DSC_I_rx_pi_b_control_5</A></td><td>RXPI INLC Control 5</td></tr>
<tr>
<td align=center>0xd446</td><td><A HREF="#DSC_I_rx_pi_b_control_6">DSC_I_rx_pi_b_control_6</A></td><td>RXPI INLC Control 6</td></tr>
<tr>
<td align=center>0xd447</td><td><A HREF="#DSC_I_rx_pi_b_control_7">DSC_I_rx_pi_b_control_7</A></td><td>RXPI INLC Control 7</td></tr>
<tr>
<td align=center>0xd448</td><td><A HREF="#DSC_I_rx_pi_b_control_9">DSC_I_rx_pi_b_control_9</A></td><td>RXPI INLC Control 9</td></tr>
<tr>
<td align=center>0xd449</td><td><A HREF="#DSC_I_rx_pi_b_control_10">DSC_I_rx_pi_b_control_10</A></td><td>RXPI INLC Control 10</td></tr>
<tr>
<td align=center>0xd44a</td><td><A HREF="#DSC_I_spare_reg_dsc_i">DSC_I_spare_reg_dsc_i</A></td><td>Spare Reg DSC I</td></tr>
<tr>
<td align=center>0xd44c</td><td><A HREF="#DSC_I_rx_pi_b_status_0">DSC_I_rx_pi_b_status_0</A></td><td>RXPI INLC Status 0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_0">DSC_I_rx_pi_b_control_0 - RXPI INLC Control 0</a></b><br>
Address Offset = 32'h0000_d440<br>
Physical Address = 32'h0000_d440<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_0_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_1</td>
<td align=left>
 RXPI INL Canceller table look up 1. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_0</td>
<td align=left>
 RXPI INL Canceller table look up 0. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_1">DSC_I_rx_pi_b_control_1 - RXPI INLC Control 1</a></b><br>
Address Offset = 32'h0000_d441<br>
Physical Address = 32'h0000_d441<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_1_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_3</td>
<td align=left>
 RXPI INL Canceller table look up 3. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_2</td>
<td align=left>
 RXPI INL Canceller table look up 2. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_2">DSC_I_rx_pi_b_control_2 - RXPI INLC Control 2</a></b><br>
Address Offset = 32'h0000_d442<br>
Physical Address = 32'h0000_d442<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_2_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_5</td>
<td align=left>
 RXPI INL Canceller table look up 5. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_4</td>
<td align=left>
 RXPI INL Canceller table look up 4. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_3">DSC_I_rx_pi_b_control_3 - RXPI INLC Control 3</a></b><br>
Address Offset = 32'h0000_d443<br>
Physical Address = 32'h0000_d443<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_3_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_7</td>
<td align=left>
 RXPI INL Canceller table look up 7. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_6</td>
<td align=left>
 RXPI INL Canceller table look up 6. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_4">DSC_I_rx_pi_b_control_4 - RXPI INLC Control 4</a></b><br>
Address Offset = 32'h0000_d444<br>
Physical Address = 32'h0000_d444<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_4_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_9</td>
<td align=left>
 RXPI INL Canceller table look up 9. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_8</td>
<td align=left>
 RXPI INL Canceller table look up 8. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_5">DSC_I_rx_pi_b_control_5 - RXPI INLC Control 5</a></b><br>
Address Offset = 32'h0000_d445<br>
Physical Address = 32'h0000_d445<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_5_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_11</td>
<td align=left>
 RXPI INL Canceller table look up 11. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_10</td>
<td align=left>
 RXPI INL Canceller table look up 10. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_6">DSC_I_rx_pi_b_control_6 - RXPI INLC Control 6</a></b><br>
Address Offset = 32'h0000_d446<br>
Physical Address = 32'h0000_d446<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_6_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_6_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_13</td>
<td align=left>
 RXPI INL Canceller table look up 13. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_12</td>
<td align=left>
 RXPI INL Canceller table look up 12. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_7">DSC_I_rx_pi_b_control_7 - RXPI INLC Control 7</a></b><br>
Address Offset = 32'h0000_d447<br>
Physical Address = 32'h0000_d447<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_7_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_7_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_15</td>
<td align=left>
 RXPI INL Canceller table look up 15. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_lut_14</td>
<td align=left>
 RXPI INL Canceller table look up 14. Signed value. -15 to +15. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_9">DSC_I_rx_pi_b_control_9 - RXPI INLC Control 9</a></b><br>
Address Offset = 32'h0000_d448<br>
Physical Address = 32'h0000_d448<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_9_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_9_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_offset</td>
<td align=left>
 RXPI INL Canceller pointer offset. 0-127. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_control_10">DSC_I_rx_pi_b_control_10 - RXPI INLC Control 10</a></b><br>
Address Offset = 32'h0000_d449<br>
Physical Address = 32'h0000_d449<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_control_10_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_control_10_A<br>
Reset Value = 16'h0200<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_phase_dly</td>
<td align=left>
 RXPI INL Canceller phase step delay. <br>
'0 = no delay, 1 = 1 clk delay, 2 = 2 clk delay, 3 = not used. <br>
"<br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_k</td>
<td align=left>
 RXPI INL Canceller k factor. k = 0,1,2,3. multiplies lut_out by 2^k. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:01</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">rx_pi_inlc_en</td>
<td align=left>
 RXPI INL Canceller enable control. 1 = enable INL canceller operation. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_spare_reg_dsc_i">DSC_I_spare_reg_dsc_i - Spare Reg DSC I</a></b><br>
Address Offset = 32'h0000_d44a<br>
Physical Address = 32'h0000_d44a<br>
Verilog CL45 Address = {`DSC_I_A, `spare_reg_dsc_i_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `spare_reg_dsc_i_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RW</td>
<td align=left valign=top style="color: red">spare_dsc_i</td>
<td align=left>
 Spare. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<b><a NAME="DSC_I_rx_pi_b_status_0">DSC_I_rx_pi_b_status_0 - RXPI INLC Status 0</a></b><br>
Address Offset = 32'h0000_d44c<br>
Physical Address = 32'h0000_d44c<br>
Verilog CL45 Address = {`DSC_I_A, `rx_pi_b_status_0_Adr}<br>
Verilog CL22 Address = {`DSC_I_A, 4'h0}, `rx_pi_b_status_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">rx_pi_inlc_rx_phase_pointer</td>
<td align=left>
 RXPI INL Canceller RX phase pointer. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">rx_pi_inlc_out</td>
<td align=left>
 RXPI INL Canceller output. Signed Value. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DSC_I Registers">Return to DSC_I: per lane register block [8 copies] Table</A><p>
<H1><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd0b0</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_CONTROL</A></td><td>RXTXCOM_OSR_MODE_CONTROL</td></tr>
<tr>
<td align=center>0xd0b1</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</A></td><td>RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</td></tr>
<tr>
<td align=center>0xd0b3</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</A></td><td>RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</td></tr>
<tr>
<td align=center>0xd0b5</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_UC_ACK_LANE_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_UC_ACK_LANE_CONTROL</A></td><td>RXTXCOM_UC_ACK_LANE_CONTROL</td></tr>
<tr>
<td align=center>0xd0b6</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL</A></td><td>RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL</td></tr>
<tr>
<td align=center>0xd0b7</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_PLL_SELECT_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_PLL_SELECT_CONTROL</A></td><td>RXTXCOM_PLL_SELECT_CONTROL</td></tr>
<tr>
<td align=center>0xd0b9</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_DP_RESET_STATE_STATUS">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_DP_RESET_STATE_STATUS</A></td><td>RXTXCOM_LANE_DP_RESET_STATE_STATUS</td></tr>
<tr>
<td align=center>0xd0ba</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_MULTICAST_MASK_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_MULTICAST_MASK_CONTROL</A></td><td>RXTXCOM_MULTICAST_MASK_CONTROL</td></tr>
<tr>
<td align=center>0xd0bb</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_STATUS_MC_MASK">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_STATUS_MC_MASK</A></td><td>RXTXCOM_OSR_MODE_STATUS_MC_MASK</td></tr>
<tr>
<td align=center>0xd0bc</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</A></td><td>RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</td></tr>
<tr>
<td align=center>0xd0be</td><td><A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LN_S_RSTB_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LN_S_RSTB_CONTROL</A></td><td>RXTXCOM_LN_S_RSTB_CONTROL</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_CONTROL - RXTXCOM_OSR_MODE_CONTROL</a></b><br>
Address Offset = 32'h0000_d0b0<br>
Physical Address = 32'h0000_d0b0<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_OSR_MODE_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_OSR_MODE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>osr_mode_frc</td>
<td align=left>
NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode. <br>
Othersise, the pin input values are used for OS mode<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_mode_frc</td>
<td align=left>
PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode. <br>
Othersise, the pin input values are used for pam4 mode<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_mode_frc_val</td>
<td align=left>
PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>osr_mode_frc_val</td>
<td align=left>
NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL - RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</a></b><br>
Address Offset = 32'h0000_d0b1<br>
Physical Address = 32'h0000_d0b1<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_dp_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane. <br>
This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL - RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</a></b><br>
Address Offset = 32'h0000_d0b3<br>
Physical Address = 32'h0000_d0b3<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_dp_h_rstb_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_dp_h_rstb input pin. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_h_rstb_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_h_rstb input pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_UC_ACK_LANE_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_UC_ACK_LANE_CONTROL - RXTXCOM_UC_ACK_LANE_CONTROL</a></b><br>
Address Offset = 32'h0000_d0b5<br>
Physical Address = 32'h0000_d0b5<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_UC_ACK_LANE_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_UC_ACK_LANE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_lane_dp_reset</td>
<td align=left>
 uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured". <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_lane_cfg_done</td>
<td align=left>
 uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 will&nbsp <br>
 should release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL - RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL</a></b><br>
Address Offset = 32'h0000_d0b6<br>
Physical Address = 32'h0000_d0b6<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_LANE_REG_RESET_OCCURRED_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>lane_reg_reset_occurred</td>
<td align=left>
 Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_PLL_SELECT_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_PLL_SELECT_CONTROL - RXTXCOM_PLL_SELECT_CONTROL</a></b><br>
Address Offset = 32'h0000_d0b7<br>
Physical Address = 32'h0000_d0b7<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_PLL_SELECT_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_PLL_SELECT_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_select</td>
<td align=left>
This register controls the selection of the PLL0 or PLL1 as clock source for the&nbsp lane. This register will be only reset upon POR hard or POR soft
reset. <br>
This register is expected to be changed only when&nbsp lane datapath is in reset. <br>
0 - Select PLL0 as clock for&nbsp lane. <br>
1 - Select PLL1 as clock for&nbsp lane. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_DP_RESET_STATE_STATUS">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LANE_DP_RESET_STATE_STATUS - RXTXCOM_LANE_DP_RESET_STATE_STATUS</a></b><br>
Address Offset = 32'h0000_d0b9<br>
Physical Address = 32'h0000_d0b9<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_LANE_DP_RESET_STATE_STATUS_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_LANE_DP_RESET_STATE_STATUS_A<br>
Reset Value = 16'h0007<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>lane_dp_reset_state</td>
<td align=left>
 Bit 2: lane_dp_reset_active&nbsp&nbsp : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.&nbsp <br>
 Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.&nbsp
<br>
 Bit 0: lane_dp_reset_held&nbsp &nbsp&nbsp : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001
and uc_ack_lane_cfg_done == 1. <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_MULTICAST_MASK_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_MULTICAST_MASK_CONTROL - RXTXCOM_MULTICAST_MASK_CONTROL</a></b><br>
Address Offset = 32'h0000_d0ba<br>
Physical Address = 32'h0000_d0ba<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_MULTICAST_MASK_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_MULTICAST_MASK_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>WO</td>
<td align=left valign=top>multicast_mask_control</td>
<td align=left>
This masks the lane from a broadcast or multicast write operation. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_STATUS_MC_MASK">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_OSR_MODE_STATUS_MC_MASK - RXTXCOM_OSR_MODE_STATUS_MC_MASK</a></b><br>
Address Offset = 32'h0000_d0bb<br>
Physical Address = 32'h0000_d0bb<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_OSR_MODE_STATUS_MC_MASK_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_OSR_MODE_STATUS_MC_MASK_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>multicast_mask_control_status</td>
<td align=left>
Status of multicast mask control for masking lane from multicast write operation. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pam4_mode</td>
<td align=left>
 PAM4 signalling mode status after the pam4_mode_frc/frc_val mux. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>osr_mode</td>
<td align=left>
 OSR Mode status after the osr_mode_frc/frc_val mux. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS - RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</a></b><br>
Address Offset = 32'h0000_d0bc<br>
Physical Address = 32'h0000_d0bc<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pam4_mode_pin</td>
<td align=left>
 Indicates the status of the pmd_pam4_mode input pin. <br>
 Decoding of pmd_pam4_mode[2:0] pin and pam4_mode registers are as follows. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>osr_mode_pin</td>
<td align=left>
 Indicates the status of the pmd_osr_mode input pin. <br>
 Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<b><a NAME="RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LN_S_RSTB_CONTROL">RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXTXCOM_LN_S_RSTB_CONTROL - RXTXCOM_LN_S_RSTB_CONTROL</a></b><br>
Address Offset = 32'h0000_d0be<br>
Physical Address = 32'h0000_d0be<br>
Verilog CL45 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXTXCOM_LN_S_RSTB_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXTXCOM_LN_S_RSTB_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>hw_fw_handshake_disable</td>
<td align=left>
1: disables the HW-FW handshake logic for the TX lane which means there is no acknowledgement required from uC and lane reset will be de-asserted once
reset register/pin conditions are de-asserted. <br>
This register bit is unused in RX lane. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane. <br>
This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXTXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies]. This is a virtual register block that broadcasts writes and reads to rxcom_ckrst_ctrl and txcom_ckrst_ctrl blocks. Table</A><p>
<H1><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd1a1</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL</A></td><td>RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL</td></tr>
<tr>
<td align=center>0xd1a2</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL</A></td><td>RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL</td></tr>
<tr>
<td align=center>0xd1a3</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</A></td><td>RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</td></tr>
<tr>
<td align=center>0xd1a4</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_DEBUG_RESET_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_DEBUG_RESET_CONTROL</A></td><td>RX_LANE_DEBUG_RESET_CONTROL</td></tr>
<tr>
<td align=center>0xd1a7</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_CLOCK_N_RESET_DEBUG_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_CLOCK_N_RESET_DEBUG_CONTROL</A></td><td>RX_CLOCK_N_RESET_DEBUG_CONTROL</td></tr>
<tr>
<td align=center>0xd1a8</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_PMD_LANE_MODE_STATUS">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_PMD_LANE_MODE_STATUS</A></td><td>RX_PMD_LANE_MODE_STATUS</td></tr>
<tr>
<td align=center>0xd1ac</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</A></td><td>RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</td></tr>
<tr>
<td align=center>0xd1ad</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA0">RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA0</A></td><td>LANE_CFG_FWAPI_DATA0</td></tr>
<tr>
<td align=center>0xd1ae</td><td><A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA1">RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA1</A></td><td>LANE_CFG_FWAPI_DATA1</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL - RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL</a></b><br>
Address Offset = 32'h0000_d1a1<br>
Physical Address = 32'h0000_d1a1<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_LANE_CLK_RESET_N_POWERDOWN_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_sigdet_pwrdn</td>
<td align=left>
 Power Down for Signal Detect. 1=power down <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_rx_s_pwrdn</td>
<td align=left>
 Active High Power Down control for RX Lane. <br>
 If asserted by writing to 1'b1 will power down the RX Lane. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL - RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL</a></b><br>
Address Offset = 32'h0000_d1a2<br>
Physical Address = 32'h0000_d1a2<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_rx_rclk20_pwrdn_frc_val</td>
<td align=left>
 AFE RX Lane rx_rclk20_pwrdwn force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_rx_rclk20_pwrdn_frc</td>
<td align=left>
 AFE RX Lane rx_rclk20_pwrdwn force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_rx_reset_frc_val</td>
<td align=left>
 AFE RX Lane reset force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_rx_reset_frc</td>
<td align=left>
 AFE RX Lane reset force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_rx_pwrdn_frc_val</td>
<td align=left>
 AFE RX Lane powerdown force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_rx_pwrdn_frc</td>
<td align=left>
 AFE RX Lane powerdown force. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL - RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</a></b><br>
Address Offset = 32'h0000_d1a3<br>
Physical Address = 32'h0000_d1a3<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_rx_h_pwrdn_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_rx_h_pwrdn input pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_DEBUG_RESET_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_LANE_DEBUG_RESET_CONTROL - RX_LANE_DEBUG_RESET_CONTROL</a></b><br>
Address Offset = 32'h0000_d1a4<br>
Physical Address = 32'h0000_d1a4<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_LANE_DEBUG_RESET_CONTROL_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_LANE_DEBUG_RESET_CONTROL_A<br>
Reset Value = 16'h0003<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sigdet_dp_rstb_en</td>
<td align=left>
 If asserted by writing to 1'b1 then lane datapath reset will also reset the sigdet filetr logic alomg with lane register reset. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_rx_dp_s_rstb</td>
<td align=left>
 Active Low Lane Soft Reset for RX datapath. If asserted by writing to 1'b0 will reset the RX datapath for a lane. <br>
 This is a debug only register and it is not handled by FW-HW handshake <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_rx_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset for RX datapath and registers. If asserted by writing to 1'b0 will reset the RX registers and datapath for a lane. <br>
 This is a debug only register and it is not handled by FW-HW handshake <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_CLOCK_N_RESET_DEBUG_CONTROL">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_CLOCK_N_RESET_DEBUG_CONTROL - RX_CLOCK_N_RESET_DEBUG_CONTROL</a></b><br>
Address Offset = 32'h0000_d1a7<br>
Physical Address = 32'h0000_d1a7<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_CLOCK_N_RESET_DEBUG_CONTROL_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_CLOCK_N_RESET_DEBUG_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_rx_clk_vld_frc_val</td>
<td align=left>
 pmd_rx_clk_vld core output pin force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_rx_clk_vld_frc</td>
<td align=left>
 pmd_rx_clk_vld core output pin force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_rx_s_comclk_frc_on</td>
<td align=left>
 Mux control for selection of comclk for RX Lane clocks by force. <br>
 If asserted by writing to 1'b1 will select the comclk for the lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.<br>
" It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_frc_on is asserted to 1'b1<br>
 by using pmd_rx_clk_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_rx_s_comclk_sel</td>
<td align=left>
 Mux control for selection of comclk for RX Lane clocks. <br>
 If asserted by writing to 1'b1 will select the comclk for the lane clocks. <br>
" It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_sel is asserted to 1'b1<br>
 by using pmd_rx_clk_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_rx_s_clkgate_frc_on</td>
<td align=left>
 RX Active High Lane clock gator enable. If 1'1b1 then rx lane clock will be gated off. It does not affect the rclk going <br>
 to RMIC block so rx lane based registers can still be readable but not writable. <br>
" It is recommended for user to force pmd_rx_clk_vld to 1'b0 while rx_s_clkgate_frc_on is asserted to 1'b1<br>
 by using pmd_rx_clk_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_PMD_LANE_MODE_STATUS">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_PMD_LANE_MODE_STATUS - RX_PMD_LANE_MODE_STATUS</a></b><br>
Address Offset = 32'h0000_d1a8<br>
Physical Address = 32'h0000_d1a8<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_PMD_LANE_MODE_STATUS_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_PMD_LANE_MODE_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pmd_rx_lane_mode</td>
<td align=left>
 This indicates the status of the core input pin pmd_rx_lane_mode.&nbsp <br>
 This is driven from PCS and used for communication between PCS and PMD Micro code. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">RX_CKRST_CTRL_8x_pll2x_v1p0_RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS - RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</a></b><br>
Address Offset = 32'h0000_d1ac<br>
Physical Address = 32'h0000_d1ac<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_A<br>
Reset Value = 16'h0007<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_rx_rclk20_pwrdn</td>
<td align=left>
 Indicates the status of the afe_rx_rclk20_pwrdn signal to the AFE after frc/frc_val mux. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_rx_reset</td>
<td align=left>
 Indicates the status of the afe_rx_reset signal to the AFE after frc/frc_val mux. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_rx_pwrdn</td>
<td align=left>
 Indicates the status of the afe_rx_pwrdn signal to the AFE after frc/frc_val mux. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA0">RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA0 - LANE_CFG_FWAPI_DATA0</a></b><br>
Address Offset = 32'h0000_d1ad<br>
Physical Address = 32'h0000_d1ad<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `LANE_CFG_FWAPI_DATA0_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `LANE_CFG_FWAPI_DATA0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>lane_cfg_fwapi_data0</td>
<td align=left>
Lane configuration firmware/API data 0<br>
This is a scratch register used by the firmware and API code to store and/or exchange <br>
lane configuration information<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA1">RX_CKRST_CTRL_8x_pll2x_v1p0_LANE_CFG_FWAPI_DATA1 - LANE_CFG_FWAPI_DATA1</a></b><br>
Address Offset = 32'h0000_d1ae<br>
Physical Address = 32'h0000_d1ae<br>
Verilog CL45 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, `LANE_CFG_FWAPI_DATA1_Adr}<br>
Verilog CL22 Address = {`RX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `LANE_CFG_FWAPI_DATA1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>lane_cfg_fwapi_data1</td>
<td align=left>
Lane configuration firmware/API data 1<br>
This is a scratch register used by the firmware and API code to store and/or exchange <br>
lane configuration information<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#RX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd1b1</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL</A></td><td>TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL</td></tr>
<tr>
<td align=center>0xd1b2</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL</A></td><td>TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL</td></tr>
<tr>
<td align=center>0xd1b3</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</A></td><td>TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</td></tr>
<tr>
<td align=center>0xd1b4</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_DEBUG_RESET_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_DEBUG_RESET_CONTROL</A></td><td>TX_LANE_DEBUG_RESET_CONTROL</td></tr>
<tr>
<td align=center>0xd1b7</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_DEBUG_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_DEBUG_CONTROL</A></td><td>TX_CLOCK_N_RESET_DEBUG_CONTROL</td></tr>
<tr>
<td align=center>0xd1b8</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_PMD_LANE_MODE_STATUS">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_PMD_LANE_MODE_STATUS</A></td><td>TX_PMD_LANE_MODE_STATUS</td></tr>
<tr>
<td align=center>0xd1bc</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</A></td><td>TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</td></tr>
<tr>
<td align=center>0xd1bd</td><td><A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_MISC_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_MISC_CONTROL</A></td><td>TX_CLOCK_N_RESET_MISC_CONTROL</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL - TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL</a></b><br>
Address Offset = 32'h0000_d1b1<br>
Physical Address = 32'h0000_d1b1<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_LANE_CLK_RESET_N_POWERDOWN_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_reset_deassert</td>
<td align=left>
 AFE TX Lane reset control. This register will be reset upon POR reg/pin or lane reset reg/pin. Lower priority than the afe_tx_reset_frc/frc_val option.<br>
 1 - AFE TX Lane tx_reset pin will be forcefully de-asserted irrespective of core/lane datapath pin/reg resets asserted. <br>
&nbsp &nbsp&nbsp This bit must be set to 1'b1 for TX_Disable all 1s/0s mode to allow TX AFE to transmit the all 1s/0s data. <br>
 0 - AFE TX Lane tx_reset pin will be asserted if core/lane pin/reg resets are asserted. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_tx_s_pwrdn</td>
<td align=left>
 Active High Power Down control for TX Lane. <br>
 If asserted by writing to 1'b1 will power down the TX Lane. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL - TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL</a></b><br>
Address Offset = 32'h0000_d1b2<br>
Physical Address = 32'h0000_d1b2<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_LANE_AFE_RESET_PWRDWN_CONTROL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_reset_frc_val</td>
<td align=left>
 AFE TX Lane reset force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_reset_frc</td>
<td align=left>
 AFE TX Lane reset force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_pwrdn_frc_val</td>
<td align=left>
 AFE TX Lane powerdown force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_pwrdn_frc</td>
<td align=left>
 AFE TX Lane powerdown force. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL - TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</a></b><br>
Address Offset = 32'h0000_d1b3<br>
Physical Address = 32'h0000_d1b3<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_tx_h_pwrdn_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_tx_h_pwrdn input pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_DEBUG_RESET_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_LANE_DEBUG_RESET_CONTROL - TX_LANE_DEBUG_RESET_CONTROL</a></b><br>
Address Offset = 32'h0000_d1b4<br>
Physical Address = 32'h0000_d1b4<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_LANE_DEBUG_RESET_CONTROL_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_LANE_DEBUG_RESET_CONTROL_A<br>
Reset Value = 16'h0003<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_tx_dp_s_rstb</td>
<td align=left>
 Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane. <br>
 This is a debug only register and it is not handled by FW-HW handshake <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_tx_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane. <br>
 This is a debug only register and it is not handled by FW-HW handshake <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_DEBUG_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_DEBUG_CONTROL - TX_CLOCK_N_RESET_DEBUG_CONTROL</a></b><br>
Address Offset = 32'h0000_d1b7<br>
Physical Address = 32'h0000_d1b7<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_CLOCK_N_RESET_DEBUG_CONTROL_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_CLOCK_N_RESET_DEBUG_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_tx_clk_vld_frc_val</td>
<td align=left>
 pmd_tx_clk_vld core output pin force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_tx_clk_vld_frc</td>
<td align=left>
 pmd_tx_clk_vld core output pin force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_tx_s_comclk_frc_on</td>
<td align=left>
 Mux control for selection of comclk for TX Lane clocks by force. <br>
 If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.<br>
" It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1<br>
 by using pmd_tx_clk_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_tx_s_comclk_sel</td>
<td align=left>
 Mux control for selection of comclk for TX Lane clocks. <br>
 If asserted by writing to 1'b1 will select the comclk for the lane clocks. <br>
" It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1<br>
 by using pmd_tx_clk_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ln_tx_s_clkgate_frc_on</td>
<td align=left>
 TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk going <br>
 to RMIC block so tx lane based registers can still be readable but not writable. <br>
" It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1<br>
 by using pmd_tx_clk_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_PMD_LANE_MODE_STATUS">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_PMD_LANE_MODE_STATUS - TX_PMD_LANE_MODE_STATUS</a></b><br>
Address Offset = 32'h0000_d1b8<br>
Physical Address = 32'h0000_d1b8<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_PMD_LANE_MODE_STATUS_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_PMD_LANE_MODE_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pmd_tx_lane_mode</td>
<td align=left>
 This indicates the status of the core input pin pmd_rx_lane_mode.&nbsp <br>
 This is driven from PCS and used for communication between PCS and PMD Micro code. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS - TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</a></b><br>
Address Offset = 32'h0000_d1bc<br>
Physical Address = 32'h0000_d1bc<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_A<br>
Reset Value = 16'h0003<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_tx_reset</td>
<td align=left>
 Indicates the status of the afe_tx_reset signal to the AFE after frc/frc_val mux. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_tx_pwrdn</td>
<td align=left>
 Indicates the status of the afe_tx_pwrdn signal to the AFE after frc/frc_val mux. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_MISC_CONTROL">TX_CKRST_CTRL_8x_pll2x_v1p0_TX_CLOCK_N_RESET_MISC_CONTROL - TX_CLOCK_N_RESET_MISC_CONTROL</a></b><br>
Address Offset = 32'h0000_d1bd<br>
Physical Address = 32'h0000_d1bd<br>
Verilog CL45 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, `TX_CLOCK_N_RESET_MISC_CONTROL_Adr}<br>
Verilog CL22 Address = {`TX_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TX_CLOCK_N_RESET_MISC_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_loop_filter_stable</td>
<td align=left>
 This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled. <br>
 When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by
firmware <br>
 to indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#TX_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TX_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<H1><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd1c0</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_CONTROL</A></td><td>RXCOM_OSR_MODE_CONTROL</td></tr>
<tr>
<td align=center>0xd1c1</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</A></td><td>RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</td></tr>
<tr>
<td align=center>0xd1c3</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</A></td><td>RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</td></tr>
<tr>
<td align=center>0xd1c5</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_UC_ACK_LANE_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_UC_ACK_LANE_CONTROL</A></td><td>RXCOM_UC_ACK_LANE_CONTROL</td></tr>
<tr>
<td align=center>0xd1c6</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_REG_RESET_OCCURRED_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_REG_RESET_OCCURRED_CONTROL</A></td><td>RXCOM_LANE_REG_RESET_OCCURRED_CONTROL</td></tr>
<tr>
<td align=center>0xd1c7</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_PLL_SELECT_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_PLL_SELECT_CONTROL</A></td><td>RXCOM_PLL_SELECT_CONTROL</td></tr>
<tr>
<td align=center>0xd1c9</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_DP_RESET_STATE_STATUS">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_DP_RESET_STATE_STATUS</A></td><td>RXCOM_LANE_DP_RESET_STATE_STATUS</td></tr>
<tr>
<td align=center>0xd1ca</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_MULTICAST_MASK_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_MULTICAST_MASK_CONTROL</A></td><td>RXCOM_MULTICAST_MASK_CONTROL</td></tr>
<tr>
<td align=center>0xd1cb</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_STATUS_MC_MASK">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_STATUS_MC_MASK</A></td><td>RXCOM_OSR_MODE_STATUS_MC_MASK</td></tr>
<tr>
<td align=center>0xd1cc</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</A></td><td>RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</td></tr>
<tr>
<td align=center>0xd1ce</td><td><A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LN_S_RSTB_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LN_S_RSTB_CONTROL</A></td><td>RXCOM_LN_S_RSTB_CONTROL</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_CONTROL - RXCOM_OSR_MODE_CONTROL</a></b><br>
Address Offset = 32'h0000_d1c0<br>
Physical Address = 32'h0000_d1c0<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_OSR_MODE_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_OSR_MODE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_osr_mode_frc</td>
<td align=left>
NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode. <br>
Othersise, the pin input values are used for OS mode<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pam4_mode_frc</td>
<td align=left>
PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode. <br>
Othersise, the pin input values are used for pam4 mode<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pam4_mode_frc_val</td>
<td align=left>
PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_osr_mode_frc_val</td>
<td align=left>
NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL - RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</a></b><br>
Address Offset = 32'h0000_d1c1<br>
Physical Address = 32'h0000_d1c1<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_ln_dp_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane. <br>
This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL - RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</a></b><br>
Address Offset = 32'h0000_d1c3<br>
Physical Address = 32'h0000_d1c3<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_rx_dp_h_rstb_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_dp_h_rstb input pin. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_rx_h_rstb_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_h_rstb input pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_UC_ACK_LANE_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_UC_ACK_LANE_CONTROL - RXCOM_UC_ACK_LANE_CONTROL</a></b><br>
Address Offset = 32'h0000_d1c5<br>
Physical Address = 32'h0000_d1c5<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_UC_ACK_LANE_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_UC_ACK_LANE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rx_uc_ack_lane_dp_reset</td>
<td align=left>
 uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured". <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>rx_uc_ack_lane_cfg_done</td>
<td align=left>
 uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 will&nbsp <br>
 should release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_REG_RESET_OCCURRED_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_REG_RESET_OCCURRED_CONTROL - RXCOM_LANE_REG_RESET_OCCURRED_CONTROL</a></b><br>
Address Offset = 32'h0000_d1c6<br>
Physical Address = 32'h0000_d1c6<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_LANE_REG_RESET_OCCURRED_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_LANE_REG_RESET_OCCURRED_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_reg_reset_occurred</td>
<td align=left>
 Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_PLL_SELECT_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_PLL_SELECT_CONTROL - RXCOM_PLL_SELECT_CONTROL</a></b><br>
Address Offset = 32'h0000_d1c7<br>
Physical Address = 32'h0000_d1c7<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_PLL_SELECT_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_PLL_SELECT_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pll_select</td>
<td align=left>
This register controls the selection of the PLL0 or PLL1 as clock source for the rx_ lane. This register will be only reset upon POR hard or POR soft reset.
<br>
This register is expected to be changed only when rx_ lane datapath is in reset. <br>
0 - Select PLL0 as clock for rx_ lane. <br>
1 - Select PLL1 as clock for rx_ lane. <br>
This register bit also drive the AFE rx_ctrl[95] pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_DP_RESET_STATE_STATUS">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LANE_DP_RESET_STATE_STATUS - RXCOM_LANE_DP_RESET_STATE_STATUS</a></b><br>
Address Offset = 32'h0000_d1c9<br>
Physical Address = 32'h0000_d1c9<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_LANE_DP_RESET_STATE_STATUS_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_LANE_DP_RESET_STATE_STATUS_A<br>
Reset Value = 16'h0007<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_lane_dp_reset_state</td>
<td align=left>
 Bit 2: lane_dp_reset_active&nbsp&nbsp : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.&nbsp <br>
 Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.&nbsp
<br>
 Bit 0: lane_dp_reset_held&nbsp &nbsp&nbsp : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001
and uc_ack_lane_cfg_done == 1. <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_MULTICAST_MASK_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_MULTICAST_MASK_CONTROL - RXCOM_MULTICAST_MASK_CONTROL</a></b><br>
Address Offset = 32'h0000_d1ca<br>
Physical Address = 32'h0000_d1ca<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_MULTICAST_MASK_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_MULTICAST_MASK_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>WO</td>
<td align=left valign=top>rx_multicast_mask_control</td>
<td align=left>
This masks the lane from a broadcast or multicast write operation. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_STATUS_MC_MASK">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_OSR_MODE_STATUS_MC_MASK - RXCOM_OSR_MODE_STATUS_MC_MASK</a></b><br>
Address Offset = 32'h0000_d1cb<br>
Physical Address = 32'h0000_d1cb<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_OSR_MODE_STATUS_MC_MASK_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_OSR_MODE_STATUS_MC_MASK_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_multicast_mask_control_status</td>
<td align=left>
Status of multicast mask control for masking lane from multicast write operation. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_pam4_mode</td>
<td align=left>
 PAM4 signalling mode status after the pam4_mode_frc/frc_val mux. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_osr_mode</td>
<td align=left>
 OSR Mode status after the osr_mode_frc/frc_val mux. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS - RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</a></b><br>
Address Offset = 32'h0000_d1cc<br>
Physical Address = 32'h0000_d1cc<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_pam4_mode_pin</td>
<td align=left>
 Indicates the status of the pmd_pam4_mode input pin. <br>
 Decoding of pmd_pam4_mode[2:0] pin and pam4_mode registers are as follows. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rx_osr_mode_pin</td>
<td align=left>
 Indicates the status of the pmd_osr_mode input pin. <br>
 Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LN_S_RSTB_CONTROL">RXCOM_CKRST_CTRL_8x_pll2x_v1p0_RXCOM_LN_S_RSTB_CONTROL - RXCOM_LN_S_RSTB_CONTROL</a></b><br>
Address Offset = 32'h0000_d1ce<br>
Physical Address = 32'h0000_d1ce<br>
Verilog CL45 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `RXCOM_LN_S_RSTB_CONTROL_Adr}<br>
Verilog CL22 Address = {`RXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `RXCOM_LN_S_RSTB_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_hw_fw_handshake_disable</td>
<td align=left>
This register bit is unused in RX lane. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_ln_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane. <br>
This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#RXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to RXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd1d0</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_CONTROL</A></td><td>TXCOM_OSR_MODE_CONTROL</td></tr>
<tr>
<td align=center>0xd1d1</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</A></td><td>TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</td></tr>
<tr>
<td align=center>0xd1d3</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</A></td><td>TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</td></tr>
<tr>
<td align=center>0xd1d5</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_UC_ACK_LANE_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_UC_ACK_LANE_CONTROL</A></td><td>TXCOM_UC_ACK_LANE_CONTROL</td></tr>
<tr>
<td align=center>0xd1d6</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_REG_RESET_OCCURRED_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_REG_RESET_OCCURRED_CONTROL</A></td><td>TXCOM_LANE_REG_RESET_OCCURRED_CONTROL</td></tr>
<tr>
<td align=center>0xd1d7</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_PLL_SELECT_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_PLL_SELECT_CONTROL</A></td><td>TXCOM_PLL_SELECT_CONTROL</td></tr>
<tr>
<td align=center>0xd1d9</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_DP_RESET_STATE_STATUS">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_DP_RESET_STATE_STATUS</A></td><td>TXCOM_LANE_DP_RESET_STATE_STATUS</td></tr>
<tr>
<td align=center>0xd1da</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_MULTICAST_MASK_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_MULTICAST_MASK_CONTROL</A></td><td>TXCOM_MULTICAST_MASK_CONTROL</td></tr>
<tr>
<td align=center>0xd1db</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_STATUS_MC_MASK">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_STATUS_MC_MASK</A></td><td>TXCOM_OSR_MODE_STATUS_MC_MASK</td></tr>
<tr>
<td align=center>0xd1dc</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</A></td><td>TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</td></tr>
<tr>
<td align=center>0xd1de</td><td><A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LN_S_RSTB_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LN_S_RSTB_CONTROL</A></td><td>TXCOM_LN_S_RSTB_CONTROL</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_CONTROL - TXCOM_OSR_MODE_CONTROL</a></b><br>
Address Offset = 32'h0000_d1d0<br>
Physical Address = 32'h0000_d1d0<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_OSR_MODE_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_OSR_MODE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_osr_mode_frc</td>
<td align=left>
NRZ/PAM4 oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode. <br>
Othersise, the pin input values are used for OS mode<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pam4_mode_frc</td>
<td align=left>
PAM4 signalling mode force. Setting this bit will allow the register value to be used for pam4 mode. <br>
Othersise, the pin input values are used for pam4 mode<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pam4_mode_frc_val</td>
<td align=left>
PAM4 signalling mode Decoding of this register is as follows. osr_mode should be 4'd0 or 4'd1 for the PAM4 modes below. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_osr_mode_frc_val</td>
<td align=left>
NRZ/PAM4 oversample (OS) mode Decoding of this register is as follows. pam4_mode should be 3'd0 or 3'd1 for this NRZ/PAM4 OS modes. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL - TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL</a></b><br>
Address Offset = 32'h0000_d1d1<br>
Physical Address = 32'h0000_d1d1<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_LANE_CLK_RESET_N_POWERDOWN_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_ln_dp_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane. <br>
This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL - TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL</a></b><br>
Address Offset = 32'h0000_d1d3<br>
Physical Address = 32'h0000_d1d3<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_LANE_RESET_N_PWRDN_PIN_KILL_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_tx_dp_h_rstb_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_dp_h_rstb input pin. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_ln_tx_h_rstb_pkill</td>
<td align=left>
 1'b1 will disable the pmd_ln_h_rstb input pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_UC_ACK_LANE_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_UC_ACK_LANE_CONTROL - TXCOM_UC_ACK_LANE_CONTROL</a></b><br>
Address Offset = 32'h0000_d1d5<br>
Physical Address = 32'h0000_d1d5<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_UC_ACK_LANE_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_UC_ACK_LANE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>tx_uc_ack_lane_dp_reset</td>
<td align=left>
 uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured". <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>tx_uc_ack_lane_cfg_done</td>
<td align=left>
 uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 will&nbsp <br>
 should release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_REG_RESET_OCCURRED_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_REG_RESET_OCCURRED_CONTROL - TXCOM_LANE_REG_RESET_OCCURRED_CONTROL</a></b><br>
Address Offset = 32'h0000_d1d6<br>
Physical Address = 32'h0000_d1d6<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_LANE_REG_RESET_OCCURRED_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_LANE_REG_RESET_OCCURRED_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_reg_reset_occurred</td>
<td align=left>
 Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_PLL_SELECT_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_PLL_SELECT_CONTROL - TXCOM_PLL_SELECT_CONTROL</a></b><br>
Address Offset = 32'h0000_d1d7<br>
Physical Address = 32'h0000_d1d7<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_PLL_SELECT_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_PLL_SELECT_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pll_select</td>
<td align=left>
This register controls the selection of the PLL0 or PLL1 as clock source for the tx_ lane. This register will be only reset upon POR hard or POR soft reset.
<br>
This register is expected to be changed only when tx_ lane datapath is in reset. <br>
0 - Select PLL0 as clock for tx_ lane. <br>
1 - Select PLL1 as clock for tx_ lane. <br>
This register bit also drive the AFE tx_ctrl[0] pin. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_DP_RESET_STATE_STATUS">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LANE_DP_RESET_STATE_STATUS - TXCOM_LANE_DP_RESET_STATE_STATUS</a></b><br>
Address Offset = 32'h0000_d1d9<br>
Physical Address = 32'h0000_d1d9<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_LANE_DP_RESET_STATE_STATUS_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_LANE_DP_RESET_STATE_STATUS_A<br>
Reset Value = 16'h0007<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_lane_dp_reset_state</td>
<td align=left>
 Bit 2: lane_dp_reset_active&nbsp&nbsp : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.&nbsp <br>
 Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.&nbsp
<br>
 Bit 0: lane_dp_reset_held&nbsp &nbsp&nbsp : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001
and uc_ack_lane_cfg_done == 1. <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_MULTICAST_MASK_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_MULTICAST_MASK_CONTROL - TXCOM_MULTICAST_MASK_CONTROL</a></b><br>
Address Offset = 32'h0000_d1da<br>
Physical Address = 32'h0000_d1da<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_MULTICAST_MASK_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_MULTICAST_MASK_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>WO</td>
<td align=left valign=top>tx_multicast_mask_control</td>
<td align=left>
This masks the lane from a broadcast or multicast write operation. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_STATUS_MC_MASK">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_OSR_MODE_STATUS_MC_MASK - TXCOM_OSR_MODE_STATUS_MC_MASK</a></b><br>
Address Offset = 32'h0000_d1db<br>
Physical Address = 32'h0000_d1db<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_OSR_MODE_STATUS_MC_MASK_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_OSR_MODE_STATUS_MC_MASK_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_multicast_mask_control_status</td>
<td align=left>
Status of multicast mask control for masking lane from multicast write operation. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pam4_mode</td>
<td align=left>
 PAM4 signalling mode status after the pam4_mode_frc/frc_val mux. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_osr_mode</td>
<td align=left>
 OSR Mode status after the osr_mode_frc/frc_val mux. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS - TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS</a></b><br>
Address Offset = 32'h0000_d1dc<br>
Physical Address = 32'h0000_d1dc<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_AFE_RESET_PWRDN_OSR_MODE_PIN_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pam4_mode_pin</td>
<td align=left>
 Indicates the status of the pmd_pam4_mode input pin. <br>
 Decoding of pmd_pam4_mode[2:0] pin and pam4_mode registers are as follows. <br>
&nbsp &nbsp NRZ OS modes&nbsp 3'd0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp PAM4 OS modes 3'd1&nbsp &nbsp &nbsp &nbsp&nbsp (rx_pam4_es_mode reg field when 1'b1 is ES mode and 1'b0 is NS mode) <br>
&nbsp &nbsp Reserved&nbsp &nbsp &nbsp 3'd2:3d7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_osr_mode_pin</td>
<td align=left>
 Indicates the status of the pmd_osr_mode input pin. <br>
 Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows. <br>
&nbsp &nbsp OSX1&nbsp &nbsp &nbsp &nbsp &nbsp 4'd0&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX2&nbsp &nbsp &nbsp &nbsp &nbsp 4'd1&nbsp &nbsp&nbsp (NRZ mode and PAM4 mode)&nbsp&nbsp <br>
&nbsp &nbsp OSX4&nbsp &nbsp &nbsp &nbsp &nbsp 4'd2&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX21P25&nbsp &nbsp &nbsp 4'd4&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16P5&nbsp &nbsp &nbsp&nbsp 4'd8&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX20P625&nbsp &nbsp&nbsp 4'd12&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX8&nbsp &nbsp &nbsp &nbsp &nbsp 4'd5&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX16&nbsp &nbsp &nbsp &nbsp&nbsp 4'd9&nbsp &nbsp&nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
&nbsp &nbsp OSX32&nbsp &nbsp &nbsp &nbsp&nbsp 4'd13&nbsp &nbsp (NRZ mode only&nbsp &nbsp &nbsp &nbsp&nbsp )&nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LN_S_RSTB_CONTROL">TXCOM_CKRST_CTRL_8x_pll2x_v1p0_TXCOM_LN_S_RSTB_CONTROL - TXCOM_LN_S_RSTB_CONTROL</a></b><br>
Address Offset = 32'h0000_d1de<br>
Physical Address = 32'h0000_d1de<br>
Verilog CL45 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, `TXCOM_LN_S_RSTB_CONTROL_Adr}<br>
Verilog CL22 Address = {`TXCOM_CKRST_CTRL_8x_pll2x_v1p0_A, 4'h0}, `TXCOM_LN_S_RSTB_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_hw_fw_handshake_disable</td>
<td align=left>
1: disables the HW-FW handshake logic for the TX lane which means there is no acknowledgement required from uC and lane reset will be de-asserted once
reset register/pin conditions are de-asserted. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_ln_s_rstb</td>
<td align=left>
Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane. <br>
This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#TXCOM_CKRST_CTRL_8x_pll2x_v1p0 Registers">Return to TXCOM_CKRST_CTRL_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<H1><a NAME="AMS_RX Registers">AMS_RX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd0c0</td><td><A HREF="#AMS_RX_RX_CONTROL_0">AMS_RX_RX_CONTROL_0</A></td><td>AMS RX CONTROL_0</td></tr>
<tr>
<td align=center>0xd0c1</td><td><A HREF="#AMS_RX_RX_CONTROL_1">AMS_RX_RX_CONTROL_1</A></td><td>AMS RX CONTROL_1</td></tr>
<tr>
<td align=center>0xd0c2</td><td><A HREF="#AMS_RX_RX_CONTROL_2">AMS_RX_RX_CONTROL_2</A></td><td>AMS RX CONTROL_2</td></tr>
<tr>
<td align=center>0xd0c3</td><td><A HREF="#AMS_RX_RX_CONTROL_3">AMS_RX_RX_CONTROL_3</A></td><td>AMS RX CONTROL_3</td></tr>
<tr>
<td align=center>0xd0c4</td><td><A HREF="#AMS_RX_RX_CONTROL_4">AMS_RX_RX_CONTROL_4</A></td><td>AMS RX CONTROL_4</td></tr>
<tr>
<td align=center>0xd0c5</td><td><A HREF="#AMS_RX_RX_CONTROL_5">AMS_RX_RX_CONTROL_5</A></td><td>AMS RX CONTROL_5</td></tr>
<tr>
<td align=center>0xd0c6</td><td><A HREF="#AMS_RX_RX_CONTROL_6">AMS_RX_RX_CONTROL_6</A></td><td>AMS RX CONTROL_6</td></tr>
<tr>
<td align=center>0xd0c7</td><td><A HREF="#AMS_RX_RX_CONTROL_7">AMS_RX_RX_CONTROL_7</A></td><td>AMS RX CONTROL_7</td></tr>
<tr>
<td align=center>0xd0c8</td><td><A HREF="#AMS_RX_RX_CONTROL_8">AMS_RX_RX_CONTROL_8</A></td><td>AMS RX CONTROL_8</td></tr>
<tr>
<td align=center>0xd0c9</td><td><A HREF="#AMS_RX_RX_CONTROL_9">AMS_RX_RX_CONTROL_9</A></td><td>AMS RX CONTROL_9</td></tr>
<tr>
<td align=center>0xd0ca</td><td><A HREF="#AMS_RX_RX_CONTROL_10">AMS_RX_RX_CONTROL_10</A></td><td>AMS RX CONTROL_10</td></tr>
<tr>
<td align=center>0xd0cc</td><td><A HREF="#AMS_RX_RX_STATUS">AMS_RX_RX_STATUS</A></td><td>AMS RX STATUS</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_0">AMS_RX_RX_CONTROL_0 - AMS RX CONTROL_0</a></b><br>
Address Offset = 32'h0000_d0c0<br>
Physical Address = 32'h0000_d0c0<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_0_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_0_A<br>
Reset Value = 16'h0010<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_peaking_filter_ibias</td>
<td align=left>
 peaking filter ibias (max, mode, min) amsbus ctrl_out&nbsp 15:13 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dc_couple</td>
<td align=left>
&nbsp for QSGMII DC mode with 50 Ohm pull-up to RVDD0P8 amsbus ctrl_out&nbsp 12:12DFT_DFS=1'b0 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfe_hgain_en</td>
<td align=left>
&nbsp enables high, fixed gain for the DFE summer and buffer and non-DFE modes. amsbus ctrl_out&nbsp 11:11 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_eq_lz_en</td>
<td align=left>
&nbsp enables lower freq EQ peaking used in 10G mode, both bits [10:9] must be asserted for the complete 10G mode amsbus ctrl_out&nbsp 10:10 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga_10g_bw</td>
<td align=left>
&nbsp reduces the the VGA BW for 10G mode. Also see rx_ctrl[111:108] amsbus ctrl_out&nbsp 9:9 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_tport_en</td>
<td align=left>
&nbsp output rx_rclk20 to PLL test port amsbus ctrl_out&nbsp 8:8DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_rxclk66_en</td>
<td align=left>
&nbsp enables 66T clock amsbus ctrl_out&nbsp 7:7DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sigdet_pwrdn</td>
<td align=left>
&nbsp default=0 for enable signal detector amsbus ctrl_out&nbsp 6:6DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sigdet_threshold</td>
<td align=left>
&nbsp NA. Please use afe_sigdet_thresh from sigdet module. amsbus ctrl_out&nbsp 5:3 <br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_master_diodes_ibias</td>
<td align=left>
&nbsp master diodes ibias (max, mode, min) amsbus ctrl_out&nbsp 2:0DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_1">AMS_RX_RX_CONTROL_1 - AMS RX CONTROL_1</a></b><br>
Address Offset = 32'h0000_d0c1<br>
Physical Address = 32'h0000_d0c1<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_1_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_cm_voltage_ibias</td>
<td align=left>
&nbsp input CM voltage ibias (max, mode, min) amsbus ctrl_out&nbsp 31:29DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_ibias</td>
<td align=left>
&nbsp pf3_ibias (max, mode, min) amsbus ctrl_out&nbsp 28:26 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga2_ibias</td>
<td align=left>
&nbsp VGA2 ibias (max, mode, min) amsbus ctrl_out&nbsp 25:23 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga1_ibias</td>
<td align=left>
&nbsp VGA1 ibias (max, mode, min) amsbus ctrl_out&nbsp 22:20 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga0_ibias</td>
<td align=left>
&nbsp VGA0 ibias (max, mode, min) amsbus ctrl_out&nbsp 19:17 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_bypass_ac_cap</td>
<td align=left>
&nbsp test mode to bypass the internal AC cap to measure the internal DC voltages. Not intended for normal operation with data traffic. amsbus ctrl_out&nbsp
16:16DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_2">AMS_RX_RX_CONTROL_2 - AMS RX CONTROL_2</a></b><br>
Address Offset = 32'h0000_d0c2<br>
Physical Address = 32'h0000_d0c2<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_2_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_2_A<br>
Reset Value = 16'h0e00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pwrdn_ftap</td>
<td align=left>
&nbsp power down for the DFE floating taps, use for 25G-SR and all OS2 and OS4 modes, ~-1mW amsbus ctrl_out&nbsp 47:47 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga3_ind</td>
<td align=left>
&nbsp adjusts the inductor value for VGA3 amsbus ctrl_out&nbsp 46:46 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pd_ch_p1</td>
<td align=left>
&nbsp power down the p1, aka lms, channel, reduces power by ~10mW amsbus ctrl_out&nbsp 45:45 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sel_th4dfe</td>
<td align=left>
&nbsp DFE tap threshold voltage 00=12mW, 01=150mV, 10=175mV, 11=200mV amsbus ctrl_out&nbsp 44:43 <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfesum_bw</td>
<td align=left>
&nbsp set BW of DFE summer stage, 00 = <15G, 01 = 15-20G, 10 = 20-25G, 11 = >25G amsbus ctrl_out&nbsp 42:41 <br>
Reset value is 0x3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfe_tap_weight_ibias</td>
<td align=left>
&nbsp DFE tap weight ibias (max, mode, min) amsbus ctrl_out&nbsp 40:38 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_phase_interpolators_ibias</td>
<td align=left>
&nbsp phase interpolators ibias (max, mode, min) amsbus ctrl_out&nbsp 37:35DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sigdet_ibias</td>
<td align=left>
&nbsp signal detect ibias (max, mode, min) amsbus ctrl_out&nbsp 34:32 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_3">AMS_RX_RX_CONTROL_3 - AMS RX CONTROL_3</a></b><br>
Address Offset = 32'h0000_d0c3<br>
Physical Address = 32'h0000_d0c3<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_3_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_ffe_enable</td>
<td align=left>
&nbsp ffe enable, is non-sampled, continuous mode with FFE clocks off amsbus ctrl_out&nbsp 63:63 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfe_slicer_ibias</td>
<td align=left>
&nbsp dfe_slicer_ibias (max, mode, min), only mux/latch amsbus ctrl_out&nbsp 62:60 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfe_sum_buf_ibias</td>
<td align=left>
&nbsp DFE sum/buf ibias (max, mode, min) amsbus ctrl_out&nbsp 59:57 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_offset_correction_ibias</td>
<td align=left>
&nbsp offset correction ibias (max, mode, min) amsbus ctrl_out&nbsp 56:54 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dll_ibias</td>
<td align=left>
&nbsp DLL ibias (max, mode, min), clkgen for 4-phase div and mux amsbus ctrl_out&nbsp 53:51DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_met_r_ibias</td>
<td align=left>
&nbsp met R ibias (max, mode, min), threshold voltage ladder amsbus ctrl_out&nbsp 50:48 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_4">AMS_RX_RX_CONTROL_4 - AMS RX CONTROL_4</a></b><br>
Address Offset = 32'h0000_d0c4<br>
Physical Address = 32'h0000_d0c4<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_4_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga1_rescal_mux</td>
<td align=left>
&nbsp VGA1 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out&nbsp 79:75 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga0_rescal_mux</td>
<td align=left>
&nbsp VGA0 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out&nbsp 74:70 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_ffe_sha_ibias</td>
<td align=left>
&nbsp FFE sample and hold bias, BGR (max, mode, min) amsbus ctrl_out&nbsp 69:67 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_ffe_summer_tap_ibias</td>
<td align=left>
&nbsp FFE tap weight bias, 3P1CcaIR (max, mode, min) amsbus ctrl_out&nbsp 66:64 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_5">AMS_RX_RX_CONTROL_5 - AMS RX CONTROL_5</a></b><br>
Address Offset = 32'h0000_d0c5<br>
Physical Address = 32'h0000_d0c5<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_5_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sd_cal_en</td>
<td align=left>
&nbsp enables the calibration of the signal detect cicruits to cover about +/-20mV amsbus ctrl_out&nbsp 95:95 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_testclk_mux</td>
<td align=left>
&nbsp selects between local test clock, defined by rx_ctrl[93:92], and from adjacent lane, 0 = local, 1 = adjacent amsbus ctrl_out&nbsp 94:94 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_testclk_div</td>
<td align=left>
&nbsp divides/muxes rclk20 for test port, 00:div1, 01:div2, 10:div4, 11:div8, also see rx_ctrl[8] amsbus ctrl_out&nbsp 93:92 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sd_cal_polarity</td>
<td align=left>
&nbsp selects the pos or neg threshold path for signal detect calibration amsbus ctrl_out&nbsp 91:91 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sd_cal_pos</td>
<td align=left>
&nbsp offfset adj bits for SD pos amsbus ctrl_out&nbsp 90:88 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sd_cal_neg</td>
<td align=left>
&nbsp offfset adj bits for SD neg amsbus ctrl_out&nbsp 87:85 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga2_rescal_mux</td>
<td align=left>
&nbsp VGA2 rescal mux (force, ctrl[3:0]) - rescal override amsbus ctrl_out&nbsp 84:80 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_6">AMS_RX_RX_CONTROL_6 - AMS RX CONTROL_6</a></b><br>
Address Offset = 32'h0000_d0c6<br>
Physical Address = 32'h0000_d0c6<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_6_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_6_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfe_summer_vcm</td>
<td align=left>
&nbsp adjusts summer Vcm to match ladder Vcm amsbus ctrl_out&nbsp 111:110 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_en_tap9delay</td>
<td align=left>
&nbsp increased to 2 bits for 16nm 00 => 25G, 01 = 22-25G, 1x = <22G amsbus ctrl_out&nbsp 109:108 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_cml_lp</td>
<td align=left>
&nbsp DFE mux selection and latch. Assert for OS2 and OS4 rates to lower power. ~10mW. Not part of 25G VSR mode amsbus ctrl_out&nbsp 107:107 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dfesum_lp</td>
<td align=left>
&nbsp Adds peaking at 17G, intended for VSR mode with no DFE, lower power ~5mW amsbus ctrl_out&nbsp 106:106 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pd_phs_slr</td>
<td align=left>
&nbsp power down +2, -2 phase slicers amsbus ctrl_out&nbsp 105:105 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_rxclk32_en</td>
<td align=left>
&nbsp enables 32T clock amsbus ctrl_out&nbsp 104:104DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_offset_correction_rescal_mux</td>
<td align=left>
&nbsp offset correction rescal mux (force, ctrl[3:1]) - rescal override amsbus ctrl_out&nbsp 103:100 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_peaking_filter_rescal_mux</td>
<td align=left>
&nbsp peaking filter rescal mux- (force, ctrl[3:1]) -rescal override amsbus ctrl_out&nbsp 99:96 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_7">AMS_RX_RX_CONTROL_7 - AMS RX CONTROL_7</a></b><br>
Address Offset = 32'h0000_d0c7<br>
Physical Address = 32'h0000_d0c7<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_7_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_7_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga_step_mode</td>
<td align=left>
&nbsp VGA step mode, See AMS amsbus ctrl_out&nbsp 127:126 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_eq_pkcomp_dis</td>
<td align=left>
&nbsp disables the residual peaking compensation cap at the EQ output. Peaking ~3-5dB at ~11 GHz over PVT. Test mode amsbus ctrl_out&nbsp 125:125 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_eq_ind_dis</td>
<td align=left>
&nbsp shunts and disables inductor peaking which reduces the EQ BW for OS2 modes, overriden by rx_ctrl[10]. Test mode amsbus ctrl_out&nbsp 124:124 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dc_offset_half_range</td>
<td align=left>
&nbsp reduces DC offset range and LSB by 50% to improve accuracy amsbus ctrl_out&nbsp 123:123 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_short_vga_output</td>
<td align=left>
&nbsp used for slicer calibration amsbus ctrl_out&nbsp 122:122 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_rx_offset_pd</td>
<td align=left>
&nbsp pwrdn AFE offset cancellation DAC amsbus ctrl_out&nbsp 121:121 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_force_dc_offset</td>
<td align=left>
&nbsp enables override using register bits amsbus ctrl_out&nbsp 120:120 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dc_offset</td>
<td align=left>
&nbsp dc_offset amsbus ctrl_out&nbsp 119:112 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_8">AMS_RX_RX_CONTROL_8 - AMS RX CONTROL_8</a></b><br>
Address Offset = 32'h0000_d0c8<br>
Physical Address = 32'h0000_d0c8<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_8_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_8_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dac4ck_phs_q</td>
<td align=left>
&nbsp dac4ck_phs_q amsbus ctrl_out&nbsp 143:140 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dac4ck_phs_i</td>
<td align=left>
&nbsp dac4ck_phs_i amsbus ctrl_out&nbsp 139:136 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dac4ck_lms_q</td>
<td align=left>
&nbsp dac4ck_lms_q amsbus ctrl_out&nbsp 135:132 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dac4ck_lms_i</td>
<td align=left>
&nbsp dac4ck_lms_i amsbus ctrl_out&nbsp 131:128 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_9">AMS_RX_RX_CONTROL_9 - AMS RX CONTROL_9</a></b><br>
Address Offset = 32'h0000_d0c9<br>
Physical Address = 32'h0000_d0c9<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_9_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_9_A<br>
Reset Value = 16'h0300<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_clock_cal_en</td>
<td align=left>
&nbsp send PLL clock to slicer inputs for phase alignment calibration amsbus ctrl_out&nbsp 159:159 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_d2c_clkbuf_ibias</td>
<td align=left>
&nbsp d2c and clock buffer ibias (max, mode, min) - one control bus for six 100uA currents. amsbus ctrl_out&nbsp 158:156DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_sel_d2clp</td>
<td align=left>
&nbsp 0, high power for 25-28g amsbus ctrl_out&nbsp 155:155DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_spare_154</td>
<td align=left>
&nbsp NA. Use pll_select register fields from ckrst_ctrl regmap. 0=4T clks from PLL0; 1=4T clks from PLL1 amsbus ctrl_out&nbsp 154:154 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_clk_bw_ctrl</td>
<td align=left>
&nbsp clk_bw_ctrl<1:0> for 15G to 28G, see AMS amsbus ctrl_out&nbsp 153:152DFT_MUX <br>
Reset value is 0x3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dac4ck_dat_q</td>
<td align=left>
&nbsp 4-bit for each clock: dac4ck[3:0], sign+binary(2:0). 0000 or 1000 is default without adjustment. 0111(+) abd 1111(-) is the maximum value amsbus
ctrl_out&nbsp 151:148DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_dac4ck_dat_i</td>
<td align=left>
&nbsp 4-bit for each clock: dac4ck[3:0], sign+binary(2:0). 0000 or 1000 is default without adjustment. 0111(+) abd 1111(-) is the maximum value amsbus
ctrl_out&nbsp 147:144DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_CONTROL_10">AMS_RX_RX_CONTROL_10 - AMS RX CONTROL_10</a></b><br>
Address Offset = 32'h0000_d0ca<br>
Physical Address = 32'h0000_d0ca<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_CONTROL_10_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_CONTROL_10_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga_bw_ctrl_ind</td>
<td align=left>
&nbsp coarse BW control for the VGA stages, removes shunt peaking inductors, VGA3, VGA10 amsbus ctrl_out&nbsp 175:174 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_vga_bw_ctrl_cap</td>
<td align=left>
&nbsp fine BW control for the VGA stages, adds caps to VGA01 amsbus ctrl_out&nbsp 173:172 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_pkcomp_dis</td>
<td align=left>
&nbsp disables the residual peaking compensation cap at the PF3 output. Peaking ~3-5dB at ~11GHz over PVT. Test mode amsbus ctrl_out&nbsp 171:171 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_ind_dis</td>
<td align=left>
&nbsp shunts and disables inductor peaking which reduces the PF3 BW, overridden by rx_ctrl[169]. Test mode amsbus ctrl_out&nbsp 170:170 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_lz_en</td>
<td align=left>
&nbsp shift zero/pole pair to lower freq amsbus ctrl_out&nbsp 169:169 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_max_bw</td>
<td align=left>
&nbsp increases rolloff pole BW 20%, lowers DC gain 2 dB, rescal still valid, bias currents not scaled amsbus ctrl_out&nbsp 168:168 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_rescal_mux</td>
<td align=left>
&nbsp (force, ctrl[3:1]) - rescal override. Can be used to adjust the BW vs gain & possibly peaking amsbus ctrl_out&nbsp 167:164 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_rx_pf3_ctrl</td>
<td align=left>
&nbsp controls boost for new PF with higher freq range, Gray code amsbus ctrl_out&nbsp 163:160 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_RX_RX_STATUS">AMS_RX_RX_STATUS - AMS RX STATUS</a></b><br>
Address Offset = 32'h0000_d0cc<br>
Physical Address = 32'h0000_d0cc<br>
Verilog CL45 Address = {`AMS_RX_A, `RX_STATUS_Adr}<br>
Verilog CL22 Address = {`AMS_RX_A, 4'h0}, `RX_STATUS_A<br>
Reset Value = 16'h8000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_rx_sigdet</td>
<td align=left>
&nbsp Signal Detect status<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:11</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_rx_pf</td>
<td align=left>
&nbsp Copy of peaking filter control rx_pf_ctrl[3:0]<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_rx_data_thresh_sel</td>
<td align=left>
&nbsp RX data thresh sel<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_rx_vga</td>
<td align=left>
&nbsp Copy of VGA control vga_ctrl[4:0]<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_RX Registers">Return to AMS_RX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="AMS_TX Registers">AMS_TX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd0d0</td><td><A HREF="#AMS_TX_TX_CONTROL_0">AMS_TX_TX_CONTROL_0</A></td><td>AMS TX CONTROL_0</td></tr>
<tr>
<td align=center>0xd0d1</td><td><A HREF="#AMS_TX_TX_CONTROL_1">AMS_TX_TX_CONTROL_1</A></td><td>AMS TX CONTROL_1</td></tr>
<tr>
<td align=center>0xd0d2</td><td><A HREF="#AMS_TX_TX_CONTROL_2">AMS_TX_TX_CONTROL_2</A></td><td>AMS TX CONTROL_2</td></tr>
<tr>
<td align=center>0xd0d3</td><td><A HREF="#AMS_TX_TX_CONTROL_3">AMS_TX_TX_CONTROL_3</A></td><td>AMS TX CONTROL_3</td></tr>
<tr>
<td align=center>0xd0d8</td><td>AMS_TX_TX_INTCTRL</td><td>INTERNAL TX CONTROL</td></tr>
<tr>
<td align=center>0xd0d9</td><td><A HREF="#AMS_TX_TX_STATUS">AMS_TX_TX_STATUS</A></td><td>AMS TX STATUS</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="AMS_TX_TX_CONTROL_0">AMS_TX_TX_CONTROL_0 - AMS TX CONTROL_0</a></b><br>
Address Offset = 32'h0000_d0d0<br>
Physical Address = 32'h0000_d0d0<br>
Verilog CL45 Address = {`AMS_TX_A, `TX_CONTROL_0_Adr}<br>
Verilog CL22 Address = {`AMS_TX_A, 4'h0}, `TX_CONTROL_0_A<br>
Reset Value = 16'h0040<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_cal_aux</td>
<td align=left>
 Rescal manual control when cal_off=1 amsbus ctrl_out&nbsp 15:12DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_cal_off</td>
<td align=left>
&nbsp disable RESCAL[3:0], enable cal_aux[3:0] amsbus ctrl_out&nbsp 11:11DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_dcc_dis</td>
<td align=left>
&nbsp disable differential DC correction, common mode feedback only amsbus ctrl_out&nbsp 10:10 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_9</td>
<td align=left>
&nbsp AMS reserved [9] amsbus ctrl_out&nbsp 9:9 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_vddr_bgb</td>
<td align=left>
&nbsp bias mode control for LDO reference amsbus ctrl_out&nbsp 8:8DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_ticksel</td>
<td align=left>
&nbsp timing control of load signal at ana/dig interface, use 01 for all rates amsbus ctrl_out&nbsp 7:6 <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_5</td>
<td align=left>
&nbsp AMS reserved bits 5 amsbus ctrl_out&nbsp 5:5 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_skew_enable</td>
<td align=left>
&nbsp skew enable amsbus ctrl_out&nbsp 4:4 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_skew_polarity</td>
<td align=left>
&nbsp skew polarity 0=delay TX N, 1=delay TX P amsbus ctrl_out&nbsp 3:3 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_skew_pn</td>
<td align=left>
&nbsp adjusts skew between TX P and N outputs, ~0.5ps per step amsbus ctrl_out&nbsp 2:0 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_TX Registers">Return to AMS_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_TX_TX_CONTROL_1">AMS_TX_TX_CONTROL_1 - AMS TX CONTROL_1</a></b><br>
Address Offset = 32'h0000_d0d1<br>
Physical Address = 32'h0000_d0d1<br>
Verilog CL45 Address = {`AMS_TX_A, `TX_CONTROL_1_Adr}<br>
Verilog CL22 Address = {`AMS_TX_A, 4'h0}, `TX_CONTROL_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_txclk32_en</td>
<td align=left>
&nbsp enables the 32T clock. amsbus ctrl_out&nbsp 31:31DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_txclk66_en</td>
<td align=left>
&nbsp enables the 66T clock. amsbus ctrl_out&nbsp 30:30DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_ldo_vref</td>
<td align=left>
&nbsp adjusts internal driver supply voltage, scales output amplitute ~2% per step. 00=0.89V, 01=0.93V, 10=0.97V, 11=1.01V amsbus ctrl_out&nbsp 29:28DFT_MUX
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_ildo</td>
<td align=left>
&nbsp LDO bias current control amsbus ctrl_out&nbsp 27:25 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_24_22</td>
<td align=left>
&nbsp AMS reserved [24:22] amsbus ctrl_out&nbsp 24:22 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_iphint</td>
<td align=left>
&nbsp phase interpolator current control amsbus ctrl_out&nbsp 21:19DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_ibias</td>
<td align=left>
&nbsp master bias diode amsbus ctrl_out&nbsp 18:16DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_TX Registers">Return to AMS_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_TX_TX_CONTROL_2">AMS_TX_TX_CONTROL_2 - AMS TX CONTROL_2</a></b><br>
Address Offset = 32'h0000_d0d2<br>
Physical Address = 32'h0000_d0d2<br>
Verilog CL45 Address = {`AMS_TX_A, `TX_CONTROL_2_Adr}<br>
Verilog CL22 Address = {`AMS_TX_A, 4'h0}, `TX_CONTROL_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_elec_idle_aux</td>
<td align=left>
&nbsp force electrical idle mode amsbus ctrl_out&nbsp 47:47DFT_MUX_AND_PRE <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_46_40</td>
<td align=left>
&nbsp AMS reserved bits 46:40 amsbus ctrl_out&nbsp 46:40 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_driver_res_cal</td>
<td align=left>
&nbsp dedicated rescal code for the DAC driver amsbus ctrl_out&nbsp 39:38 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_test_data</td>
<td align=left>
&nbsp generates output pattern amsbus ctrl_out&nbsp 37:36 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_slew_rate</td>
<td align=left>
&nbsp Enables both the HPF bits to add loading to the TX output and increase the transition time for compliance with lower speed standards amsbus ctrl_out&nbsp
35:35 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_34</td>
<td align=left>
&nbsp NA. Use pll_select register fields from ckrst_ctrl regmap. 0=2T clks from PLL0; 1=2T clks from PLL1 amsbus ctrl_out&nbsp 34:34 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_hpf_ctrl</td>
<td align=left>
&nbsp adds a feed forward zero to tx output.helps to cancel pkg loss w/o using FIR range amsbus ctrl_out&nbsp 33:32DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_TX Registers">Return to AMS_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_TX_TX_CONTROL_3">AMS_TX_TX_CONTROL_3 - AMS TX CONTROL_3</a></b><br>
Address Offset = 32'h0000_d0d3<br>
Physical Address = 32'h0000_d0d3<br>
Verilog CL45 Address = {`AMS_TX_A, `TX_CONTROL_3_Adr}<br>
Verilog CL22 Address = {`AMS_TX_A, 4'h0}, `TX_CONTROL_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_63_56</td>
<td align=left>
&nbsp AMS reserved[63:56] amsbus ctrl_out&nbsp 63:56 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_sel_txmaster</td>
<td align=left>
&nbsp select TX lane as master, only one TX lane can be set to master. amsbus ctrl_out&nbsp 55:55 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_54</td>
<td align=left>
&nbsp AMS reserved [54] amsbus ctrl_out&nbsp 54:54 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_pdet_mode</td>
<td align=left>
&nbsp select update rate for phase detect (pdet) output. 0:Fwclk, 1:Fwclk/5 amsbus ctrl_out&nbsp 53:53 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_tx_spare_52_48</td>
<td align=left>
&nbsp AMS reserved[52:48] amsbus ctrl_out&nbsp 52:48 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_TX Registers">Return to AMS_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="AMS_TX_TX_STATUS">AMS_TX_TX_STATUS - AMS TX STATUS</a></b><br>
Address Offset = 32'h0000_d0d9<br>
Physical Address = 32'h0000_d0d9<br>
Verilog CL45 Address = {`AMS_TX_A, `TX_STATUS_Adr}<br>
Verilog CL22 Address = {`AMS_TX_A, 4'h0}, `TX_STATUS_A<br>
Reset Value = 16'h00a0<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_tx_lane_id</td>
<td align=left>
&nbsp TX Lane ID<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_tx_spare_13</td>
<td align=left>
&nbsp AMS tx_sts bit13 reserve<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_tx_drv_hv_disable</td>
<td align=left>
&nbsp Copy of of tx_drv_hv_disable. By default, assume high voltage driver (HVD) mode and 1.25V<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_tx_ana_rescal</td>
<td align=left>
&nbsp Copy of ana_rescal bus. Control code for global resistor calibration. See AMS for more details.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_tx_version_id</td>
<td align=left>
&nbsp AMS version ID. Used to track the core version.<br>
Reset value is 0xa0.</td></tr>
</table><p>
<A HREF="#AMS_TX Registers">Return to AMS_TX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="AMS_PLL_COM Registers">AMS_PLL_COM: common register block per PLL [2 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd110</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_0">AMS_PLL_COM_PLL_CONTROL_0</A></td><td>AMS PLL CONTROL_0</td></tr>
<tr>
<td align=center>0xd111</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_1">AMS_PLL_COM_PLL_CONTROL_1</A></td><td>AMS PLL CONTROL_1</td></tr>
<tr>
<td align=center>0xd112</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_2">AMS_PLL_COM_PLL_CONTROL_2</A></td><td>AMS PLL CONTROL_2</td></tr>
<tr>
<td align=center>0xd113</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_3">AMS_PLL_COM_PLL_CONTROL_3</A></td><td>AMS PLL CONTROL_3</td></tr>
<tr>
<td align=center>0xd114</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_4">AMS_PLL_COM_PLL_CONTROL_4</A></td><td>AMS PLL CONTROL_4</td></tr>
<tr>
<td align=center>0xd115</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_5">AMS_PLL_COM_PLL_CONTROL_5</A></td><td>AMS PLL CONTROL_5</td></tr>
<tr>
<td align=center>0xd116</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_6">AMS_PLL_COM_PLL_CONTROL_6</A></td><td>AMS PLL CONTROL_6</td></tr>
<tr>
<td align=center>0xd117</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_7">AMS_PLL_COM_PLL_CONTROL_7</A></td><td>AMS PLL CONTROL_7</td></tr>
<tr>
<td align=center>0xd118</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_8">AMS_PLL_COM_PLL_CONTROL_8</A></td><td>AMS PLL CONTROL_8</td></tr>
<tr>
<td align=center>0xd119</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_9">AMS_PLL_COM_PLL_CONTROL_9</A></td><td>AMS PLL CONTROL_9</td></tr>
<tr>
<td align=center>0xd11a</td><td><A HREF="#AMS_PLL_COM_PLL_CONTROL_10">AMS_PLL_COM_PLL_CONTROL_10</A></td><td>AMS PLL CONTROL_10</td></tr>
<tr>
<td align=center>0xd11b</td><td><A HREF="#AMS_PLL_COM_PLL_INTCTRL">AMS_PLL_COM_PLL_INTCTRL</A></td><td>INTERNAL PLL CONTROL</td></tr>
<tr>
<td align=center>0xd11c</td><td><A HREF="#AMS_PLL_COM_PLL_STATUS">AMS_PLL_COM_PLL_STATUS</A></td><td>AMS PLL STATUS</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_0">AMS_PLL_COM_PLL_CONTROL_0 - AMS PLL CONTROL_0</a></b><br>
Address Offset = 32'h0000_d110<br>
Physical Address = 32'h0000_d110<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_0_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_0_A<br>
Reset Value = 16'h0200<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rescal_aux</td>
<td align=left>
 over-ride ana_rescal[3:0] if force_rescal(pll_ctrl[79])=1 amsbus ctrl_out&nbsp 15:12DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_spare_11_11</td>
<td align=left>
&nbsp AMS reserved[11:11] amsbus ctrl_out&nbsp 11:11DFT_DFS=1'd0 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_lpf_rz</td>
<td align=left>
&nbsp adjust Rz in the loop filter, 00=0.71K, 01=1K, 10=1.7K, 11=5K amsbus ctrl_out&nbsp 10:9DFT_MUX <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fp3_rh</td>
<td align=left>
&nbsp adjust res in 3rd pole by 4x amsbus ctrl_out&nbsp 8:8DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fp3_ctrl</td>
<td align=left>
&nbsp adjusts caps in 3rd pole, typically used in frc-N mode, and with fp3_rh, higher code=lower pole freq amsbus ctrl_out&nbsp 7:4DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_cp_cmfdbk_iadj</td>
<td align=left>
&nbsp increases CP opamp current, 00:50uA, x1:CMF=100uA, 1x:UG=100uA amsbus ctrl_out&nbsp 3:2DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_set_clk4pcs</td>
<td align=left>
&nbsp program clk freq for clk4pcs. Combine with pll_ctrl[107] to form 3-bit control register. See AMS for details. amsbus ctrl_out&nbsp 1:0DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_1">AMS_PLL_COM_PLL_CONTROL_1 - AMS PLL CONTROL_1</a></b><br>
Address Offset = 32'h0000_d111<br>
Physical Address = 32'h0000_d111<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_1_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_1_A<br>
Reset Value = 16'h8001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_enable_ftune</td>
<td align=left>
&nbsp comparator for VCO tuning amsbus ctrl_out&nbsp 31:31DFT_MUX <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_reset</td>
<td align=left>
&nbsp PLL reset, active high amsbus ctrl_out&nbsp 30:30DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_ivco</td>
<td align=left>
&nbsp ivco[2:0], max, min, mode amsbus ctrl_out&nbsp 29:27DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_vco2_cssw</td>
<td align=left>
&nbsp test mode to disable current bias and convert current source to a switch. Could help with startup problems. amsbus ctrl_out&nbsp 26:26DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vcoictrl</td>
<td align=left>
&nbsp adjusts VCO bias current, ~6% steps. Only active if pll_ctrl[21]=0. amsbus ctrl_out&nbsp 25:24DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vco2_15g</td>
<td align=left>
&nbsp enable and select the 15-22.6G VCO amsbus ctrl_out&nbsp 23:23DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vco_autogm</td>
<td align=left>
&nbsp enables auto reduction of the VCO gm for lower jitter when pll_range > 128d amsbus ctrl_out&nbsp 22:22DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vco_res_cs</td>
<td align=left>
&nbsp test mode to enable a resistor only current bias for the main VCO, should reduce RJ, possibly worse PSRR amsbus ctrl_out&nbsp 21:21DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_spare_20_20</td>
<td align=left>
&nbsp AMS reserved[20] amsbus ctrl_out&nbsp 20:20DFT_DFS=1'd0 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_drv_hv_disable</td>
<td align=left>
&nbsp must be 0 if TVDD1P20=1.2V amsbus ctrl_out&nbsp 19:19DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_comp_thresh</td>
<td align=left>
&nbsp VCO tuning threshold (See AMS for details) amsbus ctrl_out&nbsp 18:16DFT_MUX <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_2">AMS_PLL_COM_PLL_CONTROL_2 - AMS PLL CONTROL_2</a></b><br>
Address Offset = 32'h0000_d112<br>
Physical Address = 32'h0000_d112<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_2_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_2_A<br>
Reset Value = 16'h000f<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_ick</td>
<td align=left>
&nbsp refclk input buffer amsbus ctrl_out&nbsp 47:47DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_ick</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 46:46DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_ick</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 45:45DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_icp</td>
<td align=left>
&nbsp charge pump amsbus ctrl_out&nbsp 44:44DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_icp</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 43:43DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_icp</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 42:42DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_ibias</td>
<td align=left>
&nbsp ibias all 6 above - master diode in biasgen amsbus ctrl_out&nbsp 41:41DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_ibias</td>
<td align=left>
&nbsp sign is reversed vs current sources amsbus ctrl_out&nbsp 40:40DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_ibias</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 39:39DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_refh_pll</td>
<td align=left>
&nbsp when pll_ctrl[75]=1, increase Ibias 10% amsbus ctrl_out&nbsp 38:38DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_refl_pll</td>
<td align=left>
&nbsp when pll_ctrl[75]=1, decrease Ibias 10% amsbus ctrl_out&nbsp 37:37DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vdd88_en</td>
<td align=left>
&nbsp keep bias current at 100uA if PVDD0P8=0.88V, typ amsbus ctrl_out&nbsp 36:36DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_iqp</td>
<td align=left>
&nbsp charge pump current, 50,100,150,..800uA amsbus ctrl_out&nbsp 35:32DFT_MUX <br>
Reset value is 0xf.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_3">AMS_PLL_COM_PLL_CONTROL_3 - AMS PLL CONTROL_3</a></b><br>
Address Offset = 32'h0000_d113<br>
Physical Address = 32'h0000_d113<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_3_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_rx</td>
<td align=left>
&nbsp send RX word ck to PLL test port amsbus ctrl_out&nbsp 63:63DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_pll</td>
<td align=left>
&nbsp output divided VCO clk both on - test LC amsbus ctrl_out&nbsp 62:62DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_vc</td>
<td align=left>
&nbsp test Vcontrol. See section 36 of AMS amsbus ctrl_out&nbsp 61:61DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_vref</td>
<td align=left>
&nbsp test vref amsbus ctrl_out&nbsp 60:60DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_iop</td>
<td align=left>
&nbsp test current amsbus ctrl_out&nbsp 59:59DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_iop</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 58:58DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_iop</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 57:57DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_icomp</td>
<td align=left>
&nbsp VCO comparator amsbus ctrl_out&nbsp 56:56DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_icomp</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 55:55DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_icomp</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 54:54DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_icmldiv</td>
<td align=left>
&nbsp VCO divider/buffer amsbus ctrl_out&nbsp 53:53DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_icmldiv</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 52:52DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_icmldiv</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 51:51DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imax_irxclkbuf</td>
<td align=left>
&nbsp rxclkbuf amsbus ctrl_out&nbsp 50:50DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imode_irxclkbuf</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 49:49DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_imin_irxclkbuf</td>
<td align=left>
&nbsp see AMS amsbus ctrl_out&nbsp 48:48DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_4">AMS_PLL_COM_PLL_CONTROL_4 - AMS PLL CONTROL_4</a></b><br>
Address Offset = 32'h0000_d114<br>
Physical Address = 32'h0000_d114<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_4_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_4_A<br>
Reset Value = 16'h0077<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_force_rescal</td>
<td align=left>
&nbsp force_rescal with pll_ctrl<15:12> amsbus ctrl_out&nbsp 79:79DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_force_kvh_bw</td>
<td align=left>
&nbsp enable force KVH,BW,test_vco2_cssw modes amsbus ctrl_out&nbsp 78:78DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_kvh_force</td>
<td align=left>
&nbsp force Kvco, override tuning control amsbus ctrl_out&nbsp 77:76DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vddr_bgb</td>
<td align=left>
&nbsp select between PVDD or BG, default, Vreference for the PLL bias currents amsbus ctrl_out&nbsp 75:75DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_vddr4bg</td>
<td align=left>
&nbsp test mode to force VddR bias to BG amsbus ctrl_out&nbsp 74:74DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_pll2rx_clkbw</td>
<td align=left>
&nbsp controls BW of PLL output buffers for the RX/TX clks. See AMS for details. amsbus ctrl_out&nbsp 73:72DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_bgr_ctatadj</td>
<td align=left>
&nbsp BG CTAT bias control amsbus ctrl_out&nbsp 71:68DFT_MUX <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_bgr_ptatadj</td>
<td align=left>
&nbsp BG bias, same decoder as CTAT amsbus ctrl_out&nbsp 67:64DFT_MUX <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_5">AMS_PLL_COM_PLL_CONTROL_5 - AMS PLL CONTROL_5</a></b><br>
Address Offset = 32'h0000_d115<br>
Physical Address = 32'h0000_d115<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_5_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_5_A<br>
Reset Value = 16'h2700<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_mix3p1c_calr_ptatadj</td>
<td align=left>
&nbsp bias control for Mix3P1C/calR amsbus ctrl_out&nbsp 95:91DFT_MUX <br>
Reset value is 0x4.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_mix3p1c_calr_ctatadj</td>
<td align=left>
&nbsp bias control for Mix3P1C/calR amsbus ctrl_out&nbsp 90:86DFT_MUX <br>
Reset value is 0x1c.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_pnp</td>
<td align=left>
&nbsp Measure internal BG nodes, NPN 00:off, 01:Vbe, 10:Vbe2, 11:Vbe_low. To fully enable this mode, pll_ctrl[83:82]=11 amsbus ctrl_out&nbsp 85:84DFT_MUX
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vbypass</td>
<td align=left>
&nbsp test, bypass test port opamp buffer amsbus ctrl_out&nbsp 83:83DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_bgint</td>
<td align=left>
&nbsp test enable and measure Vbg internal, ~0.4V, using BG res, and P/CTAT portions. Must not be enabled during functional operation amsbus ctrl_out&nbsp
82:82DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_bgip</td>
<td align=left>
&nbsp test, measure Ibg internal PMOS current, ~40uA, or 20uA each for P/CTAT amsbus ctrl_out&nbsp 81:81DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_max_test_port_amplitude</td>
<td align=left>
&nbsp 325 mVppse, with 50 ohm termination, default ~250 mVppse amsbus ctrl_out&nbsp 80:80DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_6">AMS_PLL_COM_PLL_CONTROL_6 - AMS PLL CONTROL_6</a></b><br>
Address Offset = 32'h0000_d116<br>
Physical Address = 32'h0000_d116<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_6_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_6_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_refclk_doubler</td>
<td align=left>
&nbsp test mode pending lab data, increases internal refclk freq by 2X and should be useful for frac-N mode to reduce the Q noise. amsbus ctrl_out&nbsp
111:111DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_doubler_res</td>
<td align=left>
&nbsp increases supported refclk freq by reducing delay with lower res. See AMS for details. amsbus ctrl_out&nbsp 110:108DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_set_clk4pcs_msb</td>
<td align=left>
&nbsp msb of set_clk4pcs control. See definition of control bits 1:0 amsbus ctrl_out&nbsp 107:107DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_doubler_cap</td>
<td align=left>
&nbsp increases supported refclk freq by reducing delay with lower cap amsbus ctrl_out&nbsp 106:104DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_clk4sync_en</td>
<td align=left>
&nbsp Enable control for clk4sync clock (0=disable, 1=enable) amsbus ctrl_out&nbsp 103:103 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_clk4sync_div</td>
<td align=left>
&nbsp Sets clk4sync output freq, 0=8T, 1=6T and T=1/VCO freq amsbus ctrl_out&nbsp 102:102DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rterm300</td>
<td align=left>
&nbsp set refclk termination impedance to 300 ohm differential amsbus ctrl_out&nbsp 101:101DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rtermhiz</td>
<td align=left>
&nbsp set refclk termination impedance to HiZ amsbus ctrl_out&nbsp 100:100DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rterm400</td>
<td align=left>
&nbsp set refclk termination impedance to 400 ohm differential amsbus ctrl_out&nbsp 99:99DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_div4</td>
<td align=left>
&nbsp input refclk divided 4 amsbus ctrl_out&nbsp 98:98 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_div2</td>
<td align=left>
&nbsp input refclk divided 2 amsbus ctrl_out&nbsp 97:97 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rterm200</td>
<td align=left>
&nbsp set refclk termination impedance to 200 ohm amsbus ctrl_out&nbsp 96:96DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_7">AMS_PLL_COM_PLL_CONTROL_7 - AMS PLL CONTROL_7</a></b><br>
Address Offset = 32'h0000_d117<br>
Physical Address = 32'h0000_d117<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_7_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_7_A<br>
Reset Value = 16'h2700<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_mix3p1cr_ptatadj</td>
<td align=left>
&nbsp PTAT bias control for Mix3P1C/R which is used in RX amsbus ctrl_out&nbsp 127:123DFT_MUX <br>
Reset value is 0x4.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_mix3p1cr_ctatadj</td>
<td align=left>
&nbsp CTAT bias control for Mix3P1C/R amsbus ctrl_out&nbsp 122:118DFT_MUX <br>
Reset value is 0x1c.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_vcodiv_refout</td>
<td align=left>
&nbsp enables VCO divided by integer value, eg 80, and sent to refoutp/n, TBD for now amsbus ctrl_out&nbsp 117:117DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_ndiv_frac_valid</td>
<td align=left>
&nbsp toggle high, then low to load in a new value for fracn_div[17:0]. This new mode should minimize any glitches when the fractional value is changed
dynamically amsbus ctrl_out&nbsp 116:116DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_pfd_ref_skew</td>
<td align=left>
&nbsp adds ~150ps of delay in refclk path amsbus ctrl_out&nbsp 115:115DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_pfd_fb_skew</td>
<td align=left>
&nbsp adds ~150ps of delay in fdbck path amsbus ctrl_out&nbsp 114:114DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_pfd_skew_enlarge</td>
<td align=left>
&nbsp increases above delays to ~300ps. All are optional settings for frac-N mode amsbus ctrl_out&nbsp 113:113DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_test_fracn_en</td>
<td align=left>
&nbsp test mode to power up fracn block when using the integer block and check for noise amsbus ctrl_out&nbsp 112:112DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_8">AMS_PLL_COM_PLL_CONTROL_8 - AMS PLL CONTROL_8</a></b><br>
Address Offset = 32'h0000_d118<br>
Physical Address = 32'h0000_d118<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_8_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_8_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fracn_div</td>
<td align=left>
&nbsp lower 16 bits fractional control of feedback divider. See AMS for details. amsbus ctrl_out&nbsp 143:128DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_9">AMS_PLL_COM_PLL_CONTROL_9 - AMS PLL CONTROL_9</a></b><br>
Address Offset = 32'h0000_d119<br>
Physical Address = 32'h0000_d119<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_9_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_9_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fracn_sel</td>
<td align=left>
&nbsp master enable and select for the frac-N mode, disables the orignal integer mode controlled by pll_mode amsbus ctrl_out&nbsp 159:159DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_ditheren</td>
<td align=left>
&nbsp enables dithering to reduce the refclk spur, and can be used during frac-N integer mode amsbus ctrl_out&nbsp 158:158DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fracn_ndiv_int</td>
<td align=left>
&nbsp fracn-N feedback divider integer control, See AMS for details amsbus ctrl_out&nbsp 157:148DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fracn_bypass</td>
<td align=left>
&nbsp test option to bypass the integer mode of the frac-N SDM block. See AMS for details amsbus ctrl_out&nbsp 147:147DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fracn_divrange</td>
<td align=left>
&nbsp selects MMD integer range for the value programmed by fracn_ndiv_int[9:0]. See AMS for details. amsbus ctrl_out&nbsp 146:146DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_fracn_div_17_16</td>
<td align=left>
&nbsp Upper 2 bits for fractional divider amsbus ctrl_out&nbsp 145:144DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_CONTROL_10">AMS_PLL_COM_PLL_CONTROL_10 - AMS PLL CONTROL_10</a></b><br>
Address Offset = 32'h0000_d11a<br>
Physical Address = 32'h0000_d11a<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_CONTROL_10_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_CONTROL_10_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_spare_175_174</td>
<td align=left>
&nbsp AMS reserved[175:174] amsbus ctrl_out&nbsp 175:174DFT_DFS=2'd0 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_tx_clkrptr_bw</td>
<td align=left>
&nbsp similar to pll_ctrl[73:72] amsbus ctrl_out&nbsp 173:172DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_tx_clkrptr_bias</td>
<td align=left>
&nbsp txclk_rptr,max,mode,min - bias currents for TX clock repeater buffers, 3P1C/calR amsbus ctrl_out&nbsp 171:169DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_tx_clk_rptr_pd</td>
<td align=left>
&nbsp disables clock repeater buffer to send TX IQ clocks from one quad to the other one amsbus ctrl_out&nbsp 168:168DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_spare_167_166</td>
<td align=left>
&nbsp AMS reserved[167:166] amsbus ctrl_out&nbsp 167:166DFT_DFS=2'd0 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rx_clkrptr_bw</td>
<td align=left>
&nbsp similar to pll_ctrl[73:72] amsbus ctrl_out&nbsp 165:164DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rx_clkrptr_bias</td>
<td align=left>
&nbsp rxclk_rptr,max,mode,min - bias currents for RX clock repeater buffers, 3P1C/calR amsbus ctrl_out&nbsp 163:161DFT_MUX <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rx_clk_rptr_pd</td>
<td align=left>
&nbsp disables clock repeater buffer to send RX IQ clocks from one quad to the other one amsbus ctrl_out&nbsp 160:160DFT_MUX <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_INTCTRL">AMS_PLL_COM_PLL_INTCTRL - INTERNAL PLL CONTROL</a></b><br>
Address Offset = 32'h0000_d11b<br>
Physical Address = 32'h0000_d11b<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_INTCTRL_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_INTCTRL_A<br>
Reset Value = 16'h0004<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_pwrdn</td>
<td align=left>
&nbsp when1, power down pll<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_div4_2_sel</td>
<td align=left>
&nbsp when 0, sel div4/2 input pin, when 1 sel pll AMS ctrl<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ams_pll_rterm_sel</td>
<td align=left>
&nbsp when 0, sel rterm input pins, when 1 sel pll AMS ctrl<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="AMS_PLL_COM_PLL_STATUS">AMS_PLL_COM_PLL_STATUS - AMS PLL STATUS</a></b><br>
Address Offset = 32'h0000_d11c<br>
Physical Address = 32'h0000_d11c<br>
Verilog CL45 Address = {`AMS_PLL_COM_A, `PLL_STATUS_Adr}<br>
Verilog CL22 Address = {`AMS_PLL_COM_A, 4'h0}, `PLL_STATUS_A<br>
Reset Value = 16'h0027<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_pll_kvh</td>
<td align=left>
&nbsp KVH[1:0]<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:06</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_pll_range</td>
<td align=left>
&nbsp VCO frequency range control (8 bits)<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_pll_low</td>
<td align=left>
&nbsp VCO tuning output, HIGH when VCO Vctrl is low or PLL frequency is too low<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ams_pll_mode</td>
<td align=left>
&nbsp pll_mode[4:0] bits<br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#AMS_PLL_COM Registers">Return to AMS_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<H1><a NAME="CORE_PLL_COM Registers">CORE_PLL_COM: common register block per PLL [2 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd180</td><td><A HREF="#CORE_PLL_COM_PMD_CORE_MODE_STATUS">CORE_PLL_COM_PMD_CORE_MODE_STATUS</A></td><td>PMD_CORE_MODE_STATUS</td></tr>
<tr>
<td align=center>0xd182</td><td><A HREF="#CORE_PLL_COM_RESET_CONTROL_PLL_DP">CORE_PLL_COM_RESET_CONTROL_PLL_DP</A></td><td>RESET_CONTROL_PLL_DP</td></tr>
<tr>
<td align=center>0xd184</td><td><A HREF="#CORE_PLL_COM_TOP_USER_CONTROL">CORE_PLL_COM_TOP_USER_CONTROL</A></td><td>TOP_USER_CONTROL</td></tr>
<tr>
<td align=center>0xd185</td><td><A HREF="#CORE_PLL_COM_UC_ACK_CORE_CONTROL">CORE_PLL_COM_UC_ACK_CORE_CONTROL</A></td><td>UC_ACK_CORE_CONTROL</td></tr>
<tr>
<td align=center>0xd188</td><td><A HREF="#CORE_PLL_COM_PLL_DP_RESET_STATE_STATUS">CORE_PLL_COM_PLL_DP_RESET_STATE_STATUS</A></td><td>PLL_DP_RESET_STATE_STATUS</td></tr>
<tr>
<td align=center>0xd189</td><td><A HREF="#CORE_PLL_COM_CORE_PLL_COM_STATUS_2">CORE_PLL_COM_CORE_PLL_COM_STATUS_2</A></td><td>CORE_PLL_COM_STATUS_2</td></tr>
<tr>
<td align=center>0xd18d</td><td><A HREF="#CORE_PLL_COM_PLL_CFG_FWAPI_DATA0">CORE_PLL_COM_PLL_CFG_FWAPI_DATA0</A></td><td>PLL_CFG_FWAPI_DATA0</td></tr>
<tr>
<td align=center>0xd18e</td><td><A HREF="#CORE_PLL_COM_PLL_CFG_FWAPI_DATA1">CORE_PLL_COM_PLL_CFG_FWAPI_DATA1</A></td><td>PLL_CFG_FWAPI_DATA1</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="CORE_PLL_COM_PMD_CORE_MODE_STATUS">CORE_PLL_COM_PMD_CORE_MODE_STATUS - PMD_CORE_MODE_STATUS</a></b><br>
Address Offset = 32'h0000_d180<br>
Physical Address = 32'h0000_d180<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `PMD_CORE_MODE_STATUS_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `PMD_CORE_MODE_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pmd_core_mode</td>
<td align=left>
 This indicates the status of the core input bus pmd_core_mode[15:0].&nbsp <br>
 This is driven from PCS and used for communication between PCS and PMD Micro code. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_RESET_CONTROL_PLL_DP">CORE_PLL_COM_RESET_CONTROL_PLL_DP - RESET_CONTROL_PLL_DP</a></b><br>
Address Offset = 32'h0000_d182<br>
Physical Address = 32'h0000_d182<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `RESET_CONTROL_PLL_DP_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `RESET_CONTROL_PLL_DP_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_s_pll_reset_frc</td>
<td align=left>
Active High PLL Reset force control. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_s_pll_reset_frc_val</td>
<td align=left>
Active High PLL Reset force value control. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_vcoclk4pcs_vld_frc_val</td>
<td align=left>
 pmd_vcoclk4pcs_vld pin force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_vcoclk4pcs_vld_frc</td>
<td align=left>
 pmd_vcoclk4pcs_vld pin force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vcoclk4pcs_s_comclk_frc_on</td>
<td align=left>
 Mux control for selection of comclk for pmd_vcoclk4pcs by force. <br>
 If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk4pcs clock. This is a debug bit and should be only used if vcoclk4pcs from AFE
is dead for unforeseen reasons.<br>
" It is recommended for user to force pmd_vcoclk4pcs_vld to 1'b0 while vcoclk4pcs_s_comclk_frc_on is asserted to 1'b1<br>
 by using pmd_vcoclk4pcs_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vcoclk4pcs_s_comclk_sel</td>
<td align=left>
 Mux control for selection of comclk for pmd_vcoclk4pcs clock. <br>
 If asserted by writing to 1'b1 will select the comclk for the pmd_vcoclk4pcs clock. <br>
" It is recommended for user to force pmd_vcoclk4pcs_vld to 1'b0 while vcoclk4pcs_s_comclk_sel is asserted to 1'b1<br>
 by using pmd_vcoclk4pcs_vld_frc/frc_val registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>refclk_s_comclk_frc_on</td>
<td align=left>
 Mux control for selection of comclk for refclk by force. <br>
 If asserted by writing to 1'b1 will select the comclk for the refclk clock. This is a debug bit and should be only used if refclk from AFE is unavailable
or dead for unforeseen reasons.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>refclk_s_comclk_sel</td>
<td align=left>
 Mux control for selection of comclk for the refclk clock used in RMIC and PLL_CAL register block.&nbsp <br>
 If asserted by writing to 1'b1 will select the comclk for the refclk clock. This register bit will enable the glitchless switching of the refclk to comclk
for the refclk used in RMIC and PLL_CAL register block. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>refclk_loc_mon_en</td>
<td align=left>
 1 - use the refclk_loc status to switch the refclk to comclk used in RMIC and PLL_CAL register block forecfully through the glitchless mux as refclk is
already lost. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_core_dp_h_rstb_pkill</td>
<td align=left>
1'b1 will disable the pmd_core_dp_h_rstb pin. <br>
 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_TOP_USER_CONTROL">CORE_PLL_COM_TOP_USER_CONTROL - TOP_USER_CONTROL</a></b><br>
Address Offset = 32'h0000_d184<br>
Physical Address = 32'h0000_d184<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `TOP_USER_CONTROL_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `TOP_USER_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>core_hw_fw_handshake_disable</td>
<td align=left>
1: disables the HW-FW handshake logic for the core which means there is no acknowledgement required from uC and core dp reset will be de-asserted once
core reset register/pin conditions are de-asserted. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_s_pll_pwrdn</td>
<td align=left>
Active High PLL Power Down control. <br>
Minimum assertion time is 50 comclk cycles. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>core_dp_s_rstb</td>
<td align=left>
Active Low Core Level Datapath Soft Reset. If asserted by writing <br>
to 1'b0 will reset datapath logic of all the lanes. This soft reset <br>
is equivalent to the hard reset input pin core_dp_h_rstb. <br>
Minimum assertion time is 50 comclk cycles. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_UC_ACK_CORE_CONTROL">CORE_PLL_COM_UC_ACK_CORE_CONTROL - UC_ACK_CORE_CONTROL</a></b><br>
Address Offset = 32'h0000_d185<br>
Physical Address = 32'h0000_d185<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `UC_ACK_CORE_CONTROL_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `UC_ACK_CORE_CONTROL_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_core_dp_reset</td>
<td align=left>
 uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured". <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>uc_ack_core_cfg_done</td>
<td align=left>
 uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 will&nbsp <br>
 should release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_PLL_DP_RESET_STATE_STATUS">CORE_PLL_COM_PLL_DP_RESET_STATE_STATUS - PLL_DP_RESET_STATE_STATUS</a></b><br>
Address Offset = 32'h0000_d188<br>
Physical Address = 32'h0000_d188<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `PLL_DP_RESET_STATE_STATUS_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `PLL_DP_RESET_STATE_STATUS_A<br>
Reset Value = 16'h0007<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>core_dp_reset_state</td>
<td align=left>
 Bit 2: core_dp_reset_active&nbsp&nbsp : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.&nbsp <br>
 Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.&nbsp
<br>
 Bit 0: core_dp_reset_held&nbsp &nbsp&nbsp : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001
and uc_ack_core_cfg_done == 1. <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_CORE_PLL_COM_STATUS_2">CORE_PLL_COM_CORE_PLL_COM_STATUS_2 - CORE_PLL_COM_STATUS_2</a></b><br>
Address Offset = 32'h0000_d189<br>
Physical Address = 32'h0000_d189<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `CORE_PLL_COM_STATUS_2_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `CORE_PLL_COM_STATUS_2_A<br>
Reset Value = 16'h0001<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>refclk_loc</td>
<td align=left>
Indicates the Loss of Clock indication for refclk. Loss of refclk monitor uses the comclk as the measuring clock so for this monitoring status to work
properly comclk has to be there.&nbsp <br>
If ratio of the (comclk freq/refclk freq) <= 4 then LOC monitor should not report it as LOC but any slower refclk than that will result into LOC even though
refclk is toggling. So assuming mac comclk is 175 Mhz, <br>
then slowest refclk which will not result into LOC is 175/4 = 43.75 Mhz. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_pwrdn_or</td>
<td align=left>
pll_pwrdn after dft muxing<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_PLL_CFG_FWAPI_DATA0">CORE_PLL_COM_PLL_CFG_FWAPI_DATA0 - PLL_CFG_FWAPI_DATA0</a></b><br>
Address Offset = 32'h0000_d18d<br>
Physical Address = 32'h0000_d18d<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `PLL_CFG_FWAPI_DATA0_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `PLL_CFG_FWAPI_DATA0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_cfg_fwapi_data0</td>
<td align=left>
PLL configuration firmware/API data 0<br>
This is a scratch register used by the firmware and API code to store and/or exchange <br>
PLL configuration information<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="CORE_PLL_COM_PLL_CFG_FWAPI_DATA1">CORE_PLL_COM_PLL_CFG_FWAPI_DATA1 - PLL_CFG_FWAPI_DATA1</a></b><br>
Address Offset = 32'h0000_d18e<br>
Physical Address = 32'h0000_d18e<br>
Verilog CL45 Address = {`CORE_PLL_COM_A, `PLL_CFG_FWAPI_DATA1_Adr}<br>
Verilog CL22 Address = {`CORE_PLL_COM_A, 4'h0}, `PLL_CFG_FWAPI_DATA1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_cfg_fwapi_data1</td>
<td align=left>
PLL configuration firmware/API data 1<br>
This is a scratch register used by the firmware and API code to store and/or exchange <br>
PLL configuration information<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#CORE_PLL_COM Registers">Return to CORE_PLL_COM: common register block per PLL [2 copies] Table</A><p>
<H1><a NAME="DIG_COM Registers">DIG_COM: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd100</td><td><A HREF="#DIG_COM_REVID0">DIG_COM_REVID0</A></td><td>REVID0</td></tr>
<tr>
<td align=center>0xd101</td><td><A HREF="#DIG_COM_RESET_CONTROL_PMD">DIG_COM_RESET_CONTROL_PMD</A></td><td>RESET_CONTROL_PMD</td></tr>
<tr>
<td align=center>0xd102</td><td><A HREF="#DIG_COM_RESET_CONTROL_CORE_DP">DIG_COM_RESET_CONTROL_CORE_DP</A></td><td>RESET_CONTROL_CORE_DP</td></tr>
<tr>
<td align=center>0xd103</td><td><A HREF="#DIG_COM_MASKDATA_REG">DIG_COM_MASKDATA_REG</A></td><td>MASKDATA_REG</td></tr>
<tr>
<td align=center>0xd104</td><td><A HREF="#DIG_COM_TOP_USER_CONTROL_0">DIG_COM_TOP_USER_CONTROL_0</A></td><td>TOP_USER_CONTROL_0</td></tr>
<tr>
<td align=center>0xd106</td><td><A HREF="#DIG_COM_CORE_REG_RESET_OCCURRED_CONTROL">DIG_COM_CORE_REG_RESET_OCCURRED_CONTROL</A></td><td>CORE_REG_RESET_OCCURRED_CONTROL</td></tr>
<tr>
<td align=center>0xd107</td><td><A HREF="#DIG_COM_RST_SEQ_TIMER_CONTROL">DIG_COM_RST_SEQ_TIMER_CONTROL</A></td><td>RST_SEQ_TIMER_CONTROL</td></tr>
<tr>
<td align=center>0xd108</td><td><A HREF="#DIG_COM_CORE_DP_RESET_STATE_STATUS">DIG_COM_CORE_DP_RESET_STATE_STATUS</A></td><td>CORE_DP_RESET_STATE_STATUS</td></tr>
<tr>
<td align=center>0xd10a</td><td><A HREF="#DIG_COM_REVID1">DIG_COM_REVID1</A></td><td>REVID1</td></tr>
<tr>
<td align=center>0xd10e</td><td><A HREF="#DIG_COM_REVID2">DIG_COM_REVID2</A></td><td>REVID2</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DIG_COM_REVID0">DIG_COM_REVID0 - REVID0</a></b><br>
Address Offset = 32'h0000_d100<br>
Physical Address = 32'h0000_d100<br>
Verilog CL45 Address = {`DIG_COM_A, `REVID0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `REVID0_A<br>
Reset Value = 16'h0366<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>revid_rev_letter</td>
<td align=left>
All layer revision letter <br>
0 = revA <br>
1 = revB <br>
2 = revC <br>
3 = revD <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:11</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>revid_rev_number</td>
<td align=left>
Metal mask revision number<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:09</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>revid_bonding</td>
<td align=left>
bonding <br>
0 = wire bond <br>
1 = flip chip <br>
2-3 = reserved<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:06</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>revid_process</td>
<td align=left>
technology process <br>
0 = 90nm <br>
1 = 65nm <br>
2 = 40nm <br>
3 = 28nm <br>
4 = 20nm <br>
5 = 16nm <br>
6-7 = reserved <br>
Reset value is 5.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>revid_model</td>
<td align=left>
model number<br>
Reset value is 0x26.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_RESET_CONTROL_PMD">DIG_COM_RESET_CONTROL_PMD - RESET_CONTROL_PMD</a></b><br>
Address Offset = 32'h0000_d101<br>
Physical Address = 32'h0000_d101<br>
Verilog CL45 Address = {`DIG_COM_A, `RESET_CONTROL_PMD_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `RESET_CONTROL_PMD_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>uc_active</td>
<td align=left>
 When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath reset<br>
 When set to 1'b0 then Hardware can internally assume that uc_ack_* = 1. <br>
 This regiter bit can only be reset by assertion of the hard reset input pin pmd_por_h_rstb. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>core_s_rstb</td>
<td align=left>
Active Low Core Level Soft Reset. If asserted by writing to 1'b0 will reset the whole core. <br>
This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb. This regiter bit can only be <br>
reset by assertion of the hard reset input pin pmd_por_h_rstb<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_RESET_CONTROL_CORE_DP">DIG_COM_RESET_CONTROL_CORE_DP - RESET_CONTROL_CORE_DP</a></b><br>
Address Offset = 32'h0000_d102<br>
Physical Address = 32'h0000_d102<br>
Verilog CL45 Address = {`DIG_COM_A, `RESET_CONTROL_CORE_DP_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `RESET_CONTROL_CORE_DP_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>disable_ack_timeout</td>
<td align=left>
Setting this bit to 1 disables the ack timeout for all ports. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_mdio_trans_pkill</td>
<td align=left>
1'b1 will disable the pmd_mdio_trans pin. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sup_rst_seq_frc</td>
<td align=left>
Suppress reset sequence force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sup_rst_seq_frc_val</td>
<td align=left>
Suppress reset sequence force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_MASKDATA_REG">DIG_COM_MASKDATA_REG - MASKDATA_REG</a></b><br>
Address Offset = 32'h0000_d103<br>
Physical Address = 32'h0000_d103<br>
Verilog CL45 Address = {`DIG_COM_A, `MASKDATA_REG_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `MASKDATA_REG_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>maskdata</td>
<td align=left>
maskdata for writes that can be used with PMI_LP or PMI_MDIO port. This register will get reset to 0 after each transaction. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_TOP_USER_CONTROL_0">DIG_COM_TOP_USER_CONTROL_0 - TOP_USER_CONTROL_0</a></b><br>
Address Offset = 32'h0000_d104<br>
Physical Address = 32'h0000_d104<br>
Verilog CL45 Address = {`DIG_COM_A, `TOP_USER_CONTROL_0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `TOP_USER_CONTROL_0_A<br>
Reset Value = 16'h0271<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_fast_mode_frc</td>
<td align=left>
Setting this bit will allow the register value to be used for mdio_fast_mode. <br>
Otherwise the pin mdio_fast_mode will be used. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_fast_mode_frc_val</td>
<td align=left>
 This value will be used to drive the internal mdio_fast_mode signal when mdio_fast_mode_frc is set to 1. <br>
 0: Normal mdio frame operation with preamble <br>
 1: Fast mdio frame operation without preamble <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>maskdata_bus_assign</td>
<td align=left>
This register is used to assign the maskdata bus to either the mdio or pmi_lp port . <br>
 0: maskdata register is assigned to MDIO port&nbsp <br>
 1: maskdata register is assigned to PMI_LP port&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>heartbeat_count_1us</td>
<td align=left>
 Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk
frequency in Mhz. <br>
 For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any
other comclk frequency.&nbsp <br>
Reset value is 0x271.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_CORE_REG_RESET_OCCURRED_CONTROL">DIG_COM_CORE_REG_RESET_OCCURRED_CONTROL - CORE_REG_RESET_OCCURRED_CONTROL</a></b><br>
Address Offset = 32'h0000_d106<br>
Physical Address = 32'h0000_d106<br>
Verilog CL45 Address = {`DIG_COM_A, `CORE_REG_RESET_OCCURRED_CONTROL_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `CORE_REG_RESET_OCCURRED_CONTROL_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>core_reg_reset_occurred</td>
<td align=left>
 Set to 1'b1 upon core level register reset and remains so until cleared by register write from uC. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_RST_SEQ_TIMER_CONTROL">DIG_COM_RST_SEQ_TIMER_CONTROL - RST_SEQ_TIMER_CONTROL</a></b><br>
Address Offset = 32'h0000_d107<br>
Physical Address = 32'h0000_d107<br>
Verilog CL45 Address = {`DIG_COM_A, `RST_SEQ_TIMER_CONTROL_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `RST_SEQ_TIMER_CONTROL_A<br>
Reset Value = 16'h8304<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rst_seq_dis_flt_mode</td>
<td align=left>
 Defines the filter mode for rst_seq_dis/pmd_mdio_trans pin.&nbsp&nbsp <br>
&nbsp 2'd0 - filter is bypassed where input is passed to output untouched. <br>
&nbsp 2'd1 - filter output is 16 comclk cycles if input is > 16 comclk cycles else output is same as input signal.&nbsp <br>
&nbsp 2'd2 - filter output is 20 comclk cycles if input is > 20 comclk cycles else output is same as input signal.&nbsp <br>
&nbsp 2'd3 - filter output is 24 comclk cycles if input is > 24 comclk cycles else output is same as input signal.&nbsp <br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pwrdn_seq_timer</td>
<td align=left>
 Defines the number of comclk cycles between de-assertion of AFE RX/TX lane pwrdn and clock muxing from comclk to lane clock.&nbsp <br>
 Valid value range is from 0 to 7 which will provide from 8 to 64 clock cycles between de-assertion of AFE RX/TX lane pwrdn <br>
 and clock muxing from comclk to lane clock. Wait_time = 8 * (pwrdn_seq_timer + 1). <br>
Reset value is 0x3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rst_seq_timer</td>
<td align=left>
 Defines the number of comclk cycles between de-assertion of AFE RX/TX lane reset and clock muxing from comclk to lane clock.&nbsp <br>
 Valid value range is from 0 to 7 which will provide from 2 to 16 clock cycles between de-assertion of AFE RX/TX lane reset <br>
 and clock muxing from comclk to lane clock. Wait_time = 2 * (rst_seq_timer + 1). <br>
Reset value is 0x4.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_CORE_DP_RESET_STATE_STATUS">DIG_COM_CORE_DP_RESET_STATE_STATUS - CORE_DP_RESET_STATE_STATUS</a></b><br>
Address Offset = 32'h0000_d108<br>
Physical Address = 32'h0000_d108<br>
Verilog CL45 Address = {`DIG_COM_A, `CORE_DP_RESET_STATE_STATUS_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `CORE_DP_RESET_STATE_STATUS_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_lane_reset_released</td>
<td align=left>
 indicates if a lane is currently at {tx_lane_dp_reset_active, tx_lane_dp_reset_occurred} = 01. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>lane_reset_released</td>
<td align=left>
 indicates if a lane is currently at {rx_lane_dp_reset_active, rx_lane_dp_reset_occurred} = 01. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>lane_reset_released_index</td>
<td align=left>
 Index of the lane number of the first RX lane in lane_reset_released state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_lane_reset_released_index</td>
<td align=left>
 Index of the lane number of the first TX lane in lane_reset_released state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_REVID1">DIG_COM_REVID1 - REVID1</a></b><br>
Address Offset = 32'h0000_d10a<br>
Physical Address = 32'h0000_d10a<br>
Verilog CL45 Address = {`DIG_COM_A, `REVID1_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `REVID1_A<br>
Reset Value = 16'h803c<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_multiplicity</td>
<td align=left>
Number of lanes <br>
Reset value is 8.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:06</td>
<td align=left valign=top style="color: red">RSVD</td>
<td align=left valign=top style="color: red">Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_mdio</td>
<td align=left>
MDIO interface present in core<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_micro</td>
<td align=left>
Microcontroller present in core<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_cl72</td>
<td align=left>
Clause 72 present in core<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_pir</td>
<td align=left>
PCS interface retiming flops present in core<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_llp</td>
<td align=left>
Ultra low latency path present in core<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top style="color: red">RO</td>
<td align=left valign=top style="color: red">revid_eee</td>
<td align=left>
EEE support present in core<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_REVID2">DIG_COM_REVID2 - REVID2</a></b><br>
Address Offset = 32'h0000_d10e<br>
Physical Address = 32'h0000_d10e<br>
Verilog CL45 Address = {`DIG_COM_A, `REVID2_Adr}<br>
Verilog CL22 Address = {`DIG_COM_A, 4'h0}, `REVID2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>revid2</td>
<td align=left>
Revision ID2 code<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DIG_COM Registers">Return to DIG_COM: common register block for all lanes Table</A><p>
<H1><a NAME="DIG_COM_B Registers">DIG_COM_B: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd190</td><td><A HREF="#DIG_COM_B_LANE_ADDR_0">DIG_COM_B_LANE_ADDR_0</A></td><td>LANE_ADDR_0</td></tr>
<tr>
<td align=center>0xd191</td><td><A HREF="#DIG_COM_B_LANE_ADDR_1">DIG_COM_B_LANE_ADDR_1</A></td><td>LANE_ADDR_1</td></tr>
<tr>
<td align=center>0xd192</td><td><A HREF="#DIG_COM_B_LANE_ADDR_2">DIG_COM_B_LANE_ADDR_2</A></td><td>LANE_ADDR_2</td></tr>
<tr>
<td align=center>0xd193</td><td><A HREF="#DIG_COM_B_LANE_ADDR_3">DIG_COM_B_LANE_ADDR_3</A></td><td>LANE_ADDR_3</td></tr>
<tr>
<td align=center>0xd194</td><td><A HREF="#DIG_COM_B_LANE_ADDR_4">DIG_COM_B_LANE_ADDR_4</A></td><td>LANE_ADDR_4</td></tr>
<tr>
<td align=center>0xd195</td><td><A HREF="#DIG_COM_B_LANE_ADDR_5">DIG_COM_B_LANE_ADDR_5</A></td><td>LANE_ADDR_5</td></tr>
<tr>
<td align=center>0xd196</td><td><A HREF="#DIG_COM_B_LANE_ADDR_6">DIG_COM_B_LANE_ADDR_6</A></td><td>LANE_ADDR_6</td></tr>
<tr>
<td align=center>0xd197</td><td><A HREF="#DIG_COM_B_LANE_ADDR_7">DIG_COM_B_LANE_ADDR_7</A></td><td>LANE_ADDR_7</td></tr>
<tr>
<td align=center>0xd19b</td><td><A HREF="#DIG_COM_B_DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0">DIG_COM_B_DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0</A></td><td>DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0</td></tr>
<tr>
<td align=center>0xd19c</td><td><A HREF="#DIG_COM_B_DIG_COM_B_STATUS_CLK4SYNC_DIV2_0">DIG_COM_B_DIG_COM_B_STATUS_CLK4SYNC_DIV2_0</A></td><td>DIG_COM_B_STATUS_CLK4SYNC_DIV2_0</td></tr>
<tr>
<td align=center>0xd19d</td><td><A HREF="#DIG_COM_B_DIG_COM_B_CONTROL_MICRO_CLK_0">DIG_COM_B_DIG_COM_B_CONTROL_MICRO_CLK_0</A></td><td>DIG_COM_B_CONTROL_MICRO_CLK_0</td></tr>
<tr>
<td align=center>0xd19e</td><td><A HREF="#DIG_COM_B_DIG_COM_B_STATUS_MICRO_CLK_0">DIG_COM_B_DIG_COM_B_STATUS_MICRO_CLK_0</A></td><td>DIG_COM_B_STATUS_MICRO_CLK_0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_0">DIG_COM_B_LANE_ADDR_0 - LANE_ADDR_0</a></b><br>
Address Offset = 32'h0000_d190<br>
Physical Address = 32'h0000_d190<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_0</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_0" at the PCS interface. <br>
tx_lane_addr_0 is the logical address of the TX lane with pins at the PCS interface labeled "_0". <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_0</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_0" at the PCS interface. <br>
rx_lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0". <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_1">DIG_COM_B_LANE_ADDR_1 - LANE_ADDR_1</a></b><br>
Address Offset = 32'h0000_d191<br>
Physical Address = 32'h0000_d191<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_1_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_1_A<br>
Reset Value = 16'h0101<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_1</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_1" at the PCS interface. <br>
tx_lane_addr_1 is the logical address of the TX lane with pins at the PCS interface labeled "_1". <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_1</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_1" at the PCS interface. <br>
rx_lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1". <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_2">DIG_COM_B_LANE_ADDR_2 - LANE_ADDR_2</a></b><br>
Address Offset = 32'h0000_d192<br>
Physical Address = 32'h0000_d192<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_2_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_2_A<br>
Reset Value = 16'h0202<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_2</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_2" at the PCS interface. <br>
tx_lane_addr_2 is the logical address of the TX lane with pins at the PCS interface labeled "_2". <br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_2</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_2" at the PCS interface. <br>
rx_lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2". <br>
Reset value is 0x2.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_3">DIG_COM_B_LANE_ADDR_3 - LANE_ADDR_3</a></b><br>
Address Offset = 32'h0000_d193<br>
Physical Address = 32'h0000_d193<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_3_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_3_A<br>
Reset Value = 16'h0303<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_3</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_3" at the PCS interface. <br>
tx_lane_addr_3 is the logical address of the TX lane with pins at the PCS interface labeled "_3". <br>
Reset value is 0x3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_3</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_3" at the PCS interface. <br>
rx_lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3". <br>
Reset value is 0x3.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_4">DIG_COM_B_LANE_ADDR_4 - LANE_ADDR_4</a></b><br>
Address Offset = 32'h0000_d194<br>
Physical Address = 32'h0000_d194<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_4_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_4_A<br>
Reset Value = 16'h0404<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_4</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_4" at the PCS interface. <br>
tx_lane_addr_4 is the logical address of the TX lane with pins at the PCS interface labeled "_4". <br>
Reset value is 0x4.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_4</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_4" at the PCS interface. <br>
rx_lane_addr_4 is the logical address of the lane with pins at the PCS interface labeled "_4". <br>
Reset value is 0x4.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_5">DIG_COM_B_LANE_ADDR_5 - LANE_ADDR_5</a></b><br>
Address Offset = 32'h0000_d195<br>
Physical Address = 32'h0000_d195<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_5_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_5_A<br>
Reset Value = 16'h0505<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_5</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_5" at the PCS interface. <br>
tx_lane_addr_5 is the logical address of the TX lane with pins at the PCS interface labeled "_5". <br>
Reset value is 0x5.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_5</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_5" at the PCS interface. <br>
rx_lane_addr_5 is the logical address of the lane with pins at the PCS interface labeled "_5". <br>
Reset value is 0x5.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_6">DIG_COM_B_LANE_ADDR_6 - LANE_ADDR_6</a></b><br>
Address Offset = 32'h0000_d196<br>
Physical Address = 32'h0000_d196<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_6_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_6_A<br>
Reset Value = 16'h0606<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_6</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_6" at the PCS interface. <br>
tx_lane_addr_6 is the logical address of the TX lane with pins at the PCS interface labeled "_6". <br>
Reset value is 0x6.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_6</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_6" at the PCS interface. <br>
rx_lane_addr_6 is the logical address of the lane with pins at the PCS interface labeled "_6". <br>
Reset value is 0x6.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_LANE_ADDR_7">DIG_COM_B_LANE_ADDR_7 - LANE_ADDR_7</a></b><br>
Address Offset = 32'h0000_d197<br>
Physical Address = 32'h0000_d197<br>
Verilog CL45 Address = {`DIG_COM_B_A, `LANE_ADDR_7_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `LANE_ADDR_7_A<br>
Reset Value = 16'h0707<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_lane_addr_7</td>
<td align=left>
Determines the logical address associated with the PMD TX lane with physical index&nbsp "_7" at the PCS interface. <br>
tx_lane_addr_7 is the logical address of the TX lane with pins at the PCS interface labeled "_7". <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_lane_addr_7</td>
<td align=left>
Determines the logical address associated with the PMD RX lane with physical index&nbsp "_7" at the PCS interface. <br>
rx_lane_addr_7 is the logical address of the lane with pins at the PCS interface labeled "_7". <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0">DIG_COM_B_DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0 - DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0</a></b><br>
Address Offset = 32'h0000_d19b<br>
Physical Address = 32'h0000_d19b<br>
Verilog CL45 Address = {`DIG_COM_B_A, `DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `DIG_COM_B_CONTROL_CLK4SYNC_DIV2_0_A<br>
Reset Value = 16'h0040<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>clk4sync_div2_s_comclk_frc_on</td>
<td align=left>
 Mux control for selection of comclk for clk4sync_div2 by force. <br>
 If asserted by writing to 1'b1 will select the comclk for the clk4sync_div2 clock. This is a debug bit and should be only used if clk4sync_div2 from AFE
is unavailable or dead for unforeseen reasons.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>clk4sync_div2_s_comclk_sel</td>
<td align=left>
 Mux control for selection of comclk for the clk4sync_div2 clock .&nbsp <br>
 If asserted by writing to 1'b1 will select the comclk for the clk4sync_div2 clock. This register bit will enable the glitchless switching of the clk4sync_div2
to comclk for the clk4sync_div2 . <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>clk4sync_div2_loc_mon_en</td>
<td align=left>
 1 - use the clk4sync_div2_loc status to switch the clk4sync_div2 to comclk forcefully through the glitchless mux as clk4sync_div2 is already lost. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>clk4sync_div2_vco_select</td>
<td align=left>
 0 - Select PLL0 clk4sync (i.e. VCO/8) clock from the AFE to generate clk4sync_div2 clock. <br>
 1 - Select PLL1 clk4sync (i.e. VCO/8) clock from the AFE to generate clk4sync_div2 clock. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>clk4sync_div2_en</td>
<td align=left>
&nbsp Controls VCO/8 clock divider setting to generate the divided clk4sync_div2. <br>
&nbsp&nbsp 1'b0 -> clk4sync_div2 = OFF. VCO divider is power gated and reset to save power. <br>
 <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_DIG_COM_B_STATUS_CLK4SYNC_DIV2_0">DIG_COM_B_DIG_COM_B_STATUS_CLK4SYNC_DIV2_0 - DIG_COM_B_STATUS_CLK4SYNC_DIV2_0</a></b><br>
Address Offset = 32'h0000_d19c<br>
Physical Address = 32'h0000_d19c<br>
Verilog CL45 Address = {`DIG_COM_B_A, `DIG_COM_B_STATUS_CLK4SYNC_DIV2_0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `DIG_COM_B_STATUS_CLK4SYNC_DIV2_0_A<br>
Reset Value = 16'h0001<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>clk4sync_div2_loc</td>
<td align=left>
Indicates the Loss of Clock indication for VCO derived clk4sync_div2 before glicthless muxing with comclk. Loss of clk4sync_div2 monitor uses the comclk
as the measuring clock so for this monitoring status to work properly comclk has to be there.&nbsp <br>
If ratio of the (comclk freq/clk4sync_div2 freq) <= 4 then LOC monitor should not report it as LOC but any slower clk4sync_div2 than that will result into
LOC even though clk4sync_div2 is toggling. So assuming max comclk is 175 Mhz, <br>
then slowest clk4sync_div2 which will not result into LOC is 175/4 = 43.75 Mhz. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>clk4sync_div2_comclk_sel</td>
<td align=left>
Indicates status of the clk4sync_div2 glitchless mux select value. 0 - indicates that VCO derived clock is selected and 1 - indicates that comclk is selected.<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_DIG_COM_B_CONTROL_MICRO_CLK_0">DIG_COM_B_DIG_COM_B_CONTROL_MICRO_CLK_0 - DIG_COM_B_CONTROL_MICRO_CLK_0</a></b><br>
Address Offset = 32'h0000_d19d<br>
Physical Address = 32'h0000_d19d<br>
Verilog CL45 Address = {`DIG_COM_B_A, `DIG_COM_B_CONTROL_MICRO_CLK_0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `DIG_COM_B_CONTROL_MICRO_CLK_0_A<br>
Reset Value = 16'h0047<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_clk_s_comclk_frc_on</td>
<td align=left>
 Mux control for selection of comclk for micro_clk by force. <br>
 If asserted by writing to 1'b1 will select the comclk for the micro_clk clock. This is a debug bit and should be only used if micro_clk from AFE is unavailable
or dead for unforeseen reasons.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_clk_s_comclk_sel</td>
<td align=left>
 Mux control for selection of comclk for the micro_clk clock used in micro subsystem block.&nbsp <br>
 If asserted by writing to 1'b1 will select the comclk for the micro_clk clock. This register bit will enable the glitchless switching of the micro_clk
to comclk for the micro_clk used in micro subsystem block. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_clk_loc_mon_en</td>
<td align=left>
 1 - use the micro_clk_loc status to switch the micro_clk to comclk used in micro subsystem block forcefully through the glitchless mux as micro_clk is
already lost. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_clk_vco_select</td>
<td align=left>
 0 - Select PLL0 VCO/8 clock from the AFE to generate micro clock. <br>
 1 - Select PLL1 VCO/8 clock from the AFE to generate micro clock. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_clk_vco_div</td>
<td align=left>
&nbsp Controls VCO/8 clock divider setting to generate the divided micro_clk. <br>
&nbsp&nbsp 3'd0 -> micro_clk = VCO/48. <br>
&nbsp&nbsp 3'd1 -> micro_clk = VCO/56. <br>
&nbsp&nbsp 3'd2 -> micro_clk = VCO/64. <br>
&nbsp&nbsp 3'd3 -> micro_clk = VCO/72. <br>
&nbsp&nbsp 3'd4 -> micro_clk = VCO/80. <br>
&nbsp&nbsp 3'd5 -> micro_clk = VCO/88. <br>
&nbsp&nbsp 3'd6 -> micro_clk = VCO/96. <br>
&nbsp&nbsp 3'd7 -> micro_clk = OFF. VCO divider is power gated and reset to save power. <br>
 <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<b><a NAME="DIG_COM_B_DIG_COM_B_STATUS_MICRO_CLK_0">DIG_COM_B_DIG_COM_B_STATUS_MICRO_CLK_0 - DIG_COM_B_STATUS_MICRO_CLK_0</a></b><br>
Address Offset = 32'h0000_d19e<br>
Physical Address = 32'h0000_d19e<br>
Verilog CL45 Address = {`DIG_COM_B_A, `DIG_COM_B_STATUS_MICRO_CLK_0_Adr}<br>
Verilog CL22 Address = {`DIG_COM_B_A, 4'h0}, `DIG_COM_B_STATUS_MICRO_CLK_0_A<br>
Reset Value = 16'h0001<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_clk_loc</td>
<td align=left>
Indicates the Loss of Clock indication for VCO derived micro_clk before glicthless muxing with comclk. Loss of micro_clk monitor uses the comclk as the
measuring clock so for this monitoring status to work properly comclk has to be there.&nbsp <br>
If ratio of the (comclk freq/micro_clk freq) <= 4 then LOC monitor should not report it as LOC but any slower micro_clk than that will result into LOC
even though micro_clk is toggling. So assuming max comclk is 175 Mhz, <br>
then slowest micro_clk which will not result into LOC is 175/4 = 43.75 Mhz. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_clk_comclk_sel</td>
<td align=left>
Indicates status of the micro_clk glitchless mux select value. 0 - indicates that VCO derived clock is selected and 1 - indicates that comclk is selected.<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#DIG_COM_B Registers">Return to DIG_COM_B: common register block for all lanes Table</A><p>
<H1><a NAME="LINKTRN_USER_RX Registers">LINKTRN_USER_RX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd080</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_control0_register">LINKTRN_USER_RX_linktrnur_control0_register</A></td><td>Control 0 Register</td></tr>
<tr>
<td align=center>0xd081</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_control1_register">LINKTRN_USER_RX_linktrnur_control1_register</A></td><td>Control 1 Register</td></tr>
<tr>
<td align=center>0xd082</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_control2_register">LINKTRN_USER_RX_linktrnur_control2_register</A></td><td>Control 2 Register</td></tr>
<tr>
<td align=center>0xd083</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_status0_register">LINKTRN_USER_RX_linktrnur_status0_register</A></td><td>Status 0 Register</td></tr>
<tr>
<td align=center>0xd084</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_micro_interrupt_control0_register">LINKTRN_USER_RX_linktrnur_micro_interrupt_control0_register</A></td><td>Micro Interrupt Control 0 Register</td></tr>
<tr>
<td align=center>0xd085</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_micro_status0_register">LINKTRN_USER_RX_linktrnur_micro_status0_register</A></td><td>Micro Status 0 Register</td></tr>
<tr>
<td align=center>0xd086</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_micro_status1_register">LINKTRN_USER_RX_linktrnur_micro_status1_register</A></td><td>Micro Status 1 Register</td></tr>
<tr>
<td align=center>0xd087</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_control3_register">LINKTRN_USER_RX_linktrnur_control3_register</A></td><td>Control 3 Register</td></tr>
<tr>
<td align=center>0xd088</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_control4_register">LINKTRN_USER_RX_linktrnur_control4_register</A></td><td>Control 4 Register</td></tr>
<tr>
<td align=center>0xd089</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_status1_register">LINKTRN_USER_RX_linktrnur_status1_register</A></td><td>Status 1 Register</td></tr>
<tr>
<td align=center>0xd08a</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_control5_register">LINKTRN_USER_RX_linktrnur_control5_register</A></td><td>Control 5 Register</td></tr>
<tr>
<td align=center>0xd08d</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_micro_interrupt_control1_register">LINKTRN_USER_RX_linktrnur_micro_interrupt_control1_register</A></td><td>Micro Interrupt Control 1 Register</td></tr>
<tr>
<td align=center>0xd08e</td><td><A HREF="#LINKTRN_USER_RX_linktrnur_micro_interrupt_control2_register">LINKTRN_USER_RX_linktrnur_micro_interrupt_control2_register</A></td><td>Micro Interrupt Control 2 Register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_control0_register">LINKTRN_USER_RX_linktrnur_control0_register - Control 0 Register</a></b><br>
Address Offset = 32'h0000_d080<br>
Physical Address = 32'h0000_d080<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_control0_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_control0_register_A<br>
Reset Value = 16'h0004<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_active</td>
<td align=left>
Set to TRUE (1'b1) by the micro to indicate the link training<br>
is active on the rx side.<br>
This field is used in the RX lane(s) to determine <br>
when it is safe to turn on/off PAM4/NRZ decoded in the&nbsp <br>
in the RX datapath. The firmware is required set this field the&nbsp <br>
when link training is active in the RX side<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_trn_mode</td>
<td align=left>
RX Training mode select<br>
0 - cl72/cl93 mode <br>
1 - 802.3cd mode <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_signal_ok</td>
<td align=left>
 Firmware sets this bit to 1'b0 when the training is in progress<br>
 and sets this bit to 1'b1 when the training is complete <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_tr_coarse_lock</td>
<td align=left>
Set to TRUE (1'b1) by the micro when coarse lock to recovered clock has occured. <br>
linktrn_pmd, then, proceeds with establishing frame_lock. <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_training_en</td>
<td align=left>
RX Training Enable <br>
Enables the frame lock fsm on the RX sides <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_control1_register">LINKTRN_USER_RX_linktrnur_control1_register - Control 1 Register</a></b><br>
Address Offset = 32'h0000_d081<br>
Physical Address = 32'h0000_d081<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_control1_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_control1_register_A<br>
Reset Value = 16'h0052<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_bad_marker_cnt</td>
<td align=left>
Number of bad marker to check <br>
before losing frame lock <br>
Reset value is 0x5.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_good_marker_cnt</td>
<td align=left>
Number of good marker to check <br>
before enabling frame lock <br>
Reset value is 0x2.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_control2_register">LINKTRN_USER_RX_linktrnur_control2_register - Control 2 Register</a></b><br>
Address Offset = 32'h0000_d082<br>
Physical Address = 32'h0000_d082<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_control2_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_control2_register_A<br>
Reset Value = 16'h0b90<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_usedme_marker_chk</td>
<td align=left>
This field allows the use of the bits from the DME cell <br>
for frame marker checking. Using more bits for frame marker <br>
decreases the probability of false frame marker locking <br>
0 - use only frame marker bits for the frame marker checking<br>
1 - use frame marker + DME cell bits for frame marker checking<br>
<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_block_lp_ieee_updates</td>
<td align=left>
linktrn Block new lp ieee control/status page updates while an interrupt is pending<br>
0 - when the consistency checks are disabled, allow lp ieee control/status pages <br>
&nbsp &nbsp to be updated upon receiving new pages all of the time <br>
"1 - when the consistency checks are disabled, block lp ieee control/status pages <br>
<br>
&nbsp &nbsp to be updated upon receiving new pages if an interrupt is already pending <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_frame_consistency_chk_en</td>
<td align=left>
linktrn frame consistency check enable<br>
0 - disabled <br>
1 - enabled - checks that three consective frames from the link partner <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp has the same status response/coffcient update request information <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp before it set the sets the latched status bits <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_dp_ln_clk_en</td>
<td align=left>
linktrn Rx datapath lane clock enable<br>
0 - disabled <br>
1 - enabled <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_ppm_offset_en</td>
<td align=left>
if enabled, linktrn tracks ppm offset of incoming data <br>
while checking from frame lock, the offset is in <br>
either direction for every frame <br>
0 - disabled <br>
1 - enabled <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_strict_marker_chk</td>
<td align=left>
When determining frame lock, this field can be used to <br>
specifies whether the edges of frame markers are allowed <br>
to shift by a couple samples <br>
0 - ignore first and last two samples of the marker<br>
1 - do not ignore first and last two samples of the marker <br>
&nbsp &nbsp check for all 16 ones followed by 16 zeros <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_strict_dme_chk</td>
<td align=left>
This field specifies whether the edges of DME cells are allowed <br>
to shift by a couple samples <br>
 0 - ignore bits 0, 3, 4 and 7 of the DME cell <br>
 1 - check all 8 bits of the DME cell <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_dme_cell_boundary_chk</td>
<td align=left>
Check for DME cell boundary transitions <br>
 0 - disabled <br>
 1 - enabled <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_status0_register">LINKTRN_USER_RX_linktrnur_status0_register - Status 0 Register</a></b><br>
Address Offset = 32'h0000_d083<br>
Physical Address = 32'h0000_d083<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_status0_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_status0_register_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_rcv_status_report_parity</td>
<td align=left>
This fields indicates the parity of the current value of the <br>
linktrn_ieee_lp_status_report register field. This field can be <br>
used to determine if contents of linktrn_ieee_lp_status_report <br>
has parity error <br>
0 - even parity - linktrn_ieee_lp_status_report field has even number of 1's <br>
1 - odd parity&nbsp - linktrn_ieee_lp_status_report field has odd number of 1's <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_rcv_coeff_update_parity</td>
<td align=left>
This fields indicates the parity of the current value of the <br>
linktrn_ieee_lp_coeff_update register field. This field can be <br>
used to determine if contents of linktrn_ieee_lp_coeff_update <br>
has parity error <br>
0 - even parity - linktrn_ieee_lp_coeff_update field has even number of 1's <br>
1 - odd parity&nbsp - linktrn_ieee_lp_coeff_update field has odd number of 1's <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_frame_lock_LH</td>
<td align=left>
frame_lock latch high<br>
It only goes to a 1 if the frame_lock field transitions from a 0 to a 1 <br>
cleared upon reading this register <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_frame_lock_LL</td>
<td align=left>
frame_lock latch low<br>
It only goes to a 1 if the frame_lock field transitions from a 1 to a 0 <br>
cleared upon reading this register <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_remote_rx_ready</td>
<td align=left>
remote_rx_ready status <br>
This bit provides status of the remote_rx_ready signal from the link partner.<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_frame_lock</td>
<td align=left>
Frame Lock signal status <br>
This bit provides status of the frame lock signal from the frame lock fsm.<br>
1 - frame locked <br>
0 - frame not locked<br>
 The status bit in the IEEE registers space is set by firmware <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_micro_interrupt_control0_register">LINKTRN_USER_RX_linktrnur_micro_interrupt_control0_register - Micro Interrupt Control 0 Register</a></b><br>
Address Offset = 32'h0000_d084<br>
Physical Address = 32'h0000_d084<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_micro_interrupt_control0_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_micro_interrupt_control0_register_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_status_resp_int_frc_val</td>
<td align=left>
Force value on linktrn_micro_status_resp_int pin <br>
when linktrn_micro_status_resp_int_frc field is set to 1'b1 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_status_resp_int_frc</td>
<td align=left>
Force an interrupt on linktrn_micro_status_resp_int pin <br>
0 -&nbsp interrupt on the linktrn_micro_status_resp_int pin <br>
&nbsp &nbsp&nbsp generated when the status field value changes in the training<br>
&nbsp &nbsp&nbsp frame received from Link Partner and <br>
&nbsp &nbsp&nbsp linktrn_micro_status_chg_int_en field is set to 1'b1 <br>
1 -&nbsp interrupt on the linktrn_micro_status_resp_int pin <br>
&nbsp &nbsp&nbsp generated by the linktrn_micro_status_resp_int_frc_val field <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_update_req_int_frc_val</td>
<td align=left>
Force value on linktrn_micro_update_req_int pin <br>
when linktrn_micro_update_req_int_frc field is set to 1'b1 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_update_req_int_frc</td>
<td align=left>
Force an interrupt on linktrn_micro_update_req_int pin <br>
0 -&nbsp interrupt on the linktrn_micro_update_req_int pin <br>
&nbsp &nbsp&nbsp generated when the update field value changes in the training<br>
&nbsp &nbsp&nbsp frame received from Link Partner and <br>
&nbsp &nbsp&nbsp linktrn_micro_update_chg_int_en field is set to 1'b1 <br>
1 -&nbsp interrupt on the linktrn_micro_update_req_int pin <br>
&nbsp &nbsp&nbsp generated by the linktrn_micro_update_req_int_frc_val field <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_fflock_int_en</td>
<td align=left>
False frame lock micro interrupt enable. <br>
 1 - Enable <br>
 0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_frame_lock_int_en</td>
<td align=left>
frame_lock change micro interrupt enable. <br>
 1 - Enable <br>
 0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_status_chg_int_en</td>
<td align=left>
Status field change micro interrupt enable. Enables an interrupt when the status field value changes in the training frame received from Link Partner<br>
When the Local Devices requests Link Partner to change its TX FIR tap values, then the Link Partner updates <br>
taps and sends a response on the stataus field of the training frame <br>
 1 - Enable. Generates an interrupt when linktrn_micro_lstatus_status_chg = 1'b1. <br>
 0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_update_chg_int_en</td>
<td align=left>
Update field micro interrupt enable. Enables an interrupt when the update field value changes in the training frame received from Link Partner<br>
The Link parnter request a change to the Local Device TX FIR tap values via the update field <br>
 1 - Enable. Generates an interrupt when linktrn_micro_lstatus_update_chg = 1'b1.&nbsp <br>
 0 - Disable <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_micro_status0_register">LINKTRN_USER_RX_linktrnur_micro_status0_register - Micro Status 0 Register</a></b><br>
Address Offset = 32'h0000_d085<br>
Physical Address = 32'h0000_d085<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_micro_status0_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_micro_status0_register_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_micro_update_chg_lstatus</td>
<td align=left>
coeffcient update field change latched status -&nbsp This bit is set to 1'b1 when the update field value changes in the <br>
training frame received from the Link Partner. <br>
 This bit cleared when this register is read. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_micro_status1_register">LINKTRN_USER_RX_linktrnur_micro_status1_register - Micro Status 1 Register</a></b><br>
Address Offset = 32'h0000_d086<br>
Physical Address = 32'h0000_d086<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_micro_status1_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_micro_status1_register_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_micro_fflock_lstatus</td>
<td align=left>
False frame lock latched status - This bit is set to 1'b1 when a number of consective frames with DME errors are detected.&nbsp <br>
The number of the frames are specified by the linktrn_fflock_derr_consec_fcnt field <br>
This bit cleared when this register is read. <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_micro_frame_lock_lstatus</td>
<td align=left>
Frame lock change latched status - This bit is set to 1'b1 when a change is detected on the frame lock signal <br>
This bit cleared when this register is read. <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_micro_status_chg_lstatus</td>
<td align=left>
coeffcient status field latched status - This bit is set to 1'b1 when the status field value changes in the <br>
training frame received from the Link Partner. <br>
This bit cleared when this register is read. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_control3_register">LINKTRN_USER_RX_linktrnur_control3_register - Control 3 Register</a></b><br>
Address Offset = 32'h0000_d087<br>
Physical Address = 32'h0000_d087<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_control3_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_control3_register_A<br>
Reset Value = 16'h000d<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_pam4_trn_frame_size</td>
<td align=left>
In 802.3cd mode, RX training frame size <br>
1 - 16672 UI RX training frame <br>
0 - 4384 UI RX training frame <br>
UI = 2 bits <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_async_ppm_adjust</td>
<td align=left>
PPM offset adjustment select <br>
 0 - allow 1 UI of drift from one frame to the next <br>
 1 - allow upto 10UI of drift from one frame to the next <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_signdata_sel</td>
<td align=left>
Select sign data for link training <br>
1 - Use 20 bit sign data <br>
&nbsp &nbsp (i.e. sign bit from phase slicers in PAM4 mode,<br>
&nbsp &nbsp and data bit from the data slicers in NRZ mode) <br>
0 - Use 40 bit rx data from the aggregator <br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_control4_register">LINKTRN_USER_RX_linktrnur_control4_register - Control 4 Register</a></b><br>
Address Offset = 32'h0000_d088<br>
Physical Address = 32'h0000_d088<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_control4_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_control4_register_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_prbs_chk_mode_sel</td>
<td align=left>
In 802.3cd mode, RX Link training PRBS polynomial select. <br>
0:&nbsp&nbsp 1 + x&nbsp + x2 + x12 + x13<br>
1:&nbsp&nbsp 1 + x2 + x3 + x7&nbsp + x13<br>
2:&nbsp&nbsp 1 + x2 + x4 + x8&nbsp + x13<br>
3:&nbsp&nbsp 1 + x2 + x5 + x9&nbsp + x13<br>
PLEASE NOTE:The default value of this register field is unique for each lane i.e. <br>
Lane 0,4 - 2'b00 <br>
Lane 1,5 - 2'b01 <br>
Lane 2,6 - 2'b10 <br>
Lane 3,7 - 2'b11 <br>
<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_prbs_chk_auto_detect_relock_en</td>
<td align=left>
In 802.3cd mode, Re-auto-detect PRBS polynomial in the RX Link training frames <br>
1 - Re-auto-detect PRBS polynomial if linktrn_rx_prbs_chk_auto_detect_lock tranitions to 0 ? <br>
0 - use auto-detected PRBS polynomial until %LINKTRN_CFG%]_rx_prbs_chk_auto_detect_en =0<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_prbs_chk_auto_detect_en</td>
<td align=left>
In 802.3cd mode, Auto-detect PRBS polynomials in the RX Link training frames. <br>
 1 - Enabled. <br>
 0 - Disabled. <br>
{linktrn_rx_prbs_chk_auto_detect_en, linktrn_rx_prbs_chk_auto_detect_relock_en} <br>
{1'b0, 1'bx} : Disabled. Use linktrn_rx_prbs_chk_mode_sel to select PRBS polynomial for PRBS checking <br>
{1'b1, 1'b0} : Enabled. Use auto-detected PRBS polynomial until %LINKTRN_CFG%]_rx_prbs_chk_auto_detect_en = 0&nbsp <br>
{1'b1, 1'b1} : Enabled. Re-auto-detected if linktrn_rx_prbs_chk_auto_detect_lock transitions to 0 ? <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_rx_prbs_chk_en</td>
<td align=left>
In 802.3cd mode, PRBS checking in the RX link training frames <br>
1 - Enabled<br>
0 - Disabled<br>
The micro (firmware) set's this field to 1 to start the RX link training PRBS checking<br>
and clear it when the training is complete<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_status1_register">LINKTRN_USER_RX_linktrnur_status1_register - Status 1 Register</a></b><br>
Address Offset = 32'h0000_d089<br>
Physical Address = 32'h0000_d089<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_status1_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_status1_register_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_rx_prbs_chk_mode_sel_auto_detect</td>
<td align=left>
In 802.3cd mode, Status of the auto-detected polynomial, valid after linktrn_rx_prbs_chk_auto_detect_lock = 1 <br>
2'd0:&nbsp&nbsp 1 + x&nbsp + x2 + x12 + x13<br>
2'd1:&nbsp&nbsp 1 + x2 + x3 + x7&nbsp + x13<br>
2'd2:&nbsp&nbsp 1 + x2 + x4 + x8&nbsp + x13<br>
2'd3:&nbsp&nbsp 1 + x2 + x5 + x9&nbsp + x13<br>
The default value of this field will depends on the lane number i.e. <br>
PLEASE NOTE:The default value of this register field for each lane is unique i.e.<br>
Lane 0,4 - 2'b00 <br>
Lane 1,5 - 2'b01 <br>
Lane 2,6 - 2'b10 <br>
Lane 3,7 - 2'b11 <br>
<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_rx_prbs_chk_auto_detect_lock</td>
<td align=left>
In 802.3cd mode, Auto-detect PRBS polynomial lock status&nbsp <br>
1 - Locked<br>
0 - Unlocked<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_control5_register">LINKTRN_USER_RX_linktrnur_control5_register - Control 5 Register</a></b><br>
Address Offset = 32'h0000_d08a<br>
Physical Address = 32'h0000_d08a<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_control5_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_control5_register_A<br>
Reset Value = 16'h0510<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_fflock_derr_per_fcnt</td>
<td align=left>
This field specify the number of DME errors to be detected in a frame to be regard it as a bad frame <br>
Reset value is 5.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_fflock_derr_consec_fcnt</td>
<td align=left>
This field defines the number of consective frame with dme errors to be detected <br>
to identify false frame lock <br>
Reset value is 0x10.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_micro_interrupt_control1_register">LINKTRN_USER_RX_linktrnur_micro_interrupt_control1_register - Micro Interrupt Control 1 Register</a></b><br>
Address Offset = 32'h0000_d08d<br>
Physical Address = 32'h0000_d08d<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_micro_interrupt_control1_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_micro_interrupt_control1_register_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_interrupt_mask_control_page</td>
<td align=left>
Interrupt mask for the control page received from the link partner <br>
 1 - mask. A change on the corresponding bit will not generate interrupt&nbsp <br>
 0 - normal mode.&nbsp A change on the corresponding bit will generate interrupt <br>
 should be set 0xCFC0 during training <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_RX_linktrnur_micro_interrupt_control2_register">LINKTRN_USER_RX_linktrnur_micro_interrupt_control2_register - Micro Interrupt Control 2 Register</a></b><br>
Address Offset = 32'h0000_d08e<br>
Physical Address = 32'h0000_d08e<br>
Verilog CL45 Address = {`LINKTRN_USER_RX_A, `linktrnur_micro_interrupt_control2_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_RX_A, 4'h0}, `linktrnur_micro_interrupt_control2_register_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_micro_interrupt_mask_status_page</td>
<td align=left>
Interrupt mask for the status page received from the link partner <br>
 1 - mask. A change on the corresponding bit will not generate interrupt&nbsp <br>
 0 - normal mode.&nbsp A change on the corresponding bit will generate interrupt <br>
 should be set 0x7FC0 during training <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_RX Registers">Return to LINKTRN_USER_RX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="LINKTRN_USER_TX Registers">LINKTRN_USER_TX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd090</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_xmt_update_page_register">LINKTRN_USER_TX_linktrnut_xmt_update_page_register</A></td><td>linktrn Send Coefficient Update Request to Link Partner Register</td></tr>
<tr>
<td align=center>0xd091</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_ld_xmt_status_page">LINKTRN_USER_TX_linktrnut_ld_xmt_status_page</A></td><td>linktrn Send Local Device's Coeffcient Status to Link Partner Register</td></tr>
<tr>
<td align=center>0xd092</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_control0_register">LINKTRN_USER_TX_linktrnut_control0_register</A></td><td>linktrn Control 0 Register</td></tr>
<tr>
<td align=center>0xd093</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_control1_register">LINKTRN_USER_TX_linktrnut_control1_register</A></td><td>linktrn Control 1 Register</td></tr>
<tr>
<td align=center>0xd094</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_control2_register">LINKTRN_USER_TX_linktrnut_control2_register</A></td><td>linktrn Control 2 Register</td></tr>
<tr>
<td align=center>0xd095</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_control3_register">LINKTRN_USER_TX_linktrnut_control3_register</A></td><td>linktrn Control 3 Register</td></tr>
<tr>
<td align=center>0xd096</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_status0_register">LINKTRN_USER_TX_linktrnut_status0_register</A></td><td>linktrn Status 0 Register</td></tr>
<tr>
<td align=center>0xd097</td><td><A HREF="#LINKTRN_USER_TX_linktrnut_control4_register">LINKTRN_USER_TX_linktrnut_control4_register</A></td><td>linktrn Control 4 Register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_xmt_update_page_register">LINKTRN_USER_TX_linktrnut_xmt_update_page_register - linktrn Send Coefficient Update Request to Link Partner Register</a></b><br>
Address Offset = 32'h0000_d090<br>
Physical Address = 32'h0000_d090<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_xmt_update_page_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_xmt_update_page_register_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_xmt_update_page</td>
<td align=left>
Local Device's transmit control page <br>
The contents of this register maps to the control field <br>
portion of the link training frame. This register is <br>
fully programmable and therefore the firmware has the flexibility <br>
to map the register bits to different IEEE/OIF/FC standards <br>
Please see the apprpopiate standards for registers bit definitions. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_ld_xmt_status_page">LINKTRN_USER_TX_linktrnut_ld_xmt_status_page - linktrn Send Local Device's Coeffcient Status to Link Partner Register</a></b><br>
Address Offset = 32'h0000_d091<br>
Physical Address = 32'h0000_d091<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_ld_xmt_status_page_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_ld_xmt_status_page_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_ld_xmt_status_page</td>
<td align=left>
Local Device's transmit status page <br>
The contents of this register maps to the Status Report <br>
portion of the link training frame. This register is <br>
fully programmable and therefore the firmware has the flexibility <br>
to map the register bits to different IEEE/OIF/FC standards <br>
Please see the apprpopiate standards for registers bit definitions. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_control0_register">LINKTRN_USER_TX_linktrnut_control0_register - linktrn Control 0 Register</a></b><br>
Address Offset = 32'h0000_d092<br>
Physical Address = 32'h0000_d092<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_control0_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_control0_register_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_ignore_xmt_reg_value</td>
<td align=left>
linktrn_ignore_xmt_reg_value is used to tell the linktrn <br>
transmitter that it should ignore the contents of linktrn_xmt_update_page <br>
and linktrn_ld_xmt_status_page fields. This is used in applications that <br>
only allows the control and status to change during the same frame <br>
1 - ignore (do not use) linktrn_xmt_update_page/linktrn_ld_xmt_status_page&nbsp &nbsp fields in the linktrn frame(s) trasmitterd to LP 0 - allow linktrn_xmt_update_page/linktrn_ld_xmt_status_page
<br>
&nbsp &nbsp fields in the linktrn frame(s) trasmitterd to LP <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_sw_remote_rx_ready</td>
<td align=left>
Set to TRUE (1'b1) by the micro to indicate to the training fsm<br>
link parnter rx ready bit is set. It indicates that the remote is trained <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_sw_frame_lock</td>
<td align=left>
Set to TRUE (1'b1) by the micro to indicate to the training fsm<br>
frame lock has been achieved <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_sw_rx_trained</td>
<td align=left>
Set to TRUE (1'b1) by the micro when the remote transmit<br>
and local equalizers have been optimized and normal data <br>
transmission may commence; set to FALSE (1'b0) otherwise. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_control1_register">LINKTRN_USER_TX_linktrnut_control1_register - linktrn Control 1 Register</a></b><br>
Address Offset = 32'h0000_d093<br>
Physical Address = 32'h0000_d093<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_control1_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_control1_register_A<br>
Reset Value = 16'h0004<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_timer_value_sel</td>
<td align=left>
This bit is used to select the register fields that sets the <br>
maximum training time and the number of frames to be sent by <br>
the local device after it has been trainined <br>
This field is normally set while the datapath reset is asserted. <br>
This bit is asynchronous to the txcom_* register fields<br>
 1 = use txcom_linktrn_wait_cntr_limit_2ndset/txcom_linktrn_max_wait_timer_period_2ndset <br>
 0 = use txcom_linktrn_wait_cntr_limit/txcom_linktrn_max_wait_timer_period&nbsp <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_tx_dp_ln_clk_en</td>
<td align=left>
linktrn Tx Datapath lane clock enable<br>
0 - disabled <br>
1 - enabled <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_dis_max_wait_timer</td>
<td align=left>
 disable max wait timer<br>
 1 = max wait timer disabled <br>
 0 = max wait timer enabled <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_brk_ring_osc</td>
<td align=left>
PRBS 11 Ring Oscillator control<br>
1: No oscillating - low power mode <br>
0: Osciallate - normal mode<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_control2_register">LINKTRN_USER_TX_linktrnut_control2_register - linktrn Control 2 Register</a></b><br>
Address Offset = 32'h0000_d094<br>
Physical Address = 32'h0000_d094<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_control2_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_control2_register_A<br>
Reset Value = 16'h1021<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_pam4m_prbs_repl_mode</td>
<td align=left>
PRBS bit replication mode during 802.3cd PAM2 modulation <br>
 0 - disable replication <br>
 1 - replicate/map even bits from the PRBS generator and discard odd bits <br>
 2 - replicate/map odd bits from the PRBS generator and discard even bits <br>
 3 - replicate/map both odd and even bits from the PRBS generator (for Sinai/cl72/cl93 NRZ pattern) <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_pam4m_graycoder_en_frc</td>
<td align=left>
In 802.3cd mode, gray coding for PRBS pattern is::<br>
 a) Disabled when PAM2/NRZ modulation is used <br>
 b) Enabled when PAM4 modulation is used <br>
 However, graycoding can be forced on/off using <br>
linktrn_pam4m_graycoder_en_frc and linktrn_pam4m_graycoder_en_frc_val register fields i.e. <br>
{linktrn_pam4m_graycoder_en_frc linktrn_pam4m_graycoder_en_frc_val register fields} <br>
2'b0x - normal mode<br>
2'b10 - force gray coding off<br>
2'b11 - force gray coding on<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_pam4m_graycoder_en_frc_val</td>
<td align=left>
Please see linktrn_pam4m_graycoder_en_frc <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_pam4_symbol_bit_swap</td>
<td align=left>
In 802.3cd mode PRBS Symbol bits {A,B} swap enable.&nbsp <br>
Bit swapping is done just before the gray encoder.<br>
1 => 2 bits symbol bits will be swapped. Symbol bits {A,B} <br>
&nbsp &nbsp&nbsp maps to the datastream bits {[n+1], [n]} where n is the first bit <br>
&nbsp &nbsp&nbsp in transmission order.<br>
0 => No swapping, default mode. Symbol bits {A,B} maps to the <br>
&nbsp &nbsp&nbsp datastream bits {[n], [n+1]} where n is the first bit in transmission order.<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_pam4m_precoder_en</td>
<td align=left>
In 802.3cd mode, PRBS pattern precoding enable <br>
 0 - Diabled <br>
 1 - Enabled <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_pam4m_sym_sel</td>
<td align=left>
In 802.3cd mode, PRBS pattern symbol (modulation) select <br>
 0 - PAM2/NRZ symbol (modulation). Each bit of the PRBS training pattern is repeated <br>
&nbsp &nbsp&nbsp to generate NRZ symbols <br>
 1 - PAM4 symbol (modulation). Two bits of the PRBS training pattern is used to generate <br>
&nbsp &nbsp&nbsp the PAM4 symbols. Gray code and Precoding are disabled by default <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_tx_pam4_trn_frame_size</td>
<td align=left>
In 802.3cd mode, TX training frame size select <br>
1 - 16672 UI TX training frame <br>
0 - 4384 UI TX training frame <br>
UI = 2 bits <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_tx_trn_mode</td>
<td align=left>
TX Training mode select<br>
0 - cl72/cl93 mode <br>
1 - 802.3cd mode <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_prbs_mode_sel</td>
<td align=left>
This field is used to select prbs mode<br>
 00 - cl72 mode. Uses 1 + x9&nbsp + x11 prbs polynomial <br>
 01 - cl93 mode. linktrn_cl93prbs_poly_sel selects the cl93 PRBS polynomial <br>
 10 - 802.3cd mode. linktrn_prbs13_poly_sel selects the PRBS13 polynomial <br>
<br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_control3_register">LINKTRN_USER_TX_linktrnut_control3_register - linktrn Control 3 Register</a></b><br>
Address Offset = 32'h0000_d095<br>
Physical Address = 32'h0000_d095<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_control3_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_control3_register_A<br>
Reset Value = 16'h1aa0<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_prbs13_poly_sel</td>
<td align=left>
prbs13 polynomial select <br>
These bits are used to select prbs13 polynomials when prbs_mode_sel field is set to 2 <br>
2'b00:&nbsp&nbsp 1 + x&nbsp + x2 + x12 + x13<br>
2'b01:&nbsp&nbsp 1 + x2 + x3 + x7&nbsp + x13<br>
2'b10:&nbsp&nbsp 1 + x2 + x4 + x8&nbsp + x13<br>
2'b11:&nbsp&nbsp 1 + x2 + x5 + x9&nbsp + x13<br>
PLEASE NOTE:The default value of this register field for each lane is unique. <br>
the default values for lanes are: <br>
Lane 0,4 - 2'b00 <br>
Lane 1,5 - 2'b01 <br>
Lane 2,6 - 2'b10 <br>
Lane 3,7 - 2'b11 <br>
<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_prbs13_seed_val</td>
<td align=left>
prbs13 seed value <br>
These bits can be used to specify the prbs13 seed values <br>
PLEASE NOTE: The default value of these register bits for each lane is unique. The IEEE standards <br>
defines the following default seed values for each lane: <br>
Lane 0,4 - 13'h1AA0 <br>
Lane 1,5 - 13'h105C <br>
Lane 2,6 - 13'h0689 <br>
Lane 3,7 - 13'h0822 <br>
<br>
Reset value is 0x1aa0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_status0_register">LINKTRN_USER_TX_linktrnut_status0_register - linktrn Status 0 Register</a></b><br>
Address Offset = 32'h0000_d096<br>
Physical Address = 32'h0000_d096<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_status0_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_status0_register_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_sm_current_state</td>
<td align=left>
Training State machine current state <br>
0 = ST_INITIALIZE <br>
1 = ST_SEND_TRAINING <br>
2 = ST_TRAIN_LOCAL <br>
3 = ST_TRAIN_REMOTE <br>
4 = ST_LINK_READY <br>
5 = ST_SEND_DATA <br>
6 = ST_TRAINING_FAILURE <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_xmt_status_report_parity</td>
<td align=left>
This fields indicates the parity of the current value of the <br>
linktrn_ld_xmt_status_page register field. This field can be <br>
used to adjust the parity of the Status page field before <br>
it is sent to the link partner. <br>
0 - even parity - linktrn_ld_xmt_status_page field has even number of 1's <br>
1 - odd parity&nbsp - linktrn_ld_xmt_status_page field has odd number of 1's <br>
linktrn_ignore_xmt_reg_value can be set to 1 stop the contents of <br>
linktrn_ld_xmt_status_page being sent while parity is being adjusted <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_xmt_coeff_update_parity</td>
<td align=left>
This fields indicates the parity of the current value of the <br>
linktrn_xmt_update_page register field. This field can be <br>
used to adjust the parity of the Coeffcient Update field before <br>
it is sent to the link partner. <br>
0 - even parity - linktrn_xmt_update_page field has even number of 1's <br>
1 - odd parity&nbsp - linktrn_xmt_update_page field has odd number of 1's <br>
linktrn_ignore_xmt_reg_value can be set to 1 stop the contents of <br>
linktrn_xmt_update_page being sent while parity is being adjusted <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_training_fsm_signal_detect</td>
<td align=left>
1 - linktrn is in SEND_DATA state <br>
0 - linktrn is in training or reset state <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>linktrn_local_rx_ready</td>
<td align=left>
Set to TRUE (1'b1) by the FSM when the remote transmit<br>
and local equalizers have been optimized and normal data <br>
transmission may commence; set to FALSE (1'b0) otherwise. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="LINKTRN_USER_TX_linktrnut_control4_register">LINKTRN_USER_TX_linktrnut_control4_register - linktrn Control 4 Register</a></b><br>
Address Offset = 32'h0000_d097<br>
Physical Address = 32'h0000_d097<br>
Verilog CL45 Address = {`LINKTRN_USER_TX_A, `linktrnut_control4_register_Adr}<br>
Verilog CL22 Address = {`LINKTRN_USER_TX_A, 4'h0}, `linktrnut_control4_register_A<br>
Reset Value = 16'h03f5<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_prbs_seed_sel</td>
<td align=left>
These bits used to select the seed for prbs generator during the training sequence:<br>
2'b00 - cl72 mode - random seed every frame, cl93 mode - seed specified by the linktrn_prbs_seed_val field<br>
&nbsp &nbsp &nbsp &nbsp 802.3cd mode - seed specified by the linktrn_prbs13_seed_val field<br>
2'b01 - random seed every frame<br>
2'b10 - random seed first frame only and then same seed every frame<br>
2'b11 - seed specified by the linktrn_prbs_seed_val and/or linktrn_prbs13_seed_val fields <br>
<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_cl93prbs_poly_sel</td>
<td align=left>
cl93 mode prbs polynomial select <br>
These bits are used to select the following prbs polynomials when prbs_mode_sel field is set to 1'b1: <br>
2'b00: 1 + x5 + x6 + x10 + x11 <br>
2'b01: 1 + x5 + x6 + x9&nbsp + x11 <br>
2'b10: 1 + x4 + x6 + x8&nbsp + x11 <br>
2'b11: 1 + x4 + x6 + x7&nbsp + x11 <br>
PLEASE NOTE:The default value of this register field is unique for each lane. The IEEE P802.3bj-2014 <br>
defines the following default seed values for each lane: <br>
Lane 0,4 - 2'b00 <br>
Lane 1,5 - 2'b01 <br>
Lane 2,6 - 2'b10 <br>
Lane 3,7 - 2'b11 <br>
<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>linktrn_prbs_seed_val</td>
<td align=left>
prbs seed value <br>
These bits can be used to specify the cl72/cl93 prbs seed values <br>
PLEASE NOTE: The default value of these register bits for each lane is unique. The IEEE P802.3bj/D2.1 <br>
defines the following default seed values for each lane: <br>
Lane 0,4 - 11'h3F5 <br>
Lane 1,5 - 11'h513 <br>
Lane 2,6 - 11'h5A7 <br>
Lane 3,7 - 11'h36F <br>
<br>
Reset value is 0x3f5.</td></tr>
</table><p>
<A HREF="#LINKTRN_USER_TX Registers">Return to LINKTRN_USER_TX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TX_PI_8x_pll2x_v1p0 Registers">TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd0a0</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_control_0">TX_PI_8x_pll2x_v1p0_tx_pi_control_0</A></td><td>TX Phase Interpolator Control 0</td></tr>
<tr>
<td align=center>0xd0a1</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_control_1">TX_PI_8x_pll2x_v1p0_tx_pi_control_1</A></td><td>TX Phase Interpolator Control 1</td></tr>
<tr>
<td align=center>0xd0a2</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_control_2">TX_PI_8x_pll2x_v1p0_tx_pi_control_2</A></td><td>TX Phase Interpolator Control 2</td></tr>
<tr>
<td align=center>0xd0a3</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_control_3">TX_PI_8x_pll2x_v1p0_tx_pi_control_3</A></td><td>TX Phase Interpolator Control 3</td></tr>
<tr>
<td align=center>0xd0a4</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_control_4">TX_PI_8x_pll2x_v1p0_tx_pi_control_4</A></td><td>TX Phase Interpolator Control 4</td></tr>
<tr>
<td align=center>0xd0a5</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_control_5">TX_PI_8x_pll2x_v1p0_tx_pi_control_5</A></td><td>TX Phase Interpolator Control 5</td></tr>
<tr>
<td align=center>0xd0a8</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_status_0">TX_PI_8x_pll2x_v1p0_tx_pi_status_0</A></td><td>TX Phase Interpolator Status 0</td></tr>
<tr>
<td align=center>0xd0a9</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_status_1">TX_PI_8x_pll2x_v1p0_tx_pi_status_1</A></td><td>TX Phase Interpolator Status 1</td></tr>
<tr>
<td align=center>0xd0aa</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_status_2">TX_PI_8x_pll2x_v1p0_tx_pi_status_2</A></td><td>TX Phase Interpolator Status 2</td></tr>
<tr>
<td align=center>0xd0ab</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_status_3">TX_PI_8x_pll2x_v1p0_tx_pi_status_3</A></td><td>TX Phase Interpolator Status 3</td></tr>
<tr>
<td align=center>0xd0ac</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_status_4">TX_PI_8x_pll2x_v1p0_tx_pi_status_4</A></td><td>TX Phase Interpolator Status 4</td></tr>
<tr>
<td align=center>0xd0ad</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_tx_fifo_ovfb_status">TX_PI_8x_pll2x_v1p0_tx_pi_tx_fifo_ovfb_status</A></td><td>TX FIFO Overflow Status</td></tr>
<tr>
<td align=center>0xd0ae</td><td><A HREF="#TX_PI_8x_pll2x_v1p0_tx_pi_status_5">TX_PI_8x_pll2x_v1p0_tx_pi_status_5</A></td><td>TX Phase Interpolator Status 5</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_control_0">TX_PI_8x_pll2x_v1p0_tx_pi_control_0 - TX Phase Interpolator Control 0</a></b><br>
Address Offset = 32'h0000_d0a0<br>
Physical Address = 32'h0000_d0a0<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_control_0_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_control_0_A<br>
Reset Value = 16'h7000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_second_order_loop_en</td>
<td align=left>
 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop. <br>
 This bit is only valid when tx_pi_jitter_filter_en is set to 1'b1. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ext_phase_bwsel_integ</td>
<td align=left>
 External Phase bandwidth control. Valid values are 0 to 7. <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_second_order_bwsel_integ</td>
<td align=left>
 Second order bandwidth control. Valid values are 0, 1, 2 and 3. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_first_order_bwsel_integ</td>
<td align=left>
 First order bandwidth control. <br>
 3'd0 - 110 KHz <br>
 3'd1 - 220 KHz <br>
 3'd2 - 440 KHz <br>
 3'd3 - 880 KHz <br>
 3'd4 - 1.7 MHz <br>
 >= 3'd5 is unused and reserved for future use. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_jit_ssc_freq_mode</td>
<td align=left>
 SSJ Mode Select:&nbsp <br>
 1'b1 : 10G SSC mode and 1'b0: 6G SSC mode <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ssc_gen_en</td>
<td align=left>
 Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_sj_gen_en</td>
<td align=left>
 Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_freq_override_en</td>
<td align=left>
 Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ext_ctrl_en</td>
<td align=left>
 Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Repeater ) <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_jitter_filter_en</td>
<td align=left>
 This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) . <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_en</td>
<td align=left>
 Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_control_1">TX_PI_8x_pll2x_v1p0_tx_pi_control_1 - TX Phase Interpolator Control 1</a></b><br>
Address Offset = 32'h0000_d0a1<br>
Physical Address = 32'h0000_d0a1<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_control_1_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_control_1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_freq_override_val</td>
<td align=left>
 Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.
<br>
 +8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per
UI = 781.25 <br>
 (-781.25) ppm. So 1 ppm = 10.486 value. <br>
 If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are
-8192 to +8191<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_control_2">TX_PI_8x_pll2x_v1p0_tx_pi_control_2 - TX Phase Interpolator Control 2</a></b><br>
Address Offset = 32'h0000_d0a2<br>
Physical Address = 32'h0000_d0a2<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_control_2_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_control_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_jit_amp</td>
<td align=left>
 Jitter Generator Amplification Factor. Valid values are 0 to 63. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_jit_freq_idx</td>
<td align=left>
 Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator
parameters. <br>
 In SJ&nbsp mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details. <br>
 In SSC mode: It provides Nssc.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp&nbsp Refer Jitter Generator spec for the table details. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_control_3">TX_PI_8x_pll2x_v1p0_tx_pi_control_3 - TX Phase Interpolator Control 3</a></b><br>
Address Offset = 32'h0000_d0a3<br>
Physical Address = 32'h0000_d0a3<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_control_3_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_control_3_A<br>
Reset Value = 16'h0100<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_phase_step_num</td>
<td align=left>
 Defines the number of phase steps movement for every manual strobe. Valid values are 1 to 15. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_phase_invert</td>
<td align=left>
 1'b1 : will invert (i.e. swap) the final inc and dec before the PI code shifter logic. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_phase_step_dir</td>
<td align=left>
 Manual Phase Step direction. <br>
 1'b0: Increment <br>
 1'b1: Decrement <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>tx_pi_phase_strobe</td>
<td align=left>
 Manual Phase strobe. When set to 1'b1 then it will generate 1 phase step (inc/dec depending on tx_pi_phase_step_dir) or multiple phase steps if tx_pi_phase_step_osr
is 1'b1. <br>
 If tx_pi_phase_override is 1'b0 then manual phase steps will be added with the output of the IIR filter phase steps during the time when there is no phase
steps from the IIR filter. <br>
 Self Clearing Register. Must be polled for 1'b0 before writing it to 1'b1 again for correct Manual Phase Step Shift. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_phase_override</td>
<td align=left>
 Manual Phase Override Mode. When 1'b1 the PI phase can be moved manually using registers. All the filter logic is bypassed during manual mode. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_control_4">TX_PI_8x_pll2x_v1p0_tx_pi_control_4 - TX Phase Interpolator Control 4</a></b><br>
Address Offset = 32'h0000_d0a4<br>
Physical Address = 32'h0000_d0a4<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_control_4_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_control_4_A<br>
Reset Value = 16'h0704<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_sampler_max_cnt</td>
<td align=left>
 This register defines the sampling of the phase_sum_val from the CDR by TX_PI. There is a local counter running with TX_PI clock (i.e. tclk) which counts
from 0 to tx_pi_sample_max_cnt. <br>
 This register value should be pragrammed such that (tx_pi_sample_max_cnt+1)*N cycles of tclk equals the phase_sum_val_toggle period. N should be >=1 and
the smallest number.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
 Supported values are from 7 to 15. Do not program values less than 7.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
 Programming examples are as below for widely used modes.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------&nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
 phase_sum_val_toggle period in tclk terms&nbsp&nbsp tx_pi_sample_max_cnt&nbsp comments&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------&nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 8&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp
7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp default mode used in remote loopback and repeater application between same kind of PMD cores and same data
rate.&nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 10 or 20&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 9&nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16 or 32&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 15&nbsp (or 7)&nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 40&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp
9&nbsp (or 7)&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_frz_mode_s1</td>
<td align=left>
 Freeze Mode. 1'b1 will freeze the integ2 reg for the first stage fliter so that during the freeze, TX PI will generate the phase steps based on the integ2
freeze value. tx_pi_frz_mode should be 0 when this bit is enabled. <br>
 1'b1 will freeze the integ2 reg&nbsp for the first stage fliter so that during the freeze, TX PI will generate the phase steps based on the integ2_s1
freeze value. <br>
 1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm
from PLL/VCO clock. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_reset_code_dbg</td>
<td align=left>
 Debug register.&nbsp <br>
 Resets the TX PI code going to AFE. This is just a debug register and is not recommended to be used during normal operation of TX PI. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_frz_mode</td>
<td align=left>
 Freeze Mode. 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value. <br>
 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value. <br>
 1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm
from PLL/VCO clock. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_frz_frc_val</td>
<td align=left>
 Force value for the IIR filter freeze. 1'b1 is freeze, 1'b0 is normal IIR operation. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_frz_frc</td>
<td align=left>
 IIR filter freeze control by force. 1'b1 will force the freeze value indicated by tx_pi_frz_frc_val otherwise Normal IIR operation. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_control_5">TX_PI_8x_pll2x_v1p0_tx_pi_control_5 - TX Phase Interpolator Control 5</a></b><br>
Address Offset = 32'h0000_d0a5<br>
Physical Address = 32'h0000_d0a5<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_control_5_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_control_5_A<br>
Reset Value = 16'h0084<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_pd_bypass_vco</td>
<td align=left>
 1'b1 will enable filter and vco bypass for inc/dec indication from all sources to get a quicker phase locking time. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_pd_bypass_flt</td>
<td align=left>
 1'b1 will enable filter bypass for inc/dec indication from all sources to get a quicker phase locking time. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_fifo_resetb_frc</td>
<td align=left>
1'b0: Normal mode where reset pin tx_fifo_resetb is controlled as per the description of the register afe_tx_fifo_resetb. <br>
1'b1: force the reset pin tx_fifo_resetb to value indicated in the register afe_tx_fifo_resetb. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_tx_fifo_resetb</td>
<td align=left>
1'b0: will assert the reset pin tx_fifo_resetb to 1'b0. <br>
1'b1: Once this bit is written to 1'b1 then phase error (bit 4) from FIFO is looked for 2 transitions and then reset is de-asserted to the Phase FIFO.
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ext_phase_step_cnt_full_bypass</td>
<td align=left>
 1'b1 : will select the pmd_tx_pi_ext_phase_step_cnt pin by controlling the tx_pi final inc/dec full bypass mux . Only have effect when tx_pi_ext_phase_step_cnt_sel
= 1.<br>
 1'b0 : pmd_tx_pi_ext_phase_step_cnt will go through the dsm2 filter&nbsp <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ext_phase_step_cnt_sel</td>
<td align=left>
 1'b1 : will select the pmd_tx_pi_ext_phase_step_cnt pin by controlling the tx_pi final inc/dec complete bypass mux . <br>
 If tx_pi_jitter_filter_en OR tx_pi_freq_override_en OR tx_pi_ext_ctrl_en reg fields are enabled then final mux will automatically switch to the normal
tx_pi mode <br>
 as if tx_pi_ext_phase_step_cnt_sel is 1'b0. Once all these fields are cleared then it will switch back to the pmd_tx_pi_ext_pd_inc/dec pin control mode
if tx_pi_ext_phase_step_cnt_sel is 1. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ext_phase_step_cnt_invert</td>
<td align=left>
 1'b1 : invert pmd_tx_pi_ext_phase_step_cnt such that -x will become +x and vice-versa and 0 will remain 0. <br>
 It is only valid when tx_pi_ext_phase_step_cnt_sel OR tx_pi_ext_pd_sel bits are 1'b1. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_hs_fifo_phserr_sel</td>
<td align=left>
Selects the source of the Phase Detector inc/dec information. tx_pi_ext_pd_sel has higher priority so it should be 1'b0 for tx_pi_hs_fifo_phserr_sel to
select. <br>
1'b1: hs_fifo_phserr[4] from the PD inside AFE for ultra-low latency path or TCA irrespective of rg_tx_pi_repeater_mode_en. <br>
1'b0: Select PD path based on rg_tx_pi_repeater_mode_en. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_ext_pd_sel</td>
<td align=left>
Selects the source of the Phase Detector inc/dec information. <br>
1'b1: Select external PD path irrespective of rg_tx_pi_repeater_mode_en <br>
1'b0: Select PD path based on rg_tx_pi_repeater_mode_en <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_repeater_mode_en</td>
<td align=left>
Selects the source of the Loop Timing CDR and Phase Detector inc/dec information. <br>
1'b1: Select external CDR and hs_fifo_phserr[4:0] from the high speed Phase FIFO PD inside AFE for ultra-low latency path. <br>
1'b0: selects the internal CDR and inc/dec from the Remote Loopback Phase Detector. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_hs_fifo_phserr_invert</td>
<td align=left>
1'b1: Inverts the hs_fifo_phserr[4:0] to invert the meaning of inc/dec from hs_fifo_phserr[4:0]. When this bit is 1'b0, 1'b1 is increment and 1'b0 is decrement.
<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_status_0">TX_PI_8x_pll2x_v1p0_tx_pi_status_0 - TX Phase Interpolator Status 0</a></b><br>
Address Offset = 32'h0000_d0a8<br>
Physical Address = 32'h0000_d0a8<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_status_0_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_status_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_phase_cntr</td>
<td align=left>
 TX PI Phase Counter. Signed Value. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_status_1">TX_PI_8x_pll2x_v1p0_tx_pi_status_1 - TX Phase Interpolator Status 1</a></b><br>
Address Offset = 32'h0000_d0a9<br>
Physical Address = 32'h0000_d0a9<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_status_1_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_status_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_integ1_reg</td>
<td align=left>
 TX PI integ1 register. Signed Value. <br>
 This field is meant for internal debug only. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_status_2">TX_PI_8x_pll2x_v1p0_tx_pi_status_2 - TX Phase Interpolator Status 2</a></b><br>
Address Offset = 32'h0000_d0aa<br>
Physical Address = 32'h0000_d0aa<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_status_2_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_status_2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_integ2_reg</td>
<td align=left>
 TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock. <br>
 +8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock. <br>
 Divide this register value by 10.485 to get the tclk ppm. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_status_3">TX_PI_8x_pll2x_v1p0_tx_pi_status_3 - TX Phase Interpolator Status 3</a></b><br>
Address Offset = 32'h0000_d0ab<br>
Physical Address = 32'h0000_d0ab<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_status_3_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_status_3_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_phase_sum_capture_resync_lh</td>
<td align=left>
 Debug latch high status bit to indicate when phase_sum_val transfer to tclk domain mechanism is resynced. It is clear upon read status. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_phase_err_s1</td>
<td align=left>
 TX PI Phase Error for the first stage jitter filter. Signed Value. Valid values are -8 to +8. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_phase_err</td>
<td align=left>
 TX PI Phase Error. Signed Value. Valid values are -8 to +8. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_status_4">TX_PI_8x_pll2x_v1p0_tx_pi_status_4 - TX Phase Interpolator Status 4</a></b><br>
Address Offset = 32'h0000_d0ac<br>
Physical Address = 32'h0000_d0ac<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_status_4_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_status_4_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>st_afe_tx_fifo_resetb</td>
<td align=left>
 Status of the final afe_tx_fifo_resetb signal connected to the AFE pin. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_hs_fifo_phserr</td>
<td align=left>
 Bit 4 of hs_fifo_pherr. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_tx_fifo_ovfb_status">TX_PI_8x_pll2x_v1p0_tx_pi_tx_fifo_ovfb_status - TX FIFO Overflow Status</a></b><br>
Address Offset = 32'h0000_d0ad<br>
Physical Address = 32'h0000_d0ad<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_tx_fifo_ovfb_status_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_tx_fifo_ovfb_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_fifo_ovfb_fall_edge_lh</td>
<td align=left>
 lathc high indication for 1 -> 0 transition on tx_fifo_ovfb signal from AFE/High Speed Phase FIFO. This is clear on read status.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_fifo_ovfb</td>
<td align=left>
 Indiactes live status of the tx_fifo_ovfb signal from AFE/High Speed Phase FIFO. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_PI_8x_pll2x_v1p0_tx_pi_status_5">TX_PI_8x_pll2x_v1p0_tx_pi_status_5 - TX Phase Interpolator Status 5</a></b><br>
Address Offset = 32'h0000_d0ae<br>
Physical Address = 32'h0000_d0ae<br>
Verilog CL45 Address = {`TX_PI_8x_pll2x_v1p0_A, `tx_pi_status_5_Adr}<br>
Verilog CL22 Address = {`TX_PI_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_status_5_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_pi_integ2_reg_s1</td>
<td align=left>
 TX PI integ2 register for the First Stage (s1 refers to first stage) jitter filter. Signed Value. Once settled, it can provide the information of the
ppm on the TX clock w.r.t. PLL/VCO clock. <br>
 +8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock. <br>
 Divide this register value by 10.485 to get the tclk ppm. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_8x_pll2x_v1p0 Registers">Return to TX_PI_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TX_PI_B_8x_pll2x_v1p0 Registers">TX_PI_B_8x_pll2x_v1p0: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd43e</td><td><A HREF="#TX_PI_B_8x_pll2x_v1p0_tx_pi_b_control_12">TX_PI_B_8x_pll2x_v1p0_tx_pi_b_control_12</A></td><td>TXPI INLC Control 12</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TX_PI_B_8x_pll2x_v1p0_tx_pi_b_control_12">TX_PI_B_8x_pll2x_v1p0_tx_pi_b_control_12 - TXPI INLC Control 12</a></b><br>
Address Offset = 32'h0000_d43e<br>
Physical Address = 32'h0000_d43e<br>
Verilog CL45 Address = {`TX_PI_B_8x_pll2x_v1p0_A, `tx_pi_b_control_12_Adr}<br>
Verilog CL22 Address = {`TX_PI_B_8x_pll2x_v1p0_A, 4'h0}, `tx_pi_b_control_12_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_first_order_bwsel_integ_s1</td>
<td align=left>
 First order bandwidth control. <br>
 3'd0 - 110 KHz <br>
 3'd1 - 220 KHz <br>
 3'd2 - 440 KHz <br>
 3'd3 - 880 KHz <br>
 3'd4 - 1.7 MHz <br>
 3'd5 -&nbsp 55 KHz <br>
 >= 3'd6 is unused and reserved for future use. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_freq_override_en_s1</td>
<td align=left>
 Enable for the frequency override mode for&nbsp First Stage Jitter filter.&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pi_jitter_filter_en_s1</td>
<td align=left>
 This enables the First Stage Jitter filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) . <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_PI_B_8x_pll2x_v1p0 Registers">Return to TX_PI_B_8x_pll2x_v1p0: per lane register block [8 copies] Table</A><p>
<H1><a NAME="SIGDET Registers">SIGDET: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd0e0</td><td><A HREF="#SIGDET_SIGDET_CTRL_0">SIGDET_SIGDET_CTRL_0</A></td><td>SIGDET_CTRL_0</td></tr>
<tr>
<td align=center>0xd0e1</td><td><A HREF="#SIGDET_SIGDET_CTRL_1">SIGDET_SIGDET_CTRL_1</A></td><td>SIGDET_CTRL_1</td></tr>
<tr>
<td align=center>0xd0e2</td><td><A HREF="#SIGDET_SIGDET_CTRL_2">SIGDET_SIGDET_CTRL_2</A></td><td>SIGDET_CTRL_2</td></tr>
<tr>
<td align=center>0xd0e8</td><td><A HREF="#SIGDET_SIGDET_STATUS_0">SIGDET_SIGDET_STATUS_0</A></td><td>SIGDET_STATUS_0</td></tr>
<tr>
<td align=center>0xd0e9</td><td><A HREF="#SIGDET_SIGDET_STATUS_1">SIGDET_SIGDET_STATUS_1</A></td><td>SIGDET_STATUS_1</td></tr>
<tr>
<td align=center>0xd0ea</td><td><A HREF="#SIGDET_SIGDET_STATUS_2">SIGDET_SIGDET_STATUS_2</A></td><td>SIGDET_STATUS_2</td></tr>
<tr>
<td align=center>0xd0eb</td><td><A HREF="#SIGDET_SIGDET_STATUS_3">SIGDET_SIGDET_STATUS_3</A></td><td>SIGDET_STATUS_3</td></tr>
<tr>
<td align=center>0xd0ec</td><td><A HREF="#SIGDET_SIGDET_STATUS_4">SIGDET_SIGDET_STATUS_4</A></td><td>SIGDET_STATUS_4</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="SIGDET_SIGDET_CTRL_0">SIGDET_SIGDET_CTRL_0 - SIGDET_CTRL_0</a></b><br>
Address Offset = 32'h0000_d0e0<br>
Physical Address = 32'h0000_d0e0<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_CTRL_0_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_CTRL_0_A<br>
Reset Value = 16'h1109<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>los_filter_count</td>
<td align=left>
 Defines the width of the signal_detect==1'b0 pulses which will be filtered out in the criteria for loss of signal. <br>
 Valid range is 0 to 31 which maps to 0 to 448 clock cycles. By default, these clock cycles are comclk cycles but&nbsp&nbsp <br>
 if signal_detect_filter_1us register field is set to 1, these clock cycles are 1us heartbeat clock cycles. <br>
 0:31 maps to (0:448) clock cycles as shown below <br>
&nbsp &nbsp 0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 0 clocks&nbsp <br>
&nbsp &nbsp 1	&nbsp &nbsp &nbsp&nbsp 1 clocks&nbsp <br>
&nbsp &nbsp 2	&nbsp &nbsp &nbsp&nbsp 2 clocks&nbsp <br>
&nbsp &nbsp 3	&nbsp &nbsp &nbsp&nbsp 3 clocks&nbsp <br>
&nbsp &nbsp 4	&nbsp &nbsp &nbsp&nbsp 4 clocks&nbsp <br>
&nbsp &nbsp 5	&nbsp &nbsp &nbsp&nbsp 5 clocks&nbsp <br>
&nbsp &nbsp 6	&nbsp &nbsp &nbsp&nbsp 6 clocks&nbsp <br>
&nbsp &nbsp 7	&nbsp &nbsp &nbsp&nbsp 7 clocks&nbsp <br>
&nbsp &nbsp 8	&nbsp &nbsp &nbsp&nbsp 8 clocks&nbsp <br>
&nbsp &nbsp 9	&nbsp &nbsp &nbsp 10 clocks&nbsp <br>
&nbsp&nbsp 10	&nbsp &nbsp &nbsp 12 clocks&nbsp <br>
&nbsp&nbsp 11	&nbsp &nbsp &nbsp 14 clocks&nbsp <br>
&nbsp&nbsp 12	&nbsp &nbsp &nbsp 16 clocks&nbsp <br>
&nbsp&nbsp 13	&nbsp &nbsp &nbsp 20 clocks&nbsp <br>
&nbsp&nbsp 14	&nbsp &nbsp &nbsp 24 clocks&nbsp <br>
&nbsp&nbsp 15	&nbsp &nbsp &nbsp 28 clocks&nbsp <br>
&nbsp&nbsp 16	&nbsp &nbsp &nbsp 32 clocks&nbsp <br>
&nbsp&nbsp 17	&nbsp &nbsp &nbsp 40 clocks&nbsp <br>
&nbsp&nbsp 18	&nbsp &nbsp &nbsp 48 clocks&nbsp <br>
&nbsp&nbsp 19	&nbsp &nbsp &nbsp 56 clocks&nbsp <br>
&nbsp&nbsp 20	&nbsp &nbsp &nbsp 64 clocks&nbsp <br>
&nbsp&nbsp 21	&nbsp &nbsp &nbsp 80 clocks&nbsp <br>
&nbsp&nbsp 22	&nbsp &nbsp &nbsp 96 clocks&nbsp <br>
&nbsp&nbsp 23	&nbsp &nbsp&nbsp 112 clocks&nbsp <br>
&nbsp&nbsp 24	&nbsp &nbsp&nbsp 128 clocks&nbsp <br>
&nbsp&nbsp 25	&nbsp &nbsp&nbsp 160 clocks&nbsp <br>
&nbsp&nbsp 26	&nbsp &nbsp&nbsp 192 clocks&nbsp <br>
&nbsp&nbsp 27	&nbsp &nbsp&nbsp 224 clocks&nbsp <br>
&nbsp&nbsp 28	&nbsp &nbsp&nbsp 256 clocks&nbsp <br>
&nbsp&nbsp 29	&nbsp &nbsp&nbsp 320 clocks&nbsp <br>
&nbsp&nbsp 30	&nbsp &nbsp&nbsp 384 clocks&nbsp <br>
&nbsp&nbsp 31	&nbsp &nbsp&nbsp 448 clocks&nbsp <br>
Reset value is 0x11.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>signal_detect_filter_count</td>
<td align=left>
 Defines the width of the signal_detect==1'b1 pulses which will be filtered out in the criteria for signal detect. <br>
 Valid range is 0 to 31 which maps to 0 to 448 comclk cycles. Refer to los_filter_count field for mapping. <br>
Reset value is 0x9.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_CTRL_1">SIGDET_SIGDET_CTRL_1 - SIGDET_CTRL_1</a></b><br>
Address Offset = 32'h0000_d0e1<br>
Physical Address = 32'h0000_d0e1<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_CTRL_1_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_CTRL_1_A<br>
Reset Value = 16'ha008<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>energy_detect_mask_count</td>
<td align=left>
 Defines the mask_count timer for energy_detect. Valid range is 0 to 31 <br>
 which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping. <br>
Reset value is 0x14.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>signal_detect_frc_val</td>
<td align=left>
 pmd_signal_detect Force Value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>signal_detect_frc</td>
<td align=left>
 pmd_signal_detect Force. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>energy_detect_frc_val</td>
<td align=left>
 pmd_energy_detect Force Value.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>energy_detect_frc</td>
<td align=left>
 pmd_energy_detect Force.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>signal_detect_filter_1us</td>
<td align=left>
 1'b1 will use 1us heartbeat for los_filter_count counter instead of comclk. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ignore_lp_mode</td>
<td align=left>
 1'b1 will ignore the pmd_rx_mode (low power mode) input pin. Set to 1'b0 if EEE mode is supported by the PCS<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ext_los_inv</td>
<td align=left>
 1'b1 will invert the polarity of the pmd_ext_los pin.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>ext_los_en</td>
<td align=left>
 1'b1 will enable the external (optical) LOS path into the sigdet filter.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>afe_signal_detect_dis</td>
<td align=left>
 1'b1 will disable the signal_detect from AFE.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_CTRL_2">SIGDET_SIGDET_CTRL_2 - SIGDET_CTRL_2</a></b><br>
Address Offset = 32'h0000_d0e2<br>
Physical Address = 32'h0000_d0e2<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_CTRL_2_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_CTRL_2_A<br>
Reset Value = 16'h3f22<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>hold_sd_count</td>
<td align=left>
 HOLD_SD state counter. Value 0 to 7 maps to 2 to 16 in increments of 2. <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>hold_los_count</td>
<td align=left>
 HOLD_LOS state counter. Value 0 to 7 maps to 2 to 16 in increments of 2. <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>signal_detect_thresh</td>
<td align=left>
 AFE signal detect threshold to be used when filtered signal_detect == 0.<br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>los_thresh</td>
<td align=left>
 AFE signal detect threshold to be used when filtered signal_detect == 1.<br>
Reset value is 0x2.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_STATUS_0">SIGDET_SIGDET_STATUS_0 - SIGDET_STATUS_0</a></b><br>
Address Offset = 32'h0000_d0e8<br>
Physical Address = 32'h0000_d0e8<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_STATUS_0_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_STATUS_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_sigdet_change</td>
<td align=left>
 This latches the transition on afe_sigdet and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_sigdet</td>
<td align=left>
 Internal sigdet from the AFE sigdet block going into the sigdet filter. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ext_sigdet_change</td>
<td align=left>
 This latches the transition on ext_sigdet and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>ext_sigdet</td>
<td align=left>
 External LOS/sigdet from the pin going into the sigdet filter. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>signal_detect_raw_change</td>
<td align=left>
 This latches the transition on signal_detect_raw and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>signal_detect_raw</td>
<td align=left>
 Raw version of Signal Detect going into the filter. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>signal_detect_change</td>
<td align=left>
 This latches the transition on signal_detect and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>signal_detect</td>
<td align=left>
 Filtered version of Signal Detect after frc/frc_val. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_STATUS_1">SIGDET_SIGDET_STATUS_1 - SIGDET_STATUS_1</a></b><br>
Address Offset = 32'h0000_d0e9<br>
Physical Address = 32'h0000_d0e9<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_STATUS_1_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_STATUS_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_afe_sigdet_change</td>
<td align=left>
 This latches the transition on uc_afe_sigdet and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_afe_sigdet</td>
<td align=left>
 Internal sigdet from the AFE sigdet block going into the sigdet filter. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_ext_sigdet_change</td>
<td align=left>
 This latches the transition on uc_ext_sigdet and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_ext_sigdet</td>
<td align=left>
 External LOS/sigdet from the pin going into the sigdet filter. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_signal_detect_change</td>
<td align=left>
 This latches the transition on uc_signal_detect and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_signal_detect</td>
<td align=left>
 Filtered version of Signal Detect after frc/frc_val. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_STATUS_2">SIGDET_SIGDET_STATUS_2 - SIGDET_STATUS_2</a></b><br>
Address Offset = 32'h0000_d0ea<br>
Physical Address = 32'h0000_d0ea<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_STATUS_2_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_STATUS_2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>energy_detect_change</td>
<td align=left>
 This latches the transition on energy_detect and cleared on read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>energy_detect</td>
<td align=left>
 Filtered version of Energy Detect after frc/frc_val. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_STATUS_3">SIGDET_SIGDET_STATUS_3 - SIGDET_STATUS_3</a></b><br>
Address Offset = 32'h0000_d0eb<br>
Physical Address = 32'h0000_d0eb<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_STATUS_3_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_STATUS_3_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pmd_signal_detect</td>
<td align=left>
 Filtered version of Signal Detect after frc/frc_val. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<b><a NAME="SIGDET_SIGDET_STATUS_4">SIGDET_SIGDET_STATUS_4 - SIGDET_STATUS_4</a></b><br>
Address Offset = 32'h0000_d0ec<br>
Physical Address = 32'h0000_d0ec<br>
Verilog CL45 Address = {`SIGDET_A, `SIGDET_STATUS_4_Adr}<br>
Verilog CL22 Address = {`SIGDET_A, 4'h0}, `SIGDET_STATUS_4_A<br>
Reset Value = 16'h0002<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>afe_sigdet_thresh</td>
<td align=left>
 Live status of sigdet_thresh going to AFE. <br>
Reset value is 0x2.</td></tr>
</table><p>
<A HREF="#SIGDET Registers">Return to SIGDET: per lane register block [8 copies] Table</A><p>
<H1><a NAME="PATT_GEN_COM Registers">PATT_GEN_COM: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd120</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_0">PATT_GEN_COM_patt_gen_seq_0</A></td><td>Pattern Generator Sequence Word 0</td></tr>
<tr>
<td align=center>0xd121</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_1">PATT_GEN_COM_patt_gen_seq_1</A></td><td>Pattern Generator Sequence Word 1</td></tr>
<tr>
<td align=center>0xd122</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_2">PATT_GEN_COM_patt_gen_seq_2</A></td><td>Pattern Generator Sequence Word 2</td></tr>
<tr>
<td align=center>0xd123</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_3">PATT_GEN_COM_patt_gen_seq_3</A></td><td>Pattern Generator Sequence Word 3</td></tr>
<tr>
<td align=center>0xd124</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_4">PATT_GEN_COM_patt_gen_seq_4</A></td><td>Pattern Generator Sequence Word 4</td></tr>
<tr>
<td align=center>0xd125</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_5">PATT_GEN_COM_patt_gen_seq_5</A></td><td>Pattern Generator Sequence Word 5</td></tr>
<tr>
<td align=center>0xd126</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_6">PATT_GEN_COM_patt_gen_seq_6</A></td><td>Pattern Generator Sequence Word 6</td></tr>
<tr>
<td align=center>0xd127</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_7">PATT_GEN_COM_patt_gen_seq_7</A></td><td>Pattern Generator Sequence Word 7</td></tr>
<tr>
<td align=center>0xd128</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_8">PATT_GEN_COM_patt_gen_seq_8</A></td><td>Pattern Generator Sequence Word 8</td></tr>
<tr>
<td align=center>0xd129</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_9">PATT_GEN_COM_patt_gen_seq_9</A></td><td>Pattern Generator Sequence Word 9</td></tr>
<tr>
<td align=center>0xd12a</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_10">PATT_GEN_COM_patt_gen_seq_10</A></td><td>Pattern Generator Sequence Word 10</td></tr>
<tr>
<td align=center>0xd12b</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_11">PATT_GEN_COM_patt_gen_seq_11</A></td><td>Pattern Generator Sequence Word 11</td></tr>
<tr>
<td align=center>0xd12c</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_12">PATT_GEN_COM_patt_gen_seq_12</A></td><td>Pattern Generator Sequence Word 12</td></tr>
<tr>
<td align=center>0xd12d</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_13">PATT_GEN_COM_patt_gen_seq_13</A></td><td>Pattern Generator Sequence Word 13</td></tr>
<tr>
<td align=center>0xd12e</td><td><A HREF="#PATT_GEN_COM_patt_gen_seq_14">PATT_GEN_COM_patt_gen_seq_14</A></td><td>Pattern Generator Sequence Word 14</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_0">PATT_GEN_COM_patt_gen_seq_0 - Pattern Generator Sequence Word 0</a></b><br>
Address Offset = 32'h0000_d120<br>
Physical Address = 32'h0000_d120<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_0_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_0_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_0</td>
<td align=left>
Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted
last. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_1">PATT_GEN_COM_patt_gen_seq_1 - Pattern Generator Sequence Word 1</a></b><br>
Address Offset = 32'h0000_d121<br>
Physical Address = 32'h0000_d121<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_1_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_1_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_1</td>
<td align=left>
Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_2">PATT_GEN_COM_patt_gen_seq_2 - Pattern Generator Sequence Word 2</a></b><br>
Address Offset = 32'h0000_d122<br>
Physical Address = 32'h0000_d122<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_2_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_2_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_2</td>
<td align=left>
Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_3">PATT_GEN_COM_patt_gen_seq_3 - Pattern Generator Sequence Word 3</a></b><br>
Address Offset = 32'h0000_d123<br>
Physical Address = 32'h0000_d123<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_3_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_3_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_3</td>
<td align=left>
Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_4">PATT_GEN_COM_patt_gen_seq_4 - Pattern Generator Sequence Word 4</a></b><br>
Address Offset = 32'h0000_d124<br>
Physical Address = 32'h0000_d124<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_4_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_4_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_4</td>
<td align=left>
Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_5">PATT_GEN_COM_patt_gen_seq_5 - Pattern Generator Sequence Word 5</a></b><br>
Address Offset = 32'h0000_d125<br>
Physical Address = 32'h0000_d125<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_5_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_5_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_5</td>
<td align=left>
Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_6">PATT_GEN_COM_patt_gen_seq_6 - Pattern Generator Sequence Word 6</a></b><br>
Address Offset = 32'h0000_d126<br>
Physical Address = 32'h0000_d126<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_6_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_6_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_6</td>
<td align=left>
Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_7">PATT_GEN_COM_patt_gen_seq_7 - Pattern Generator Sequence Word 7</a></b><br>
Address Offset = 32'h0000_d127<br>
Physical Address = 32'h0000_d127<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_7_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_7_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_7</td>
<td align=left>
Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_8">PATT_GEN_COM_patt_gen_seq_8 - Pattern Generator Sequence Word 8</a></b><br>
Address Offset = 32'h0000_d128<br>
Physical Address = 32'h0000_d128<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_8_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_8_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_8</td>
<td align=left>
Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_9">PATT_GEN_COM_patt_gen_seq_9 - Pattern Generator Sequence Word 9</a></b><br>
Address Offset = 32'h0000_d129<br>
Physical Address = 32'h0000_d129<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_9_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_9_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_9</td>
<td align=left>
Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_10">PATT_GEN_COM_patt_gen_seq_10 - Pattern Generator Sequence Word 10</a></b><br>
Address Offset = 32'h0000_d12a<br>
Physical Address = 32'h0000_d12a<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_10_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_10_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_10</td>
<td align=left>
Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_11">PATT_GEN_COM_patt_gen_seq_11 - Pattern Generator Sequence Word 11</a></b><br>
Address Offset = 32'h0000_d12b<br>
Physical Address = 32'h0000_d12b<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_11_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_11_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_11</td>
<td align=left>
Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_12">PATT_GEN_COM_patt_gen_seq_12 - Pattern Generator Sequence Word 12</a></b><br>
Address Offset = 32'h0000_d12c<br>
Physical Address = 32'h0000_d12c<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_12_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_12_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_12</td>
<td align=left>
Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_13">PATT_GEN_COM_patt_gen_seq_13 - Pattern Generator Sequence Word 13</a></b><br>
Address Offset = 32'h0000_d12d<br>
Physical Address = 32'h0000_d12d<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_13_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_13_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_13</td>
<td align=left>
Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<b><a NAME="PATT_GEN_COM_patt_gen_seq_14">PATT_GEN_COM_patt_gen_seq_14 - Pattern Generator Sequence Word 14</a></b><br>
Address Offset = 32'h0000_d12e<br>
Physical Address = 32'h0000_d12e<br>
Verilog CL45 Address = {`PATT_GEN_COM_A, `patt_gen_seq_14_Adr}<br>
Verilog CL22 Address = {`PATT_GEN_COM_A, 4'h0}, `patt_gen_seq_14_A<br>
Reset Value = 16'hff00<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_seq_14</td>
<td align=left>
Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted
first. <br>
Reset value is 0xff00.</td></tr>
</table><p>
<A HREF="#PATT_GEN_COM Registers">Return to PATT_GEN_COM: common register block for all lanes Table</A><p>
<H1><a NAME="TX_FED Registers">TX_FED: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd130</td><td><A HREF="#TX_FED_txfir_micro_control0">TX_FED_txfir_micro_control0</A></td><td>Micro Control 0 Register</td></tr>
<tr>
<td align=center>0xd131</td><td><A HREF="#TX_FED_txfir_misc_control0">TX_FED_txfir_misc_control0</A></td><td>Misc Control 0 Register</td></tr>
<tr>
<td align=center>0xd132</td><td><A HREF="#TX_FED_txfir_misc_status0">TX_FED_txfir_misc_status0</A></td><td>Misc Status 0 Register</td></tr>
<tr>
<td align=center>0xd133</td><td><A HREF="#TX_FED_txfir_tap_control0">TX_FED_txfir_tap_control0</A></td><td>txfir tap control 0 register</td></tr>
<tr>
<td align=center>0xd134</td><td><A HREF="#TX_FED_txfir_tap_control1">TX_FED_txfir_tap_control1</A></td><td>txfir tap control 1 register</td></tr>
<tr>
<td align=center>0xd135</td><td><A HREF="#TX_FED_txfir_tap_control2">TX_FED_txfir_tap_control2</A></td><td>txfir tap control 2 register</td></tr>
<tr>
<td align=center>0xd136</td><td><A HREF="#TX_FED_txfir_tap_control3">TX_FED_txfir_tap_control3</A></td><td>txfir tap control 3 register</td></tr>
<tr>
<td align=center>0xd137</td><td><A HREF="#TX_FED_txfir_tap_control4">TX_FED_txfir_tap_control4</A></td><td>txfir tap control 4 register</td></tr>
<tr>
<td align=center>0xd138</td><td><A HREF="#TX_FED_txfir_tap_control5">TX_FED_txfir_tap_control5</A></td><td>txfir tap control 5 register</td></tr>
<tr>
<td align=center>0xd139</td><td><A HREF="#TX_FED_txfir_tap_control6">TX_FED_txfir_tap_control6</A></td><td>txfir tap control 6 register</td></tr>
<tr>
<td align=center>0xd13a</td><td><A HREF="#TX_FED_txfir_tap_control7">TX_FED_txfir_tap_control7</A></td><td>txfir tap control 7 register</td></tr>
<tr>
<td align=center>0xd13b</td><td><A HREF="#TX_FED_txfir_tap_control8">TX_FED_txfir_tap_control8</A></td><td>txfir tap control 8 register</td></tr>
<tr>
<td align=center>0xd13c</td><td><A HREF="#TX_FED_txfir_tap_control9">TX_FED_txfir_tap_control9</A></td><td>txfir tap control 9 register</td></tr>
<tr>
<td align=center>0xd13d</td><td><A HREF="#TX_FED_txfir_tap_control10">TX_FED_txfir_tap_control10</A></td><td>txfir tap control 10 register</td></tr>
<tr>
<td align=center>0xd13e</td><td><A HREF="#TX_FED_txfir_tap_control11">TX_FED_txfir_tap_control11</A></td><td>txfir tap control 11 register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TX_FED_txfir_micro_control0">TX_FED_txfir_micro_control0 - Micro Control 0 Register</a></b><br>
Address Offset = 32'h0000_d130<br>
Physical Address = 32'h0000_d130<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_micro_control0_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_micro_control0_A<br>
Reset Value = 16'hc160<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_eee_alert_en</td>
<td align=left>
Tx eee alert mode control <br>
 1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b10 <br>
 0 - Disable eee alert mode <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_eee_quiet_en</td>
<td align=left>
Tx eee quiet mode control <br>
 1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b01 <br>
 0 - Disable eee quiet mode <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_disable_timer_ctrl</td>
<td align=left>
tx_disable timer value controls <br>
tx_disable_timer_ctrl[5] (MSB) selects the timer units <br>
0 - 2us units <br>
1 - 1ms units <br>
<br>
tx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units per <br>
the list below <br>
0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 units&nbsp <br>
1&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 units&nbsp <br>
2&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 2 units&nbsp <br>
3&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 3 units&nbsp <br>
4&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 4 units&nbsp <br>
5&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 5 units&nbsp <br>
6&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 6 units&nbsp <br>
7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 7 units&nbsp <br>
8&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 8 units&nbsp <br>
9&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 10 units&nbsp <br>
10&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 12 units&nbsp <br>
11&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 14 units&nbsp <br>
12&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 16 units&nbsp <br>
13&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 20 units&nbsp <br>
14&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 24 units&nbsp <br>
15&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 28 units&nbsp <br>
16&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 32 units&nbsp <br>
17&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 40 units&nbsp <br>
18&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 48 units&nbsp <br>
19&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 56 units&nbsp <br>
20&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 64 units&nbsp <br>
21&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 80 units&nbsp <br>
22&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 96 units&nbsp <br>
23&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 112 units&nbsp <br>
24&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 128 units&nbsp <br>
25&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 160 units&nbsp <br>
26&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 192 units&nbsp <br>
27&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 224 units&nbsp <br>
28&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 256 units&nbsp <br>
29&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 320 units&nbsp <br>
30&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 384 units&nbsp <br>
31&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 448 units&nbsp <br>
Reset value is 0x16.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pmd_tx_disable_pkill</td>
<td align=left>
 Tx disable using the pmd_tx_disable pin disable control <br>
 0 - enable tx disable from pmd_tx_disable pin <br>
 1 - disable tx disable from pmd_tx_disable pin <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dp_reset_tx_disable_dis</td>
<td align=left>
Tx disable based on data path reset<br>
 0 - Enable tx disable based on data path reset<br>
 1 - Disable tx disable based on data path reset<br>
&nbsp &nbsp&nbsp Need to set this bit to 1 if tx_disable_output_sel = 2'b01 (send TX power down).<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>tx_disable_trigger</td>
<td align=left>
Tx disable trigger <br>
When this bit is set to 1, it triggers a TX disable with timer starting at 0. <br>
No matter where the TX disable state is, it start a new timer and apply TX disable. <br>
This bit is self clearing <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_tx_disable</td>
<td align=left>
micro tx disable <br>
This field is used by the Microcontroller for tx disable control during CL93N72 forced mode <br>
Please see Falcon PMD Internal Functional Specification for details <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_misc_control0">TX_FED_txfir_misc_control0 - Misc Control 0 Register</a></b><br>
Address Offset = 32'h0000_d131<br>
Physical Address = 32'h0000_d131<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_misc_control0_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_misc_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_disable_output_sel</td>
<td align=left>
These bits select tx disable output function <br>
2'b00 - send electrical idles <br>
2'b01 - send power down <br>
2'b10 - send ones <br>
2'b11 - send zeroes <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sdk_tx_disable</td>
<td align=left>
sdk tx disable <br>
This tx disable control field is for SDK use during TX programming <br>
Please see Eagle & Merlin PMD Internal Functional Specification for details <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_misc_status0">TX_FED_txfir_misc_status0 - Misc Status 0 Register</a></b><br>
Address Offset = 32'h0000_d132<br>
Physical Address = 32'h0000_d132<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_misc_status0_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_misc_status0_A<br>
Reset Value = 16'h0003<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_elec_idle_status</td>
<td align=left>
tx electrical idle status <br>
When this bit is set it indicates the tx elecrticl idle active due to:<br>
 1) tx disable being programmed to send electrical idles or <br>
 2) An internal logic signal derived from PMD interface pins for EEE TX MODE <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tx_disable_status</td>
<td align=left>
tx disable status <br>
When this bit is set it indicates the tx_disable is active due to:<br>
 1) pin at AN/PCS to PMD Interface OR <br>
 2) dp_reset being asserted <br>
 3) register bit dedicated to micro use <br>
 4) register bit dedicated to SDK use <br>
 5) tx disable timer that guarntees minimum assertion time has not expired <br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control0">TX_FED_txfir_tap_control0 - txfir tap control 0 register</a></b><br>
Address Offset = 32'h0000_d133<br>
Physical Address = 32'h0000_d133<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control0_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control0_A<br>
Reset Value = 16'h3000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_test_data_en</td>
<td align=left>
txfir DAC test data enable <br>
1 - Test mode. Enables test data path from the DAC memory to the DAC for characterization<br>
"0 - Normal modes. TXFIR DAC driver is used to drive the DAC.<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap_en</td>
<td align=left>
txfir taps enable <br>
2'd0 - tap2:tap0 <br>
2'd1 - tap5:tap0 <br>
2'd2 - tap8:tap0 <br>
2'd3 - tap11:tap0 <br>
Reset value is 3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>txfir_tap_load</td>
<td align=left>
Load txfir tap values <br>
The sequence to load the taps is: <br>
1) set taps values in the txfir_tap*_coeff fields as needed <br>
2) set txfir_tap_load field to 1'b1.&nbsp <br>
This field is self-clearing, always read-back 0 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_nrz_tap_range_sel</td>
<td align=left>
TXFIR NRZ tap range select <br>
 0 - PAM4 tap range -170..+170 <br>
 1 - NRZ tap range -127..+127 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap0_coeff</td>
<td align=left>
TXFIR tap 0 coeffient values in signed 2's complement format <br>
tap range: -170 to +170 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -127 to +127 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control1">TX_FED_txfir_tap_control1 - txfir tap control 1 register</a></b><br>
Address Offset = 32'h0000_d134<br>
Physical Address = 32'h0000_d134<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control1_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap1_coeff</td>
<td align=left>
TXFIR tap 1 coeffient values in signed 2's complement format <br>
tap range: -170 to +170 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -127 to +127 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control2">TX_FED_txfir_tap_control2 - txfir tap control 2 register</a></b><br>
Address Offset = 32'h0000_d135<br>
Physical Address = 32'h0000_d135<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control2_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control2_A<br>
Reset Value = 16'h00a8<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap2_coeff</td>
<td align=left>
TXFIR tap 2 coeffient values in signed 2's complement format <br>
tap range: -170 to +170 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -127 to +127 in NRZ mode&nbsp &nbsp <br>
Reset value is 0xa8.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control3">TX_FED_txfir_tap_control3 - txfir tap control 3 register</a></b><br>
Address Offset = 32'h0000_d136<br>
Physical Address = 32'h0000_d136<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control3_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap3_coeff</td>
<td align=left>
TXFIR tap 3 coeffient values in signed 2's complement format <br>
tap range: -170 to +170 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -127 to +127 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control4">TX_FED_txfir_tap_control4 - txfir tap control 4 register</a></b><br>
Address Offset = 32'h0000_d137<br>
Physical Address = 32'h0000_d137<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control4_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control4_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap4_coeff</td>
<td align=left>
TXFIR tap 4 coeffient values in signed 2's complement format <br>
tap range: -170 to +170 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -127 to +127 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control5">TX_FED_txfir_tap_control5 - txfir tap control 5 register</a></b><br>
Address Offset = 32'h0000_d138<br>
Physical Address = 32'h0000_d138<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control5_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control5_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap5_coeff</td>
<td align=left>
TXFIR tap 5 coeffient values in signed 2's complement format <br>
tap range: -170 to +170 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -127 to +127 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control6">TX_FED_txfir_tap_control6 - txfir tap control 6 register</a></b><br>
Address Offset = 32'h0000_d139<br>
Physical Address = 32'h0000_d139<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control6_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control6_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_level_shift_mode_en</td>
<td align=left>
Level shifting enable. Level shifting is achieved by re-purposing <br>
the last 6 taps such that taps 6-8 provide level adjustment for <br>
level = 3 and Taps 9-11 for level = -3 <br>
1 - enabled <br>
0 - disabled <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_dc_adjust</td>
<td align=left>
This field specify the amount of DC offset added to TXFIR output <br>
The range is -64 to +63 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap6_coeff</td>
<td align=left>
TXFIR tap 6 coeffient values in signed 2's complement format <br>
tap range: -64 to +63 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -24 to +23 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control7">TX_FED_txfir_tap_control7 - txfir tap control 7 register</a></b><br>
Address Offset = 32'h0000_d13a<br>
Physical Address = 32'h0000_d13a<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control7_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control7_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap7_coeff</td>
<td align=left>
TXFIR tap 7 coeffient values in signed 2's complement format <br>
tap range: -64 to +63 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -24 to +23 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control8">TX_FED_txfir_tap_control8 - txfir tap control 8 register</a></b><br>
Address Offset = 32'h0000_d13b<br>
Physical Address = 32'h0000_d13b<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control8_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control8_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap8_coeff</td>
<td align=left>
TXFIR tap 8 coeffient values in signed 2's complement format <br>
tap range: -64 to +63 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -24 to +23 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control9">TX_FED_txfir_tap_control9 - txfir tap control 9 register</a></b><br>
Address Offset = 32'h0000_d13c<br>
Physical Address = 32'h0000_d13c<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control9_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control9_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap9_coeff</td>
<td align=left>
TXFIR tap 9 coeffient values in signed 2's complement format <br>
tap range: -64 to +63 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -24 to +23 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control10">TX_FED_txfir_tap_control10 - txfir tap control 10 register</a></b><br>
Address Offset = 32'h0000_d13d<br>
Physical Address = 32'h0000_d13d<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control10_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control10_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap10_coeff</td>
<td align=left>
TXFIR tap 10 coeffient values in signed 2's complement format <br>
tap range: -64 to +63 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -24 to +23 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<b><a NAME="TX_FED_txfir_tap_control11">TX_FED_txfir_tap_control11 - txfir tap control 11 register</a></b><br>
Address Offset = 32'h0000_d13e<br>
Physical Address = 32'h0000_d13e<br>
Verilog CL45 Address = {`TX_FED_A, `txfir_tap_control11_Adr}<br>
Verilog CL22 Address = {`TX_FED_A, 4'h0}, `txfir_tap_control11_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txfir_tap11_coeff</td>
<td align=left>
TXFIR tap 11 coeffient values in signed 2's complement format <br>
tap range: -64 to +63 in PAM4 mode <br>
&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp -24 to +23 in NRZ mode&nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TX_FED Registers">Return to TX_FED: per lane register block [8 copies] Table</A><p>
<H1><a NAME="PLL_CAL_COM Registers">PLL_CAL_COM: common register block per PLL [2 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd140</td><td><A HREF="#PLL_CAL_COM_CTL_0">PLL_CAL_COM_CTL_0</A></td><td>PLL CAL Configuration Registers 0.</td></tr>
<tr>
<td align=center>0xd141</td><td><A HREF="#PLL_CAL_COM_CTL_1">PLL_CAL_COM_CTL_1</A></td><td>PLL CAL Configuration Registers 1.</td></tr>
<tr>
<td align=center>0xd142</td><td><A HREF="#PLL_CAL_COM_CTL_2">PLL_CAL_COM_CTL_2</A></td><td>PLL CAL Configuration Registers 2.</td></tr>
<tr>
<td align=center>0xd143</td><td><A HREF="#PLL_CAL_COM_CTL_3">PLL_CAL_COM_CTL_3</A></td><td>PLL CAL Configuration Registers 3.</td></tr>
<tr>
<td align=center>0xd144</td><td><A HREF="#PLL_CAL_COM_CTL_4">PLL_CAL_COM_CTL_4</A></td><td>PLL CAL Configuration Registers 4.</td></tr>
<tr>
<td align=center>0xd145</td><td><A HREF="#PLL_CAL_COM_CTL_5">PLL_CAL_COM_CTL_5</A></td><td>PLL CAL Configuration Registers 5.</td></tr>
<tr>
<td align=center>0xd146</td><td><A HREF="#PLL_CAL_COM_CTL_6">PLL_CAL_COM_CTL_6</A></td><td>PLL CAL Configuration Registers 6.</td></tr>
<tr>
<td align=center>0xd147</td><td><A HREF="#PLL_CAL_COM_CTL_7">PLL_CAL_COM_CTL_7</A></td><td>PLL CAL Configuration Registers 7.</td></tr>
<tr>
<td align=center>0xd148</td><td><A HREF="#PLL_CAL_COM_CTL_STATUS_0">PLL_CAL_COM_CTL_STATUS_0</A></td><td>PLL CAL status registers register.</td></tr>
<tr>
<td align=center>0xd149</td><td><A HREF="#PLL_CAL_COM_CTL_STATUS_1">PLL_CAL_COM_CTL_STATUS_1</A></td><td>PLL CAL status registers register.</td></tr>
<tr>
<td align=center>0xd14a</td><td><A HREF="#PLL_CAL_COM_CTL_STATUS_DBG">PLL_CAL_COM_CTL_STATUS_DBG</A></td><td>PLL CAL debug status registers register.</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_0">PLL_CAL_COM_CTL_0 - PLL CAL Configuration Registers 0.</a></b><br>
Address Offset = 32'h0000_d140<br>
Physical Address = 32'h0000_d140<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_0_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_0_A<br>
Reset Value = 16'hc803<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vco_start_time</td>
<td align=left>
VCO powerup wait time<br>
Reset value is 0xc8.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vco_step_time</td>
<td align=left>
VCO time between iterations<br>
Reset value is 0x3.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_1">PLL_CAL_COM_CTL_1 - PLL CAL Configuration Registers 1.</a></b><br>
Address Offset = 32'h0000_d141<br>
Physical Address = 32'h0000_d141<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_1_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_1_A<br>
Reset Value = 16'hc8ff<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pre_freq_det_time</td>
<td align=left>
wait time prior to freq det <br>
Reset value is 0xc8.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>retry_time</td>
<td align=left>
retry wait time&nbsp <br>
Reset value is 0xff.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_2">PLL_CAL_COM_CTL_2 - PLL CAL Configuration Registers 2.</a></b><br>
Address Offset = 32'h0000_d142<br>
Physical Address = 32'h0000_d142<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_2_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_2_A<br>
Reset Value = 16'hff01<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>res_cal_cntr</td>
<td align=left>
freq. counter's 8-msbits starting value <br>
Reset value is 0xff.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>win_cal_cntr</td>
<td align=left>
freq. counter's 8-lsbits stoping value <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_3">PLL_CAL_COM_CTL_3 - PLL CAL Configuration Registers 3.</a></b><br>
Address Offset = 32'h0000_d143<br>
Physical Address = 32'h0000_d143<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_3_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_select_m</td>
<td align=left>
Manual vco cap value (i.e pll_range[7:0])<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_select_m_en</td>
<td align=left>
Manual vco cap value mode, force using pll_range force value<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_force_slowdown_en</td>
<td align=left>
slowdown force enable&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_force_slowdown</td>
<td align=left>
slowdown force value&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_retry_en</td>
<td align=left>
enable retry on cap search failure<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_restart</td>
<td align=left>
force cap sequencer to restart, set to high then low<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_seq_cya</td>
<td align=left>
cya bit to revert cap sequencer back to original hyper/xaui sequence<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>cap_cnt_mask_en</td>
<td align=left>
masks cap count to allow control of max value<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>fast_search_mode</td>
<td align=left>
force cap sequencer using select_m value for fast searching<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_4">PLL_CAL_COM_CTL_4 - PLL CAL Configuration Registers 4.</a></b><br>
Address Offset = 32'h0000_d144<br>
Physical Address = 32'h0000_d144<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_4_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_4_A<br>
Reset Value = 16'ha80d<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_seq_start</td>
<td align=left>
start pll sequencer by writing to 1'b0 followed by writing to 1'b1. For debug only, use core_dp_s/h_rstb to restart PLL calibration<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vco_done_en</td>
<td align=left>
enable vco_done status bit<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>freq_det_retry_en</td>
<td align=left>
enable retry on freq det failure<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>freq_det_restart_en</td>
<td align=left>
enable restart when not freq locked<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>freq_monitor_en</td>
<td align=left>
continuously monitor vco freq<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>slowdn_xor</td>
<td align=left>
invert sense of the slowdn/pll_low input from AFE<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vco_rst_en</td>
<td align=left>
enable pll reset when state machine is in start state. For debug only, use core_dp_s/h_rstb to restart PLL calibration<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_fdone_en</td>
<td align=left>
enable pllforcefdone & pllforcefpass into pllseq<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_fdone</td>
<td align=left>
force freqdone<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_fpass</td>
<td align=left>
force freqpass<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_cap_done_en</td>
<td align=left>
enable pllforcecapdone<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_cap_done</td>
<td align=left>
force capdone<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_cap_pass_en</td>
<td align=left>
enable pllforcecappass<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_force_cap_pass</td>
<td align=left>
force cappass<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_lock_frc</td>
<td align=left>
force pll lock<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_lock_frc_val</td>
<td align=left>
force pll lock value<br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_5">PLL_CAL_COM_CTL_5 - PLL CAL Configuration Registers 5.</a></b><br>
Address Offset = 32'h0000_d145<br>
Physical Address = 32'h0000_d145<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_5_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_5_A<br>
Reset Value = 16'h0027<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dec_search_en</td>
<td align=left>
VCO range decremental search enable control. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>refclk_divcnt</td>
<td align=left>
Refclk Divider Count to generate a slower divided refclk enable pulse for the PLL calibration logic. <br>
Most of the PLL calibration logic including PLL calibration state machines uses this divided version of the refclk clock signal.<br>
PLL calibration time is proportional to this register value.<br>
Reset value is 0x27.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_6">PLL_CAL_COM_CTL_6 - PLL CAL Configuration Registers 6.</a></b><br>
Address Offset = 32'h0000_d146<br>
Physical Address = 32'h0000_d146<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_6_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_6_A<br>
Reset Value = 16'h0007<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vco_range_adjust_en</td>
<td align=left>
enable vco_range_adjust by hardware when set to 1<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>vco_range_adjust</td>
<td align=left>
signed 2's complement vco_range_offset value to be added to vco_range to AFE. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>refclk_divcnt_sel</td>
<td align=left>
Refclk Divider Mode Select. <br>
Value 7: will select refclk_divcnt[13:0] as refclk divider value which has max value of 16383.<br>
Value 0 to 6 are reserved for future use and should not be selected. <br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_7">PLL_CAL_COM_CTL_7 - PLL CAL Configuration Registers 7.</a></b><br>
Address Offset = 32'h0000_d147<br>
Physical Address = 32'h0000_d147<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_7_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_7_A<br>
Reset Value = 16'h0007<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rescal_frc</td>
<td align=left>
rescal force to use rescal force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rescal_frc_val</td>
<td align=left>
rescal force value. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pll_mode</td>
<td align=left>
PLL Multiplier.<br>
"00000&nbsp = 64;<br>
"00001&nbsp = 66;<br>
"00010&nbsp = 80;<br>
"00011&nbsp = 128;<br>
"00100&nbsp = 132;<br>
"00101&nbsp = 140;<br>
"00110&nbsp = 160;<br>
"00111&nbsp = 165;<br>
"01000&nbsp = 168;<br>
"01001&nbsp = 170;<br>
"01010&nbsp = 175;<br>
"01011&nbsp = 180;<br>
"01100&nbsp = 184;<br>
"01101&nbsp = 200;<br>
"01110&nbsp = 224;<br>
"01111&nbsp = 264;<br>
"10000&nbsp = 96;<br>
"10001&nbsp = 120;<br>
"10010&nbsp = 144;<br>
"10011&nbsp = 198'<br>
Reset value is 0x7.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_STATUS_0">PLL_CAL_COM_CTL_STATUS_0 - PLL CAL status registers register.</a></b><br>
Address Offset = 32'h0000_d148<br>
Physical Address = 32'h0000_d148<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_STATUS_0_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_STATUS_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>lost_pll_lock_sm</td>
<td align=left>
status bit indicating pll_lock was lost, clear on read<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cap_done</td>
<td align=left>
status indicating cap sequencer is done<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cap_pass</td>
<td align=left>
status indicating cap value was found<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>freq_done_sm</td>
<td align=left>
status bit indicating freq det is done<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>freq_pass_sm</td>
<td align=left>
status bit indicating frequency lock<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_seq_done</td>
<td align=left>
status bit indicating pll sequencer is done<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_seq_pass</td>
<td align=left>
status bit indicating pll sequencer finised successfully<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_lock</td>
<td align=left>
status bit indicating PLL is locked<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cap_done_lh_ll</td>
<td align=left>
indicates change on cap_done status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cap_pass_lh_ll</td>
<td align=left>
indicates change on cap_pass status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>freq_done_sm_lh_ll</td>
<td align=left>
indicates change on freq_done_sm status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>freq_pass_sm_lh_ll</td>
<td align=left>
indicates change on freq_pass_sm status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_seq_done_lh_ll</td>
<td align=left>
indicates change on pll_seq_done status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_seq_pass_lh_ll</td>
<td align=left>
indicates change on pll_seq_pass status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pll_lock_lh_ll</td>
<td align=left>
indicates change on pll_lock status bit. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_STATUS_1">PLL_CAL_COM_CTL_STATUS_1 - PLL CAL status registers register.</a></b><br>
Address Offset = 32'h0000_d149<br>
Physical Address = 32'h0000_d149<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_STATUS_1_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_STATUS_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rescal_in</td>
<td align=left>
rescal input value<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>cap_select</td>
<td align=left>
status bit indicating the selected cap value (i.e. pll_range[7:0])<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<b><a NAME="PLL_CAL_COM_CTL_STATUS_DBG">PLL_CAL_COM_CTL_STATUS_DBG - PLL CAL debug status registers register.</a></b><br>
Address Offset = 32'h0000_d14a<br>
Physical Address = 32'h0000_d14a<br>
Verilog CL45 Address = {`PLL_CAL_COM_A, `CTL_STATUS_DBG_Adr}<br>
Verilog CL22 Address = {`PLL_CAL_COM_A, 4'h0}, `CTL_STATUS_DBG_A<br>
Reset Value = 16'h0001<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_pll_state_one_hot</td>
<td align=left>
Indicates one hot encoded PLL Sequence State Machines states. clear on read register.<br>
"Following are the one-hot state assignments.<br>
 <br>
State&nbsp&nbsp dbg_pll_state_one_hot[x] where x is : <br>
==============================================<br>
Start&nbsp &nbsp &nbsp &nbsp &nbsp 0 <br>
WaitVco&nbsp &nbsp &nbsp &nbsp 1 <br>
VcoAdjust&nbsp &nbsp &nbsp 2 <br>
WaitFreq&nbsp &nbsp &nbsp&nbsp 3 <br>
FreqDet&nbsp &nbsp &nbsp &nbsp 4 <br>
Fail&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 5 <br>
FreqMon&nbsp &nbsp &nbsp &nbsp 6 <br>
Finish&nbsp &nbsp &nbsp &nbsp&nbsp 7 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_cap_state_one_hot</td>
<td align=left>
Indicates one hot encoded Cap Sequence State Machines states. clear on read register.<br>
Following are the one-hot state assignments.<br>
 <br>
State&nbsp &nbsp dbg_cap_state_one_hot[x] where x is : <br>
================================================== <br>
Start&nbsp &nbsp &nbsp &nbsp &nbsp 0 <br>
WaitAmpL&nbsp &nbsp &nbsp&nbsp 1 <br>
WaitSpeedL&nbsp &nbsp&nbsp 2 <br>
IncCapL&nbsp &nbsp &nbsp &nbsp 3 <br>
Finish&nbsp &nbsp &nbsp &nbsp&nbsp 4 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_fdbck</td>
<td align=left>
Indicates change on AFE fdbck output signal. clear on read status register.<br>
Will be used to see if fdbck clock from AFE is toggling and alive<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_slowdn_change</td>
<td align=left>
Indicates change on AFE pll_low/slowdn output signal. It is clear on read status register<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_slowdn</td>
<td align=left>
Indicates AFE pll_low/slowdn output signal status. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#PLL_CAL_COM Registers">Return to PLL_CAL_COM: common register block per PLL [2 copies] Table</A><p>
<H1><a NAME="TXCOM Registers">TXCOM: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd152</td><td><A HREF="#TXCOM_txcom_control2_register">TXCOM_txcom_control2_register</A></td><td>TX common control 2 register</td></tr>
<tr>
<td align=center>0xd153</td><td><A HREF="#TXCOM_txcom_control3_register">TXCOM_txcom_control3_register</A></td><td>TX common control 3 register</td></tr>
<tr>
<td align=center>0xd154</td><td><A HREF="#TXCOM_txcom_control4_register">TXCOM_txcom_control4_register</A></td><td>TX common control 4 register</td></tr>
<tr>
<td align=center>0xd155</td><td><A HREF="#TXCOM_txcom_control5_register">TXCOM_txcom_control5_register</A></td><td>TX common control 5 register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TXCOM_txcom_control2_register">TXCOM_txcom_control2_register - TX common control 2 register</a></b><br>
Address Offset = 32'h0000_d152<br>
Physical Address = 32'h0000_d152<br>
Verilog CL45 Address = {`TXCOM_A, `txcom_control2_register_Adr}<br>
Verilog CL22 Address = {`TXCOM_A, 4'h0}, `txcom_control2_register_A<br>
Reset Value = 16'h01f4<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txcom_linktrn_max_wait_timer_period</td>
<td align=left>
 Maximum Training Time in ms<br>
 Period/range is 500 ms <br>
Reset value is 0x1f4.</td></tr>
</table><p>
<A HREF="#TXCOM Registers">Return to TXCOM: common register block for all lanes Table</A><p>
<b><a NAME="TXCOM_txcom_control3_register">TXCOM_txcom_control3_register - TX common control 3 register</a></b><br>
Address Offset = 32'h0000_d153<br>
Physical Address = 32'h0000_d153<br>
Verilog CL45 Address = {`TXCOM_A, `txcom_control3_register_Adr}<br>
Verilog CL22 Address = {`TXCOM_A, 4'h0}, `txcom_control3_register_A<br>
Reset Value = 16'h00c8<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txcom_linktrn_wait_cntr_limit</td>
<td align=left>
 Period/range is 100-300 frames <br>
 Period to keep transiming frames after the local device has completed training<br>
 The units are training pages.<br>
Reset value is 0xc8.</td></tr>
</table><p>
<A HREF="#TXCOM Registers">Return to TXCOM: common register block for all lanes Table</A><p>
<b><a NAME="TXCOM_txcom_control4_register">TXCOM_txcom_control4_register - TX common control 4 register</a></b><br>
Address Offset = 32'h0000_d154<br>
Physical Address = 32'h0000_d154<br>
Verilog CL45 Address = {`TXCOM_A, `txcom_control4_register_Adr}<br>
Verilog CL22 Address = {`TXCOM_A, 4'h0}, `txcom_control4_register_A<br>
Reset Value = 16'h05dc<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txcom_linktrn_max_wait_timer_period_2ndset</td>
<td align=left>
 Maximum Training Time in ms<br>
 Period/range is 500 ms for Eternet<br>
 Period/range is 1.5s for Fibre Channel<br>
 Second copy to allow for different training times for 10G,25G and Fibre channel links <br>
 The defaults are set to for Fibre channel <br>
Reset value is 0x5dc.</td></tr>
</table><p>
<A HREF="#TXCOM Registers">Return to TXCOM: common register block for all lanes Table</A><p>
<b><a NAME="TXCOM_txcom_control5_register">TXCOM_txcom_control5_register - TX common control 5 register</a></b><br>
Address Offset = 32'h0000_d155<br>
Physical Address = 32'h0000_d155<br>
Verilog CL45 Address = {`TXCOM_A, `txcom_control5_register_Adr}<br>
Verilog CL22 Address = {`TXCOM_A, 4'h0}, `txcom_control5_register_A<br>
Reset Value = 16'h01b8<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>txcom_linktrn_wait_cntr_limit_2ndset</td>
<td align=left>
 Period/range is 32us-96us (220-660 frames) for Fiber channel <br>
 Period/range is 100-300 frames for Ethernet<br>
 Period to keep transmiting frames after the local device has completed training<br>
 The units are training pages. Second copy to allow for different training times for 10G, 25G and fibre channel links <br>
 The defaults are set to for Fibre channel <br>
Reset value is 0x1b8.</td></tr>
</table><p>
<A HREF="#TXCOM Registers">Return to TXCOM: common register block for all lanes Table</A><p>
<H1><a NAME="TLB_RX Registers">TLB_RX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd160</td><td><A HREF="#TLB_RX_prbs_chk_cnt_config">TLB_RX_prbs_chk_cnt_config</A></td><td>PRBS Checker Count Control</td></tr>
<tr>
<td align=center>0xd161</td><td><A HREF="#TLB_RX_prbs_chk_config">TLB_RX_prbs_chk_config</A></td><td>PRBS Checker Control</td></tr>
<tr>
<td align=center>0xd162</td><td><A HREF="#TLB_RX_dig_lpbk_config">TLB_RX_dig_lpbk_config</A></td><td>Digital Loopback Control</td></tr>
<tr>
<td align=center>0xd163</td><td><A HREF="#TLB_RX_tlb_rx_misc_config">TLB_RX_tlb_rx_misc_config</A></td><td>TLB RX Misc. Control</td></tr>
<tr>
<td align=center>0xd164</td><td><A HREF="#TLB_RX_prbs_chk_en_timer_control">TLB_RX_prbs_chk_en_timer_control</A></td><td>TLB RX PRBS Checker Enable Timer Control</td></tr>
<tr>
<td align=center>0xd165</td><td><A HREF="#TLB_RX_prbs_chk_burst_err_cnt_status">TLB_RX_prbs_chk_burst_err_cnt_status</A></td><td>PRBS Checker Burst Error Counter Status</td></tr>
<tr>
<td align=center>0xd166</td><td><A HREF="#TLB_RX_dbg_pmd_rx_lock_status">TLB_RX_dbg_pmd_rx_lock_status</A></td><td>Debug PMD RX LOCK Status</td></tr>
<tr>
<td align=center>0xd167</td><td><A HREF="#TLB_RX_uc_pmd_rx_lock_status">TLB_RX_uc_pmd_rx_lock_status</A></td><td>Debug PMD RX LOCK Status</td></tr>
<tr>
<td align=center>0xd168</td><td><A HREF="#TLB_RX_dig_lpbk_pd_status">TLB_RX_dig_lpbk_pd_status</A></td><td>Digital Loopback Status</td></tr>
<tr>
<td align=center>0xd169</td><td><A HREF="#TLB_RX_prbs_chk_lock_status">TLB_RX_prbs_chk_lock_status</A></td><td>PRBS Checker LOCK Status</td></tr>
<tr>
<td align=center>0xd16a</td><td><A HREF="#TLB_RX_prbs_chk_err_cnt_msb_status">TLB_RX_prbs_chk_err_cnt_msb_status</A></td><td>PRBS Checker Error Counter MSB Status</td></tr>
<tr>
<td align=center>0xd16b</td><td><A HREF="#TLB_RX_prbs_chk_err_cnt_lsb_status">TLB_RX_prbs_chk_err_cnt_lsb_status</A></td><td>PRBS Checker Error Counter LSB Status</td></tr>
<tr>
<td align=center>0xd16c</td><td><A HREF="#TLB_RX_pmd_rx_lock_status">TLB_RX_pmd_rx_lock_status</A></td><td>PMD RX LOCK Status</td></tr>
<tr>
<td align=center>0xd16d</td><td><A HREF="#TLB_RX_prbs_burst_err_length_status">TLB_RX_prbs_burst_err_length_status</A></td><td>PRBS Burst Error Length Status</td></tr>
<tr>
<td align=center>0xd16e</td><td><A HREF="#TLB_RX_max_prbs_burst_err_length_status">TLB_RX_max_prbs_burst_err_length_status</A></td><td>PRBS Burst Error Maximum Length Status</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_cnt_config">TLB_RX_prbs_chk_cnt_config - PRBS Checker Count Control</a></b><br>
Address Offset = 32'h0000_d160<br>
Physical Address = 32'h0000_d160<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_cnt_config_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_cnt_config_A<br>
Reset Value = 16'h8602<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_trn_active_auto_mode_en</td>
<td align=left>
 1'b1 will forcefully disable the below described RX datapath functions automatically while RX Link Training is enabled and active irrespective of the
below register bit settings . <br>
&nbsp&nbsp - PAM4 Gray Decoder&nbsp &nbsp &nbsp &nbsp&nbsp (enabled by field pam4_gray_dec_en&nbsp &nbsp &nbsp&nbsp ) <br>
&nbsp&nbsp - PAM4 Decoder&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp (enabled by field pam4_decoder_en&nbsp &nbsp &nbsp &nbsp ) <br>
&nbsp&nbsp - PAM4 Symbol bit-swap&nbsp &nbsp &nbsp (enabled by field pam4_rx_symbol_bit_swap) <br>
&nbsp&nbsp - PAM4 Back Channel Decoder (enabled by field bc_dec_en&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp ) <br>
&nbsp&nbsp - PAM4 Descrambler&nbsp &nbsp &nbsp &nbsp &nbsp (enabled by field rx_descrambler_en&nbsp &nbsp &nbsp ) <br>
&nbsp&nbsp - NRZ&nbsp Differential Decoder (enabled by field tlb_rx_diff_dec_en&nbsp &nbsp&nbsp ) <br>
 1'b0 will ignore the control signal from RX Link Training and the above RX datapath functions will be enabled based on their individual enable bits irrespective
of the RX training status where enabled or disabled.&nbsp <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_ool_cnt</td>
<td align=left>
 specifies the number of consecutive valid clock cycles with 1 or more bit errors&nbsp <br>
 for PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where&nbsp <br>
 0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors. <br>
 likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors. <br>
Reset value is 0x6.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_lock_cnt</td>
<td align=left>
 specifies the number of consecutive valid clock cycles without any bit error <br>
 for PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where&nbsp <br>
 0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error. <br>
 likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error. <br>
Reset value is 0x2.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_config">TLB_RX_prbs_chk_config - PRBS Checker Control</a></b><br>
Address Offset = 32'h0000_d161<br>
Physical Address = 32'h0000_d161<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_config_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_config_A<br>
Reset Value = 16'h012a<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_burst_err_cnt_en</td>
<td align=left>
PRBS checker burst error count mode enable. <br>
&nbsp &nbsp&nbsp 1'b1 will enable the PRBS checker burst error count mode. It should be enabled for prbs_chk_burst_err_cnt counter . <br>
&nbsp &nbsp&nbsp Make sure that only one of the 2 register settings ((prbs_chk_en_timer_mode >=2 & prbs_chk_en_timeout > 0) and prbs_chk_burst_err_cnt_en)
are TRUE at any given time and not simultaneously TRUE. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_mode_sel_msb</td>
<td align=left>
 Extending PRBS polynomial select by using this bit as bit[3] alongwith prbs_chk_mode_sel[2:0]. <br>
 1'b0 will select old PRBS polynomials for PRBS 7, 9, 11, 15, 23, 31, 49 and 58 based on prbs_chk_mode_sel[2:0]. <br>
 1'b1 will select new PRBS polynomials for PRBS 10, 20, 13 for PAM4 based on prbs_chk_mode_sel[2:0]. <br>
 1'b1 & prbs_chk_mode_sel[2:0] == 0 will select PRBS 10. <br>
 1'b1 & prbs_chk_mode_sel[2:0] == 1 will select PRBS 20. <br>
 1'b1 & prbs_chk_mode_sel[2:0] == 2 will select PRBS 13. <br>
 1'b1 & prbs_chk_mode_sel[2:0] == 2 will select PRBS 13&nbsp with polynomial (1+x^1+x^2+x^12+x^13). This pattern is also used for PAM4 Link Training Lane
0 pattern. <br>
 1'b1 & prbs_chk_mode_sel[2:0] == 3 is reserved for future use. <br>
 1'b1 & prbs_chk_mode_sel[2:0] == 4 will select PAM4 Link Training Lane 1 PRBS 13&nbsp polynomial (1 + x2 + x3 + x7&nbsp + x13). Debug modes.<br>
 1'b1 & prbs_chk_mode_sel[2:0] == 5 will select PAM4 Link Training Lane 2 PRBS 13&nbsp polynomial (1 + x2 + x4 + x8&nbsp + x13). Debug modes.<br>
 1'b1 & prbs_chk_mode_sel[2:0] == 6 will select PAM4 Link Training Lane 3 PRBS 13&nbsp polynomial (1 + x2 + x5 + x9&nbsp + x13). Debug modes.<br>
 1'b1 & prbs_chk_mode_sel[2:0] == 7 is reserved for future use. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_clk_en_frc_on</td>
<td align=left>
PRBS checker clock enable. <br>
&nbsp &nbsp&nbsp 1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>trnsum_error_count_en</td>
<td align=left>
 Training sum error counter Mode enable. <br>
&nbsp &nbsp &nbsp&nbsp 1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode. <br>
&nbsp &nbsp &nbsp&nbsp 0 => PRBS checker mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_err_cnt_burst_mode</td>
<td align=left>
PRBS Error Counter Mode.&nbsp <br>
&nbsp &nbsp &nbsp&nbsp 1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle
of data which in worst case should be 39 bits. <br>
&nbsp &nbsp &nbsp&nbsp 0 => Each bit error will be counted. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_burst_len_chk_en</td>
<td align=left>
 0 => disbale, 1=> enable (default) <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_en_auto_mode</td>
<td align=left>
PRBS Checker Enable Mode Control.&nbsp <br>
&nbsp &nbsp &nbsp&nbsp 1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control. <br>
&nbsp &nbsp &nbsp&nbsp 0 => select&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp prbs_chk_en&nbsp as PRBS checker enable control. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_mode</td>
<td align=left>
PRBS LOCK state machine select.&nbsp&nbsp <br>
&nbsp &nbsp &nbsp&nbsp 2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp This mode results in faster locking, but bit errors are counted multiple times (often by 3x). <br>
&nbsp &nbsp &nbsp&nbsp 2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock is&nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp acquired and then they run locally independently from the received data until the checker goes out of PRBS
lock. <br>
&nbsp &nbsp &nbsp&nbsp 2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.&nbsp
&nbsp <br>
&nbsp &nbsp &nbsp&nbsp 2'd3 -> reserved for future use. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_inv</td>
<td align=left>
PRBS Invert enable.<br>
&nbsp &nbsp&nbsp 1 => will invert all the data bits to the PRBS checker. <br>
&nbsp &nbsp&nbsp 0 => will send normal data to the PRBS checker. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_mode_sel</td>
<td align=left>
PRBS checker mode select. Selects the PRBS polynomial as shown below <br>
&nbsp &nbsp&nbsp 3'd0 -> PRBS 7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp&nbsp 3'd1 -> PRBS 9&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp&nbsp 3'd2 -> PRBS 11&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd3 -> PRBS 15&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd4 -> PRBS 23&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd5 -> PRBS 31&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd6 -> PRBS 58 (1 + x^39 + x^58) <br>
&nbsp &nbsp&nbsp 3'd7 -> PRBS 49 (1 + x^40 + x^49) <br>
Reset value is 0x5.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_en</td>
<td align=left>
PRBS checker enable. <br>
&nbsp &nbsp&nbsp 1 => enable&nbsp the PRBS checker. <br>
&nbsp &nbsp&nbsp 0 => disable the PRBS checker. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_dig_lpbk_config">TLB_RX_dig_lpbk_config - Digital Loopback Control</a></b><br>
Address Offset = 32'h0000_d162<br>
Physical Address = 32'h0000_d162<br>
Verilog CL45 Address = {`TLB_RX_A, `dig_lpbk_config_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `dig_lpbk_config_A<br>
Reset Value = 16'h000e<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dig_lpbk_pd_bias_en</td>
<td align=left>
1'b1 will enable PD inc bias mode where there will be inc generated every 16th clock cycle.. <br>
1'b0 will disable the PD bias mode so inc/dec will be generated based on the PD output. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dig_lpbk_pd_flt_bypass</td>
<td align=left>
Digital Loopback Phase Detector Filter Bypass. For repeater applications, it should be 1'b1. <br>
For other applications filter can be enabled for better jitter tolerance performance for the didgital loopback. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dig_lpbk_pd_mode</td>
<td align=left>
Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1. <br>
1'b0 - swap inc/dec. 1'b1 - normal mode. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dig_lpbk_en</td>
<td align=left>
TX to RX Parallel Loopback (Digital Loopback) Enable. <br>
&nbsp &nbsp&nbsp 1 => Loopback is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => Loopback is Disabled. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_tlb_rx_misc_config">TLB_RX_tlb_rx_misc_config - TLB RX Misc. Control</a></b><br>
Address Offset = 32'h0000_d163<br>
Physical Address = 32'h0000_d163<br>
Verilog CL45 Address = {`TLB_RX_A, `tlb_rx_misc_config_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `tlb_rx_misc_config_A<br>
Reset Value = 16'h0700<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_auto_detect_relock_en</td>
<td align=left>
PRBS checker Auto detect Re-lock enable. If enabled then it will go and start the auto-detect upon loss of signal once it already found a valid AUTO-DETECT
LOCK.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_auto_detect_en</td>
<td align=left>
PRBS checker Auto detect mode enable. If enabled then it will go through all the supported PRBS polynomials in round-robin fashion and search for prbs_chk_lock=1
until AUTO-DETECT SEARCH timer is expired.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_auto_detect_cnt</td>
<td align=left>
 Specifies the timer for the auto-detect search in each polynomial setting. <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_rx_symbol_bit_swap</td>
<td align=left>
 PAM4 Symbol bits {A,B} swap enable. Enable it only for the PAM4 modes. Bit swapping is done just after the PAM4 gray decoder.<br>
&nbsp &nbsp&nbsp 1 => 2 bits PAM4 symbol bits will be swapped where PAM4 symbol bits {A,B} maps to the datastream bits {[n+1], [n]} where n is the first
bit in receive order.<br>
&nbsp &nbsp&nbsp 0 => No swapping, default mode. PAM4 symbol bits {A,B} maps to the datastream bits {[n], [n+1]} where n is the first bit in receive order.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_decoder_en</td>
<td align=left>
 PAM4 Decoder Enable. Enable it only for the PAM4 NS mode.<br>
&nbsp &nbsp&nbsp 1 => PAM4 Decoder is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => PAM4 Decoder is Disabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_gray_dec_en</td>
<td align=left>
 PAM4 Gray Decoder Enable. Enable it only for the PAM4 modes.<br>
&nbsp &nbsp&nbsp 1 => PAM4 Gray Decoder is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => PAM4 Gray Decoder is Disabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_rx_nrz_ll_mode_en</td>
<td align=left>
RX low latency mode enable for the NRZ OSR modes. It is not applicable to the PAM4 modes.<br>
&nbsp &nbsp &nbsp When Enabled by writing to 1'b1 for NRZ OS modes, following will be the data format on the 40 bit RX data bus. RX data_valid will be
forced to 1'b1 in this case. <br>
&nbsp &nbsp &nbsp PCS RX data can be fed directly to the PCS TX data (with TX native analog format mode bit enabled) on the other end for Repeater Applications.
<br>
&nbsp &nbsp &nbsp OS1/2/4 modes&nbsp &nbsp &nbsp &nbsp - 20 bits of RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data
bus going out to PCS. <br>
&nbsp &nbsp &nbsp OS8/16/32 modes&nbsp &nbsp &nbsp - 20 bits of over-sampled RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits
data bus going out to PCS. <br>
&nbsp &nbsp &nbsp OS16.5/OS20.25 modes - 20 bits of over-sampled RX data will be replicated in 2 consecutive odd/even bits to form the 40 bits data bus
going out to PCS. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_rx_diff_dec_en</td>
<td align=left>
 1'b1 will enable the Differential Decoder for pmd_rx_data. Only applicable to PCS RX data in OS1, 2 and 4 modes. <br>
 Write it to 1'b0 for 1G OSR modes 16P5 and 20P625. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dbg_mask_dig_lpbk_en</td>
<td align=left>
 Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register. <br>
&nbsp &nbsp&nbsp 1 => pmd_rx_lock will be forced to 1'b0 during digital loopback. <br>
&nbsp &nbsp&nbsp 0 => pmd_rx_lock will be forced to 1'b1 during digital loopback. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_descrambler_en</td>
<td align=left>
 PAM4 RX Datapath De-scrambler Enable. Applicable only for the PAM4 modes with PRBS or PCS data.<br>
 Not applicable when external FEC feedback is used.<br>
&nbsp &nbsp&nbsp 1 => PAM4 RX Datapath&nbsp De-scrambler is Enabled. If rx_descrambler_en is enabled then 40 bits of the transmitted data <br>
&nbsp &nbsp &nbsp &nbsp &nbsp will be XORed with the 40 MSB bits of the fixed pattern sequence register {patt_gen_seq_14[15:0], patt_gen_seq_13[15:0],
patt_gen_seq_12[15:8]}. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp Make sure {patt_gen_seq_14[15:0], patt_gen_seq_13[15:0], patt_gen_seq_12[15:8]} bits are only re-programmed or changed when
rx_descrambler_en reg field is 1'b0. <br>
&nbsp &nbsp&nbsp 0 => PAM4 RX Datapath De-scrambler is Disabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rx_pmd_dp_invert</td>
<td align=left>
RX PMD Datapath Invert Control. <br>
&nbsp &nbsp &nbsp When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane. <br>
&nbsp &nbsp &nbsp Recommended for use in case P and N pads are swapped on the PCB board. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_en_timer_control">TLB_RX_prbs_chk_en_timer_control - TLB RX PRBS Checker Enable Timer Control</a></b><br>
Address Offset = 32'h0000_d164<br>
Physical Address = 32'h0000_d164<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_en_timer_control_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_en_timer_control_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_en_timeout</td>
<td align=left>
 PRBS timer timeout value. <br>
 Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_chk_en_timer_mode</td>
<td align=left>
 prbs_chk_en timer mode. <br>
&nbsp &nbsp&nbsp 2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register. <br>
&nbsp &nbsp&nbsp 2'b10 => use heartbeat_toggle_1us for the timer. <br>
&nbsp &nbsp&nbsp 2'b11 => use heartbeat_toggle_1ms for the timer. <br>
&nbsp &nbsp&nbsp Make sure that only one of the 2 register settings ((prbs_chk_en_timer_mode >=2 & prbs_chk_en_timeout > 0) and prbs_chk_burst_err_cnt_en)
are TRUE at any given time and not simultaneously TRUE. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_burst_err_cnt_status">TLB_RX_prbs_chk_burst_err_cnt_status - PRBS Checker Burst Error Counter Status</a></b><br>
Address Offset = 32'h0000_d165<br>
Physical Address = 32'h0000_d165<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_burst_err_cnt_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_burst_err_cnt_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_burst_err_cnt</td>
<td align=left>
PRBS Checker Burst Error Counter Status Register. It is a clear on read register. This register counts <br>
the number of Burst in errors separated by atleast 1 clock cycle worth of data without any bit in error. <br>
prbs_chk_burst_err_cnt_en should be set to 1'b1 for this counter to work. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_dbg_pmd_rx_lock_status">TLB_RX_dbg_pmd_rx_lock_status - Debug PMD RX LOCK Status</a></b><br>
Address Offset = 32'h0000_d166<br>
Physical Address = 32'h0000_d166<br>
Verilog CL45 Address = {`TLB_RX_A, `dbg_pmd_rx_lock_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `dbg_pmd_rx_lock_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_pmd_rx_lock_change</td>
<td align=left>
 Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dbg_pmd_rx_lock</td>
<td align=left>
Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.&nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 => PMD is not LOCKED yet.&nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_uc_pmd_rx_lock_status">TLB_RX_uc_pmd_rx_lock_status - Debug PMD RX LOCK Status</a></b><br>
Address Offset = 32'h0000_d167<br>
Physical Address = 32'h0000_d167<br>
Verilog CL45 Address = {`TLB_RX_A, `uc_pmd_rx_lock_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `uc_pmd_rx_lock_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_pmd_rx_lock_change</td>
<td align=left>
 Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read. This is a debug register. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>uc_pmd_rx_lock</td>
<td align=left>
Debug PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.&nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 => PMD is not LOCKED yet.&nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_dig_lpbk_pd_status">TLB_RX_dig_lpbk_pd_status - Digital Loopback Status</a></b><br>
Address Offset = 32'h0000_d168<br>
Physical Address = 32'h0000_d168<br>
Verilog CL45 Address = {`TLB_RX_A, `dig_lpbk_pd_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `dig_lpbk_pd_status_A<br>
Reset Value = 16'h0002<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_mode_sel_msb_auto_detect</td>
<td align=left>
Valid only when prbs_chk_auto_detect_lock=1. Equivalent to prbs_chk_mode_sel_msb register in auto-detect mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:10</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_mode_sel_auto_detect</td>
<td align=left>
Valid only when prbs_chk_auto_detect_lock=1. Equivalent to prbs_chk_mode_sel&nbsp &nbsp&nbsp register in auto-detect mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_inv_auto_detect</td>
<td align=left>
Valid only when prbs_chk_auto_detect_lock=1. Indicates te PRBS polynomial invert bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_auto_detect_lock</td>
<td align=left>
Live indication of AUTO-DETECT Lock. Set to 1'b1 once auto-detect finds the PRBS lock. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dig_lpbk_pd_early_ind</td>
<td align=left>
1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dig_lpbk_pd_late_ind</td>
<td align=left>
1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_lock_status">TLB_RX_prbs_chk_lock_status - PRBS Checker LOCK Status</a></b><br>
Address Offset = 32'h0000_d169<br>
Physical Address = 32'h0000_d169<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_lock_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_lock_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_err_cnt_no_clr</td>
<td align=left>
PRBS Checker Error Counter which does not get cleared upon read.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp MSB bit 14 is OR of the MSB bits [30:14] of the internal error counter.&nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp LSB bits [13:0] are assigned to LSB bits [13:0] of the internal error counter.&nbsp <br>
&nbsp It can be cleared by reading the status register prbs_chk_err_cnt_msb.&nbsp &nbsp &nbsp &nbsp &nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_lock</td>
<td align=left>
PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 => PRBS Checker is in LOCKED state.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 => PRBS Checker is out of LOCK state and state machine is searching for a LOCK.&nbsp &nbsp &nbsp &nbsp&nbsp
<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_err_cnt_msb_status">TLB_RX_prbs_chk_err_cnt_msb_status - PRBS Checker Error Counter MSB Status</a></b><br>
Address Offset = 32'h0000_d16a<br>
Physical Address = 32'h0000_d16a<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_err_cnt_msb_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_err_cnt_msb_status_A<br>
Reset Value = 16'h8000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_lock_lost_lh</td>
<td align=left>
PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on the <br>
prbs_chk_lock live status register and keep it latched until read. This is a clear on read status register.<br>
"prbs_chk_lock_lost_lh status bit also indicate other PRBS checker states as below.<br>
"&nbsp&nbsp - PRBS Checker is currently not enabled ||<br>
"&nbsp&nbsp - PRBS Checker is currently not locked ||<br>
"&nbsp&nbsp - PRBS_LOCK was lost when checker was enabled since the last read<br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_err_cnt_msb</td>
<td align=left>
15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.&nbsp <br>
Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loaded&nbsp <br>
into a holding register and internal PRBS error counter's all bits are cleared to 0s <br>
 (or if there are any error in that particular clock cycle then that will be loaded). <br>
MSB portion must be read first before reading the LSB portion of the error counter.&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_chk_err_cnt_lsb_status">TLB_RX_prbs_chk_err_cnt_lsb_status - PRBS Checker Error Counter LSB Status</a></b><br>
Address Offset = 32'h0000_d16b<br>
Physical Address = 32'h0000_d16b<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_chk_err_cnt_lsb_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_chk_err_cnt_lsb_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_err_cnt_lsb</td>
<td align=left>
16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicates<br>
the value in the holding register when MSB portion [30:16] of the error counter are read. <br>
MSB portion must be read first before reading the LSB portion of the error counter.&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_pmd_rx_lock_status">TLB_RX_pmd_rx_lock_status - PMD RX LOCK Status</a></b><br>
Address Offset = 32'h0000_d16c<br>
Physical Address = 32'h0000_d16c<br>
Verilog CL45 Address = {`TLB_RX_A, `pmd_rx_lock_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `pmd_rx_lock_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pmd_rx_lock_change</td>
<td align=left>
 Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>pmd_rx_lock</td>
<td align=left>
PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.&nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 => PMD is not LOCKED yet.&nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_prbs_burst_err_length_status">TLB_RX_prbs_burst_err_length_status - PRBS Burst Error Length Status</a></b><br>
Address Offset = 32'h0000_d16d<br>
Physical Address = 32'h0000_d16d<br>
Verilog CL45 Address = {`TLB_RX_A, `prbs_burst_err_length_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `prbs_burst_err_length_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_burst_err_length_status</td>
<td align=left>
PRBS burst error length count. This the live indication of the live status of the PRBS burst error length and max at 6'd63. This register is cleared upon
read.<br>
This register is supported for all the data traffic modes but only required for NRZ OSR modes OS1, OS2 and OS4 and PAM4 NS/ES modes with and without Back
Channel enabled.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_max_prbs_burst_err_length_status">TLB_RX_max_prbs_burst_err_length_status - PRBS Burst Error Maximum Length Status</a></b><br>
Address Offset = 32'h0000_d16e<br>
Physical Address = 32'h0000_d16e<br>
Verilog CL45 Address = {`TLB_RX_A, `max_prbs_burst_err_length_status_Adr}<br>
Verilog CL22 Address = {`TLB_RX_A, 4'h0}, `max_prbs_burst_err_length_status_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>max_prbs_burst_err_length_status</td>
<td align=left>
PRBS burst error max length count. This the status of the PRBS burst error max length and max at 6'd63. This register is cleared upon read.<br>
This register is supported for all the data traffic modes but only required for NRZ OSR modes OS1, OS2 and OS4 and PAM4 NS/ES modes with and without Back
Channel enabled.<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX Registers">Return to TLB_RX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TLB_TX Registers">TLB_TX: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd170</td><td><A HREF="#TLB_TX_patt_gen_config">TLB_TX_patt_gen_config</A></td><td>Pattern Generator Control</td></tr>
<tr>
<td align=center>0xd171</td><td><A HREF="#TLB_TX_prbs_gen_config">TLB_TX_prbs_gen_config</A></td><td>PRBS Generator Control</td></tr>
<tr>
<td align=center>0xd172</td><td><A HREF="#TLB_TX_rmt_lpbk_config">TLB_TX_rmt_lpbk_config</A></td><td>Remote Loopback Control</td></tr>
<tr>
<td align=center>0xd173</td><td><A HREF="#TLB_TX_tlb_tx_misc_config">TLB_TX_tlb_tx_misc_config</A></td><td>TLB TX Misc. Control</td></tr>
<tr>
<td align=center>0xd175</td><td><A HREF="#TLB_TX_tlb_tx_pam4_config_0">TLB_TX_tlb_tx_pam4_config_0</A></td><td>TLB TX PAM4 Controls 0</td></tr>
<tr>
<td align=center>0xd178</td><td><A HREF="#TLB_TX_rmt_lpbk_pd_status">TLB_TX_rmt_lpbk_pd_status</A></td><td>Remote Loopback Status</td></tr>
<tr>
<td align=center>0xd179</td><td><A HREF="#TLB_TX_tlb_tx_bc_enc_config_0">TLB_TX_tlb_tx_bc_enc_config_0</A></td><td>TLB TX Back Channel Encoder Controls 0</td></tr>
<tr>
<td align=center>0xd17a</td><td><A HREF="#TLB_TX_tlb_tx_bc_enc_config_1">TLB_TX_tlb_tx_bc_enc_config_1</A></td><td>TLB TX Back Channel Encoder Controls 1</td></tr>
<tr>
<td align=center>0xd17b</td><td><A HREF="#TLB_TX_tlb_tx_bc_enc_config_2">TLB_TX_tlb_tx_bc_enc_config_2</A></td><td>TLB TX Back Channel Encoder Controls 2</td></tr>
<tr>
<td align=center>0xd17e</td><td><A HREF="#TLB_TX_tlb_tx_bc_enc_status_0">TLB_TX_tlb_tx_bc_enc_status_0</A></td><td>TLB TX Back Channel Encoder Status 0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TLB_TX_patt_gen_config">TLB_TX_patt_gen_config - Pattern Generator Control</a></b><br>
Address Offset = 32'h0000_d170<br>
Physical Address = 32'h0000_d170<br>
Verilog CL45 Address = {`TLB_TX_A, `patt_gen_config_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `patt_gen_config_A<br>
Reset Value = 16'hb000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_start_pos</td>
<td align=left>
 Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.&nbsp <br>
 11 means start at bit 239,&nbsp <br>
 10 means start at bit 219, ...,&nbsp <br>
&nbsp 0 means start at bit&nbsp 19&nbsp <br>
 so start bit is (rg_patt_gen_start_pos*20 + 19).&nbsp&nbsp <br>
Reset value is 0xb.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_stop_pos</td>
<td align=left>
 Valid values are 11 to 0. Defines the stop&nbsp position of the pattern in 20 bit chunks.&nbsp <br>
 This register value should be less than or equal to rg_patt_gen_start_pos. <br>
 11 means stop at bit&nbsp 220,&nbsp <br>
 10 means stop at bit&nbsp 200, ...,&nbsp &nbsp <br>
&nbsp 0 means stop at bit&nbsp &nbsp 0&nbsp <br>
 so stop&nbsp bit is (rg_patt_gen_stop_pos*20). <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_tx_jp03b_patt_en</td>
<td align=left>
JP03B Fixed Pattern Enable. Higher priority than pam4_tx_linearity_patt_en if both bits are enabled simultaneously. Make sure gray encoder and PAM4 precoder
is disabled for this fixed pattern mode. <br>
"&nbsp &nbsp&nbsp 1 => Enable&nbsp the fixed pattern for JP03B pattern of 124 bits (i.e. 62 symbols) long repeating pattern of {15{00,11}} + {16{11,00}}.
Program reg field patt_gen_seq_1[15:8] bits = 8'b_0011_1100 = 8'h3C before enabling this pattern.<br>
&nbsp &nbsp Transmission order is MSB first. If this bit is enabled then make sure that other lane fixed pattern do not use fixed pattern 20 bit chunk
of bits 39:20. <br>
"&nbsp &nbsp&nbsp 0 => Disable the JP03B fixed pattern generation. <br>
"C<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_tx_linearity_patt_en</td>
<td align=left>
PAM4 Transmitter Linearity Pattern Enable. Lower priority than pam4_tx_jp03b_patt_en if both bits are enabled simultaneously. Make sure gray encoder and
PAM4 precoder is disabled for this fixed pattern mode. <br>
&nbsp &nbsp&nbsp 1 => enable&nbsp the fixed pattern for PAM4 Transmitter Linearity Pattern of 320 bits (i.e. 160 symbols) long repeating pattern of 10
PAM4 levels of {-1, -1/3, +1/3, +1, -1, +1, -1, +1, +1/3, -1/3} where <br>
&nbsp &nbsp &nbsp &nbsp &nbsp each level is 16UI in duration.&nbsp Program reg field {patt_gen_seq_1[3:0], patt_gen_seq_0[15:0]} bits = 20'b_0001_1011_0011_0011_1001
= 20'h1B339 before enabling this pattern. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp Transmission order is MSB first.&nbsp If this bit is enabled then make sure that other lane fixed pattern do not use fixed
pattern 20 bit chunk of bits 19:0. <br>
&nbsp &nbsp&nbsp 0 => disable the PAM4 Transmitter Linearity Pattern generation. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>patt_gen_en</td>
<td align=left>
Fixed pattern generator enable. <br>
&nbsp &nbsp&nbsp 1 => enable&nbsp the fixed pattern generator. <br>
&nbsp &nbsp&nbsp 0 => disable the fixed pattern generator. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_prbs_gen_config">TLB_TX_prbs_gen_config - PRBS Generator Control</a></b><br>
Address Offset = 32'h0000_d171<br>
Physical Address = 32'h0000_d171<br>
Verilog CL45 Address = {`TLB_TX_A, `prbs_gen_config_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `prbs_gen_config_A<br>
Reset Value = 16'h000a<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>prbs_gen_pause_strobe</td>
<td align=left>
PRBS Generator Pause Strobe (debug register). It is a self clear register bit.<br>
Wrting to 1 will pause the PRBS generator for 1 clock cycle which means same 40 bits data will be replicated in the paused clock cycle. This will result
into loss of prbs checker lock on the link partner.&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_gen_mode_sel_msb</td>
<td align=left>
 Extending PRBS polynomial select by using this bit as bit[3] alongwith prbs_gen_mode_sel[2:0]. <br>
 1'b0 will select old PRBS polynomials for PRBS 7, 9, 11, 15, 23, 31, 49 and 58 based on prbs_gen_mode_sel[2:0]. <br>
 1'b1 will select new PRBS polynomials for PRBS 10, 20, 13 for PAM4 based on prbs_gen_mode_sel[2:0]. <br>
 1'b1 & prbs_gen_mode_sel[2:0] == 0 will select PRBS 10. <br>
 1'b1 & prbs_gen_mode_sel[2:0] == 1 will select PRBS 20. <br>
 1'b1 & prbs_gen_mode_sel[2:0] == 2 will select PRBS 13&nbsp with polynomial (1+x^1+x^2+x^12+x^13). This pattern is also used for PAM4 Link Training Lane
0 pattern. <br>
 1'b1 & prbs_gen_mode_sel[2:0] == 3 is reserved for future use. <br>
 1'b1 & prbs_gen_mode_sel[2:0] == 4 will select PAM4 Link Training Lane 1 PRBS 13&nbsp polynomial (1 + x2 + x3 + x7&nbsp + x13). Debug modes so auto-detect
and self-sync mode is not supported.<br>
 1'b1 & prbs_gen_mode_sel[2:0] == 5 will select PAM4 Link Training Lane 2 PRBS 13&nbsp polynomial (1 + x2 + x4 + x8&nbsp + x13). Debug modes so auto-detect
and self-sync mode is not supported.<br>
 1'b1 & prbs_gen_mode_sel[2:0] == 6 will select PAM4 Link Training Lane 3 PRBS 13&nbsp polynomial (1 + x2 + x5 + x9&nbsp + x13). Debug modes so auto-detect
and self-sync mode is not supported.<br>
 1'b1 & prbs_gen_mode_sel[2:0] == 7 is reserved for future use. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_gen_err_ins</td>
<td align=left>
PRBS Error Insert.<br>
&nbsp &nbsp&nbsp 0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_gen_inv</td>
<td align=left>
PRBS Invert enable.<br>
&nbsp &nbsp&nbsp 1 => will invert all the data bits from the PRBS generator. <br>
&nbsp &nbsp&nbsp 0 => will send normal data from the PRBS generator. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_gen_mode_sel</td>
<td align=left>
PRBS generator mode select. Selects the PRBS polynomial as shown below <br>
&nbsp &nbsp&nbsp 3'd0 -> PRBS 7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp&nbsp 3'd1 -> PRBS 9&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp&nbsp 3'd2 -> PRBS 11&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd3 -> PRBS 15&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd4 -> PRBS 23&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd5 -> PRBS 31&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp&nbsp 3'd6 -> PRBS 58 (1 + x^39 + x^58) <br>
&nbsp &nbsp&nbsp 3'd7 -> PRBS 49 (1 + x^40 + x^49) <br>
Reset value is 0x5.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>prbs_gen_en</td>
<td align=left>
PRBS generator enable. <br>
&nbsp &nbsp&nbsp 1 => enable&nbsp the PRBS generator. <br>
&nbsp &nbsp&nbsp 0 => disable the PRBS generator. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_rmt_lpbk_config">TLB_TX_rmt_lpbk_config - Remote Loopback Control</a></b><br>
Address Offset = 32'h0000_d172<br>
Physical Address = 32'h0000_d172<br>
Verilog CL45 Address = {`TLB_TX_A, `rmt_lpbk_config_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `rmt_lpbk_config_A<br>
Reset Value = 16'h0002<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rmt_lpbk_pd_frc_on</td>
<td align=left>
Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en. <br>
1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TX <br>
clock phases when there is a remote loopback outside PMD <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rmt_lpbk_pd_mode</td>
<td align=left>
Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1. <br>
1'b0 - swap inc/dec. 1'b1 - normal mode. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>rmt_lpbk_en</td>
<td align=left>
RX to TX Parallel Loopback (Remote Loopback) Enable. <br>
&nbsp &nbsp&nbsp 1 => Loopback is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => Loopback is Disabled. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_tlb_tx_misc_config">TLB_TX_tlb_tx_misc_config - TLB TX Misc. Control</a></b><br>
Address Offset = 32'h0000_d173<br>
Physical Address = 32'h0000_d173<br>
Verilog CL45 Address = {`TLB_TX_A, `tlb_tx_misc_config_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `tlb_tx_misc_config_A<br>
Reset Value = 16'h0010<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_trn_active_auto_mode_en</td>
<td align=left>
 1'b1 will forcefully disable the below described TX datapath functions automatically while TX Link Training is enabled and active irrespective of the
below register bit settings . <br>
&nbsp&nbsp - PAM4 Gray Encoder&nbsp &nbsp &nbsp &nbsp&nbsp (enabled by field pam4_gray_enc_en)&nbsp &nbsp &nbsp &nbsp <br>
&nbsp&nbsp - PAM4 Precoder&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp (enabled by field pam4_precoder_en)&nbsp &nbsp &nbsp &nbsp <br>
&nbsp&nbsp - PAM4 Symbol bit-swap&nbsp &nbsp &nbsp (enabled by field pam4_tx_symbol_bit_swap) <br>
&nbsp&nbsp - NRZ Differential Encoder&nbsp (enabled by field tlb_tx_diff_enc_en)&nbsp &nbsp &nbsp <br>
&nbsp &nbsp&nbsp In addition to these function Back channel encoder and Scrambler are always disabled while TX Link Training is enabled and active irrespective
of this register value. <br>
 1'b0 will ignore the control signal from TX Link Training and the above TX datapath functions will be enabled based on their individual enable bits irrespective
of the TX training status where enabled or disabled.&nbsp <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_tx_diff_enc_en</td>
<td align=left>
 1'b1 will enable the Differential Encoder for pmd_tx_data. Only applicable to PCS TX data in OS1, 2 and 4 modes. <br>
 Write it to 1'b0 for 1G OSR modes 16P5 and 20P625. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_mux_sel_order</td>
<td align=left>
TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72. <br>
&nbsp &nbsp &nbsp 0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}. <br>
&nbsp &nbsp &nbsp 1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pcs_native_ana_frmt_en</td>
<td align=left>
TX PCS Interface Native Analog Format Enable. <br>
&nbsp &nbsp &nbsp 1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly
to AFE. <br>
&nbsp &nbsp &nbsp 0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_pmd_dp_invert</td>
<td align=left>
TX PMD Datapath Invert Control. <br>
&nbsp &nbsp &nbsp When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane. <br>
&nbsp &nbsp &nbsp Recommended for use in case P and N pads are swapped on the PCB board. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_tlb_tx_pam4_config_0">TLB_TX_tlb_tx_pam4_config_0 - TLB TX PAM4 Controls 0</a></b><br>
Address Offset = 32'h0000_d175<br>
Physical Address = 32'h0000_d175<br>
Verilog CL45 Address = {`TLB_TX_A, `tlb_tx_pam4_config_0_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `tlb_tx_pam4_config_0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_tx_symbol_bit_swap</td>
<td align=left>
 PAM4 Symbol bits {A,B} swap enable. Enable it only for the PAM4 modes. Bit swapping is done just before the PAM4 gray encoder.<br>
&nbsp &nbsp&nbsp 1 => 2 bits PAM4 symbol bits will be swapped where PAM4 symbol bits {A,B} maps to the datastream bits {[n+1], [n]} where n is the first
bit in transmission order.<br>
&nbsp &nbsp&nbsp 0 => No swapping, default mode. PAM4 symbol bits {A,B} maps to the datastream bits {[n], [n+1]} where n is the first bit in transmission
order.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tx_scrambler_en</td>
<td align=left>
 PAM4 TX Datapath Scrambler Enable. Applicable only for the PAM4 modes with PRBS or PCS data.<br>
&nbsp &nbsp&nbsp 1 => PAM4 TX Datapath Scrambler is Enabled. If tx_scrambler_en is enabled then 40 bits of the transmitted data <br>
&nbsp &nbsp &nbsp &nbsp &nbsp will be XORed with the 40 LSB bits of the fixed pattern sequence register {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]}.
<br>
&nbsp &nbsp &nbsp &nbsp &nbsp Make sure {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]} bits are only re-programmed or changed when both
tx_scrambler_en and bc_enc_err_ins_en reg fields are 1'b0. <br>
&nbsp &nbsp&nbsp 0 => PAM4 TX Datapath Scrambler is Disabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_precoder_en</td>
<td align=left>
 PAM4 Precoder Enable. Enable it only for the PAM4 modes.<br>
&nbsp &nbsp&nbsp 1 => PAM4 Precoder is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => PAM4 Precoder is Disabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>pam4_gray_enc_en</td>
<td align=left>
 PAM4 Gray Encoder Enable. Enable it only for the PAM4 modes.<br>
&nbsp &nbsp&nbsp 1 => PAM4 Gray Encoder is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => PAM4 Gray Encoder is Disabled. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_rmt_lpbk_pd_status">TLB_TX_rmt_lpbk_pd_status - Remote Loopback Status</a></b><br>
Address Offset = 32'h0000_d178<br>
Physical Address = 32'h0000_d178<br>
Verilog CL45 Address = {`TLB_TX_A, `rmt_lpbk_pd_status_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `rmt_lpbk_pd_status_A<br>
Reset Value = 16'h0002<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rmt_lpbk_pd_early_ind</td>
<td align=left>
1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>rmt_lpbk_pd_late_ind</td>
<td align=left>
1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_tlb_tx_bc_enc_config_0">TLB_TX_tlb_tx_bc_enc_config_0 - TLB TX Back Channel Encoder Controls 0</a></b><br>
Address Offset = 32'h0000_d179<br>
Physical Address = 32'h0000_d179<br>
Verilog CL45 Address = {`TLB_TX_A, `tlb_tx_bc_enc_config_0_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `tlb_tx_bc_enc_config_0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_enc_frm_len_sel</td>
<td align=left>
 Back Channel Encoder Frame Length Select Control. Determines the distance between 2 adjacent back channel frames. <br>
 Following table explains the value of this register and BC frame length in multiples of 128 tclk20 cycles or 128*20 PAM4 symbols.&nbsp <br>
&nbsp bc_enc_frm_len_sel[2:0]&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp BC frame length in multiples of 128*20 PAM4 symbols.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
<br>
&nbsp&nbsp 0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 1&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp&nbsp 1&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^0&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 2&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^1&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 3&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^2&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 4&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^3&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 5&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^4&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 6&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^5&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^6&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_enc_err_ins_en</td>
<td align=left>
 Back Channel Encoder Error Insert Enable. Applicable only for the modes when BC encoder is enabled. <br>
 tx_scrambler_en reg field should be disabled for BC encoder error insertion to work otherwise all the TX data will be XORed instead and not only the BC
encoder frame.<br>
&nbsp &nbsp&nbsp 1 => Back Channel Encoder Error Insert is Enabled. If BC encoder error insertion is enabled and tx_scrambler_en is disabled then 40 bits
of the transmitted <br>
&nbsp &nbsp &nbsp &nbsp &nbsp BC frame will be XORed with the 40 LSB bits of the fixed pattern sequence register {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0],
patt_gen_seq_0[15:0]}. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp Make sure {patt_gen_seq_2[7:0], patt_gen_seq_1[15:0], patt_gen_seq_0[15:0]} bits are only re-programmed or changed when both
tx_scrambler_en and bc_enc_err_ins_en reg fields are 1'b0. <br>
&nbsp &nbsp&nbsp 0 => Back Channel Encoder Error Insert is Disabled. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>bc_enc_update</td>
<td align=left>
 Back Channel Encoder Update Control. Self-clear control register. Write this register to 1'b1 after updating the bc_enc_data and/or bc_enc_frm_len_sel
fields. <br>
 Updated information will be sent transmitted in the next back channel encoder word/frame. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_enc_en</td>
<td align=left>
 Back Channel Encoder Enable. Applicable only to PAM4 modes alongwith PRBS or PCS TX data sources. <br>
&nbsp &nbsp&nbsp 1 => Back Channel Encoder is Enabled.&nbsp <br>
&nbsp &nbsp&nbsp 0 => Back Channel Encoder is Disabled. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_tlb_tx_bc_enc_config_1">TLB_TX_tlb_tx_bc_enc_config_1 - TLB TX Back Channel Encoder Controls 1</a></b><br>
Address Offset = 32'h0000_d17a<br>
Physical Address = 32'h0000_d17a<br>
Verilog CL45 Address = {`TLB_TX_A, `tlb_tx_bc_enc_config_1_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `tlb_tx_bc_enc_config_1_A<br>
Reset Value = 16'hf628<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_enc_data_lsb</td>
<td align=left>
 Back Channel Encoder Data LSB bits [15:0].&nbsp <br>
Reset value is 0xf628.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_tlb_tx_bc_enc_config_2">TLB_TX_tlb_tx_bc_enc_config_2 - TLB TX Back Channel Encoder Controls 2</a></b><br>
Address Offset = 32'h0000_d17b<br>
Physical Address = 32'h0000_d17b<br>
Verilog CL45 Address = {`TLB_TX_A, `tlb_tx_bc_enc_config_2_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `tlb_tx_bc_enc_config_2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_enc_data_msb</td>
<td align=left>
 Back Channel Encoder Data LSB bits [15:0].&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_TX_tlb_tx_bc_enc_status_0">TLB_TX_tlb_tx_bc_enc_status_0 - TLB TX Back Channel Encoder Status 0</a></b><br>
Address Offset = 32'h0000_d17e<br>
Physical Address = 32'h0000_d17e<br>
Verilog CL45 Address = {`TLB_TX_A, `tlb_tx_bc_enc_status_0_Adr}<br>
Verilog CL22 Address = {`TLB_TX_A, 4'h0}, `tlb_tx_bc_enc_status_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_enc_data_sent</td>
<td align=left>
Status bit (when set to 1) indicating that the first back channel frame/word with the updated BC data and/or frame lenghth have been transmitted. <br>
This is a clear-on-read status register. It is also cleared upon bc_enc_update assertion. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_TX Registers">Return to TLB_TX: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TLB_RX_B Registers">TLB_RX_B: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd1e0</td><td><A HREF="#TLB_RX_B_tlb_rx_b_config_0">TLB_RX_B_tlb_rx_b_config_0</A></td><td>TLB_RX_B Control 0</td></tr>
<tr>
<td align=center>0xd1e1</td><td><A HREF="#TLB_RX_B_tlb_rx_b_config_1">TLB_RX_B_tlb_rx_b_config_1</A></td><td>TLB_RX_B Control 1</td></tr>
<tr>
<td align=center>0xd1e2</td><td><A HREF="#TLB_RX_B_tlb_rx_b_config_2">TLB_RX_B_tlb_rx_b_config_2</A></td><td>TLB_RX_B Control 2</td></tr>
<tr>
<td align=center>0xd1e3</td><td><A HREF="#TLB_RX_B_tlb_rx_b_config_3">TLB_RX_B_tlb_rx_b_config_3</A></td><td>TLB_RX_B Control 3</td></tr>
<tr>
<td align=center>0xd1e4</td><td><A HREF="#TLB_RX_B_tlb_rx_b_config_4">TLB_RX_B_tlb_rx_b_config_4</A></td><td>TLB_RX_B Control 4</td></tr>
<tr>
<td align=center>0xd1e7</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_7">TLB_RX_B_tlb_rx_b_status_7</A></td><td>TLB_RX_B Status 7</td></tr>
<tr>
<td align=center>0xd1e8</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_6">TLB_RX_B_tlb_rx_b_status_6</A></td><td>TLB_RX_B Status 6</td></tr>
<tr>
<td align=center>0xd1e9</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_5">TLB_RX_B_tlb_rx_b_status_5</A></td><td>TLB_RX_B Status 5</td></tr>
<tr>
<td align=center>0xd1ea</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_4">TLB_RX_B_tlb_rx_b_status_4</A></td><td>TLB_RX_B Status 4</td></tr>
<tr>
<td align=center>0xd1eb</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_3">TLB_RX_B_tlb_rx_b_status_3</A></td><td>TLB_RX_B Status 3</td></tr>
<tr>
<td align=center>0xd1ec</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_2">TLB_RX_B_tlb_rx_b_status_2</A></td><td>TLB_RX_B Status 2</td></tr>
<tr>
<td align=center>0xd1ed</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_1">TLB_RX_B_tlb_rx_b_status_1</A></td><td>TLB_RX_B Status 1</td></tr>
<tr>
<td align=center>0xd1ee</td><td><A HREF="#TLB_RX_B_tlb_rx_b_status_0">TLB_RX_B_tlb_rx_b_status_0</A></td><td>TLB_RX_B Status 0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_config_0">TLB_RX_B_tlb_rx_b_config_0 - TLB_RX_B Control 0</a></b><br>
Address Offset = 32'h0000_d1e0<br>
Physical Address = 32'h0000_d1e0<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_config_0_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_config_0_A<br>
Reset Value = 16'h2110<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_align_timer_mode</td>
<td align=left>
 Defines the timer modes for the ALIGN_SEARCH state.<br>
 00 - use rclk&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp (256&nbsp to 7936 rclk20 cycles)&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp .<br>
 01 - use heartbeat_toggle_1us (16us to 496us)&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp .<br>
 10 - use heartbeat_toggle_1ms (1ms&nbsp to 31ms)&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp .<br>
 11 - create the timer_done manually using the self-clear control register bc_dec_align_timer_done .<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_align_check_sec_en</td>
<td align=left>
 1'b1 will allow 1 bit error correction during ALIGN_CHECK state. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_align_timer_cnt</td>
<td align=left>
 Defines the timer duration to be used in the ALIGN_SEARCH state . Use it together with bc_dec_align_timer_mode. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_lock_cnt</td>
<td align=left>
 Defines the number of bc_dec_lock_cnt+1 consecutive good BC frames of (good BC frames is defined as either no error or 1 bit correctable error if bc_dec_align_check_sec_en
is 1'b1) to go to the BC frame lock. Valid values are 0 to 15. It is used in both ALIGN_FOUND and REFRAME_FOUND states. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_reframe_en</td>
<td align=left>
 1'b1 will enable re-framing to new frame length. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_en</td>
<td align=left>
Back Channel Decoder Enable. <br>
&nbsp &nbsp&nbsp 1 => enable&nbsp the Back Channel Decoder. <br>
&nbsp &nbsp&nbsp 0 => disable the Back Channel Decoder. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_config_1">TLB_RX_B_tlb_rx_b_config_1 - TLB_RX_B Control 1</a></b><br>
Address Offset = 32'h0000_d1e1<br>
Physical Address = 32'h0000_d1e1<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_config_1_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_config_1_A<br>
Reset Value = 16'hf628<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_frm_pat</td>
<td align=left>
 Defines the framing pattern which is compared to the received BC word bit [15:0] while decoder <br>
 is trying to frame on the received data to acheive BC frame lock. <br>
Reset value is 0xf628.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_config_2">TLB_RX_B_tlb_rx_b_config_2 - TLB_RX_B Control 2</a></b><br>
Address Offset = 32'h0000_d1e2<br>
Physical Address = 32'h0000_d1e2<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_config_2_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_config_2_A<br>
Reset Value = 16'h03a0<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>bc_dec_align_search_manual_timer_done</td>
<td align=left>
 Self clear regiter bit. Setting it to 1'b1 along with bc_dec_align_timer_mode=2'b11 will increment the sym_dly and search for alignment in new symbol
rotate position. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_frm_len_sel</td>
<td align=left>
 Back Channel Decoder Frame Length Select Control. Determines the distance between 2 adjacent back channel frames. <br>
 Following table explains the value of this register and BC frame length in multiples of 128 rclk20 cycles or 128*20 PAM4 symbols.&nbsp <br>
&nbsp bc_dec_frm_len_sel[2:0]&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp BC frame length in multiples of 128*20 PAM4 symbols.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
<br>
&nbsp&nbsp 0&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 1&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp&nbsp 1&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^0&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 2&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^1&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 3&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^2&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 4&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^3&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 5&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^4&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 6&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^5&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp&nbsp 7&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 16*2^6&nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_ool_cnt</td>
<td align=left>
 Defines consecutive number of bad frames (i.e. BC frame ecc error >= 2) received by the framer to assert bc_dec_lol status and interrupt. <br>
Reset value is 0x7.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_msg_cons_cnt</td>
<td align=left>
 Defines the number of good consecutive BC frames with the consistent and different from the previously captured messages to accept as a new message in
the bc_dec_msg_ms/lsb[15:0] registers. <br>
 Value of 0 has special meaning where messages will be captured every frame irrespective of whether ECC is correctable or not. Value 0 should be only used
for the debug mode. <br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_msg_type_mode</td>
<td align=left>
&nbsp It is a debug register bit to select the type of BC frames to be counted for analysis of type of errors in the BC frames. <br>
&nbsp 2'b00 - Count no error BC frames. <br>
&nbsp 2'b01 - Count 1 bit correctable error BC frames. <br>
&nbsp 2'b10 - Count 2 bit detectable&nbsp errors BC frames. <br>
&nbsp 2'b11 - Count 3 bit or more errors of un-correctable/un-detectable error BC frames. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_config_3">TLB_RX_B_tlb_rx_b_config_3 - TLB_RX_B Control 3</a></b><br>
Address Offset = 32'h0000_d1e3<br>
Physical Address = 32'h0000_d1e3<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_config_3_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_config_3_A<br>
Reset Value = 16'h0080<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sym_rotate_bc_dec_en</td>
<td align=left>
 Enable symbol rotate by BC decoder. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sym_rotate_prbs_auto_detect_en</td>
<td align=left>
 Enable symbol rotate by PRBS auto-detect. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sym_rotate_dly_frc</td>
<td align=left>
 Symbol rotate force control for debug mode. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>sym_rotate_dly_frc_val</td>
<td align=left>
 Symbol rotate force value for debug mode. Valid values are 0 to 19. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_config_4">TLB_RX_B_tlb_rx_b_config_4 - TLB_RX_B Control 4</a></b><br>
Address Offset = 32'h0000_d1e4<br>
Physical Address = 32'h0000_d1e4<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_config_4_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_config_4_A<br>
Reset Value = 16'h000f<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>bc_dec_intr_frc_msg_lsb_ready</td>
<td align=left>
 For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>bc_dec_intr_frc_msg_msb_ready</td>
<td align=left>
 For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>bc_dec_intr_frc_ool</td>
<td align=left>
 For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>bc_dec_intr_frc_lock</td>
<td align=left>
 For debug only. 1'b1 will create the corresponding interrupt event if event is unmasked. Self-clear bit. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_intr_mask_msg_lsb_ready</td>
<td align=left>
 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_intr_mask_msg_msb_ready</td>
<td align=left>
 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_intr_mask_ool</td>
<td align=left>
 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>bc_dec_intr_mask_lock</td>
<td align=left>
 1'b1 will mask the corresponding interrupt event so mask bit should be set to 1'b0 to unmask the event contribution to the interrupt pin. <br>
Reset value is 0x1.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_7">TLB_RX_B_tlb_rx_b_status_7 - TLB_RX_B Status 7</a></b><br>
Address Offset = 32'h0000_d1e7<br>
Physical Address = 32'h0000_d1e7<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_7_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_7_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>prbs_chk_auto_detect_state</td>
<td align=left>
 Indicates the live state of the PRBS Auto-Detect state machine. <br>
 2'd0 = RESET&nbsp &nbsp &nbsp &nbsp&nbsp => Reset or unlock/search state. <br>
 2'd1 = SEARCH_LOCK&nbsp&nbsp => Inidcates that AUTO-DETECT is searching for the PRBS lock by changing the PRBS polynomials in round robin fashion. <br>
 2'd2 = DONE&nbsp &nbsp &nbsp &nbsp &nbsp => Indicates that AUTO-DETECT is locked. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_6">TLB_RX_B_tlb_rx_b_status_6 - TLB_RX_B Status 6</a></b><br>
Address Offset = 32'h0000_d1e8<br>
Physical Address = 32'h0000_d1e8<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_6_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_6_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_intr_msg_lsb_ready</td>
<td align=left>
 Status of the BC decoder LSB [15:0] message capture event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.<br>
&nbsp &nbsp&nbsp 1 - indicates interrupt is active.&nbsp&nbsp bc_dec_intr_mask_msg_lsb_ready register must be 1'b0 for this bit to set. Once unmasked it
is either set to 1'b1 by the frame msg_lsb_ready event or by the bc_dec_intr_frc_msg_lsb_ready bit.<br>
&nbsp &nbsp&nbsp 0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_msg_lsb_ready register bit.
This is the default state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_intr_msg_msb_ready</td>
<td align=left>
 Status of the BC decoder MSB [31:16] message capture event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.<br>
&nbsp &nbsp&nbsp 1 - indicates interrupt is active.&nbsp&nbsp bc_dec_intr_mask_msg_msb_ready register must be 1'b0 for this bit to set. Once unmasked it
is either set to 1'b1 by the frame msg_msb_ready event or by the bc_dec_intr_frc_msg_msb_ready bit.<br>
&nbsp &nbsp&nbsp 0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_msg_msb_ready register bit.
This is the default state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_intr_ool</td>
<td align=left>
 Status of the BC decoder Frame Lock event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.<br>
&nbsp &nbsp&nbsp 1 - indicates interrupt is active.&nbsp&nbsp bc_dec_intr_mask_ool register must be 1'b0 for this bit to set. Once unmasked it is either
set to 1'b1 by the frame ool event or by the bc_dec_intr_frc_ool bit.<br>
&nbsp &nbsp&nbsp 0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_ool register bit. This is
the default state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_intr_lock</td>
<td align=left>
 Status of the BC decoder Frame Lock event. It is cleared upon read. User needs to unmask the interrupt contribution for this event.<br>
&nbsp &nbsp&nbsp 1 - indicates interrupt is active.&nbsp&nbsp bc_dec_intr_mask_lock register must be 1'b0 for this bit to set. Once unmasked it is either
set to 1'b1 by the frame lock event or by the bc_dec_intr_frc_lock bit.<br>
&nbsp &nbsp&nbsp 0 - indicates interrupt is inactive. This state can be forced by masking the corresponding bc_dec_intr_mask_lock register bit. This is
the default state. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_intr</td>
<td align=left>
 Status of the BC decoder active high interrupt pin. It is cleared upon read. This is the aggregate (i.e. ORed) of all the BC decoder interrupts. User
needs to unmask the interrupt contributor events.<br>
&nbsp &nbsp&nbsp 1 - indicates interrupt is active.&nbsp&nbsp This state can be forced by the unmasking the individual interrupts and then asserting one
or more bc_dec_intr_frc* control regs for testing the ISRs withoutBC decoder is active. It is automatically asserted if any of the unmasked interrupt contributor
events happen. <br>
&nbsp &nbsp&nbsp 0 - indicates interrupt is inactive. This state can be forced by making all the mask bits as '0' which is the default. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_5">TLB_RX_B_tlb_rx_b_status_5 - TLB_RX_B Status 5</a></b><br>
Address Offset = 32'h0000_d1e9<br>
Physical Address = 32'h0000_d1e9<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_5_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_5_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_msg_type_cnt</td>
<td align=left>
 This indicates the BC frame error type cnt within 15 consecutive frames. New 15 frame window is started upon read of this register. Used for debug and
error analysis after BC decoder is locked. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_4">TLB_RX_B_tlb_rx_b_status_4 - TLB_RX_B Status 4</a></b><br>
Address Offset = 32'h0000_d1ea<br>
Physical Address = 32'h0000_d1ea<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_4_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_4_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_msg_type_cnt_ready</td>
<td align=left>
 1'b1 indicates that bc_dec_msg_type_cnt is captured a new value and ready to be read. It is cleared upon read of bc_dec_msg_type_cnt registers. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_msg_msb_ready</td>
<td align=left>
 1'b1 indicates that a new MSB message is captured in the register bc_dec_msg_msb and ready to be read. When MSB message is ready to be read the bc_dec_intr
interrupt pin will also be asserted. This registeris cleared when MSB message register is read. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_msg_lsb_ready</td>
<td align=left>
 1'b1 indicates that a new LSB message is captured in the register bc_dec_msg_lsb and ready to be read. When LSB message is ready to be read the bc_dec_intr
interrupt pin will also be asserted. This registeris cleared when LSB message register is read. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_3">TLB_RX_B_tlb_rx_b_status_3 - TLB_RX_B Status 3</a></b><br>
Address Offset = 32'h0000_d1eb<br>
Physical Address = 32'h0000_d1eb<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_3_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_3_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_msg_lsb</td>
<td align=left>
 This indicates the captured LSB message bits [15:0]. <br>
&nbsp &nbsp&nbsp Bits [12:0]&nbsp indicates the LSB bits [15:0] of the BC INFO field. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_2">TLB_RX_B_tlb_rx_b_status_2 - TLB_RX_B Status 2</a></b><br>
Address Offset = 32'h0000_d1ec<br>
Physical Address = 32'h0000_d1ec<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_2_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_msg_msb</td>
<td align=left>
 This indicates the captured MSB message bits [31:16]. <br>
&nbsp &nbsp&nbsp Bits [15:13] indicates the BC frame length encoding. <br>
&nbsp &nbsp&nbsp Bits [12:0]&nbsp indicates the MSB bits [28:16] of the BC INFO field. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_1">TLB_RX_B_tlb_rx_b_status_1 - TLB_RX_B Status 1</a></b><br>
Address Offset = 32'h0000_d1ed<br>
Physical Address = 32'h0000_d1ed<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_1_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_sm_state_one_hot</td>
<td align=left>
 This indicates the One Hot indication of the BD decoder FSM states. It is cleared upon read. Following is the mapping of bits and FSM states. <br>
&nbsp &nbsp bit 0&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp RESET&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp <br>
&nbsp &nbsp bit 1&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp ALIGN_SEARCH&nbsp &nbsp&nbsp <br>
&nbsp &nbsp bit 2&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp ALIGN_CHECK&nbsp &nbsp &nbsp <br>
&nbsp &nbsp bit 3&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp FRM_LOCK&nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_B_tlb_rx_b_status_0">TLB_RX_B_tlb_rx_b_status_0 - TLB_RX_B Status 0</a></b><br>
Address Offset = 32'h0000_d1ee<br>
Physical Address = 32'h0000_d1ee<br>
Verilog CL45 Address = {`TLB_RX_B_A, `tlb_rx_b_status_0_Adr}<br>
Verilog CL22 Address = {`TLB_RX_B_A, 4'h0}, `tlb_rx_b_status_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>sym_rotate_dly</td>
<td align=left>
 Live indication of symbol rotate or delay. Valid valid are 0 to 19. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_sm_state</td>
<td align=left>
 Live indication of BC decoder state machine state status. These are the state encodings. <br>
&nbsp &nbsp 2'd0&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp RESET&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp => reset state when bc_dec_en=0 or datapath reset
enabled&nbsp <br>
&nbsp &nbsp 2'd1&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp ALIGN_SEARCH&nbsp &nbsp &nbsp &nbsp&nbsp => word align search where first framing candidate is found
based upon no ECC error and 16 bits framing pattern match with 16 LSB bits of the received BC frame. <br>
&nbsp &nbsp 2'd2&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp ALIGN_CHECK&nbsp &nbsp &nbsp &nbsp &nbsp => word align found where framing candidate is checked for
consistency.&nbsp &nbsp <br>
&nbsp &nbsp 2'd3&nbsp &nbsp&nbsp =>&nbsp &nbsp &nbsp FRM_LOCK&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp => frame lock acheived state. Once in this state
then only bc_dec_en=0 will reset the BC decoder otherwise it will flywheel based on the frame length accepted in the ALIGN_SEARCH. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_ool</td>
<td align=left>
Back Channel Decoder out of LOCK Indication. This is a live indication of the status of the Back Channel Decoder out of LOCK. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 => BC decoder is in Out of LOCK state.&nbsp `<br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 => BC decoder is in LOCK state.&nbsp &nbsp &nbsp &nbsp&nbsp <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>bc_dec_lock</td>
<td align=left>
Back Channel Decoder LOCK Indication. This is a live indication of the status of the Back Channel Decoder LOCK. <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 1 => BC decoder is in LOCKED state.&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp 0 => BC decoder is out of LOCK state and state machine is searching for a LOCK.&nbsp &nbsp &nbsp &nbsp&nbsp
<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_B Registers">Return to TLB_RX_B: per lane register block [8 copies] Table</A><p>
<H1><a NAME="TLB_RX_C Registers">TLB_RX_C: per lane register block [8 copies] Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd1f0</td><td><A HREF="#TLB_RX_C_tlb_rx_c_config_0">TLB_RX_C_tlb_rx_c_config_0</A></td><td>TLB_RX_C Control 0</td></tr>
<tr>
<td align=center>0xd1f1</td><td><A HREF="#TLB_RX_C_tlb_rx_c_config_1">TLB_RX_C_tlb_rx_c_config_1</A></td><td>TLB_RX_B Control 1</td></tr>
<tr>
<td align=center>0xd1f5</td><td><A HREF="#TLB_RX_C_num_errors_in_fec_frames_status_hi">TLB_RX_C_num_errors_in_fec_frames_status_hi</A></td><td>TLB_RX_C Status 8</td></tr>
<tr>
<td align=center>0xd1f6</td><td><A HREF="#TLB_RX_C_num_errors_in_fec_frames_status_lo">TLB_RX_C_num_errors_in_fec_frames_status_lo</A></td><td>TLB_RX_C Status 7</td></tr>
<tr>
<td align=center>0xd1f7</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_7">TLB_RX_C_count_histogram_error_offset_7</A></td><td>TLB_RX_C Status 7</td></tr>
<tr>
<td align=center>0xd1f8</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_6">TLB_RX_C_count_histogram_error_offset_6</A></td><td>TLB_RX_C Status 6</td></tr>
<tr>
<td align=center>0xd1f9</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_5">TLB_RX_C_count_histogram_error_offset_5</A></td><td>TLB_RX_C Status 5</td></tr>
<tr>
<td align=center>0xd1fa</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_4">TLB_RX_C_count_histogram_error_offset_4</A></td><td>TLB_RX_C Status 4</td></tr>
<tr>
<td align=center>0xd1fb</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_3">TLB_RX_C_count_histogram_error_offset_3</A></td><td>TLB_RX_C Status 3</td></tr>
<tr>
<td align=center>0xd1fc</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_2">TLB_RX_C_count_histogram_error_offset_2</A></td><td>TLB_RX_C Status 2</td></tr>
<tr>
<td align=center>0xd1fd</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_1">TLB_RX_C_count_histogram_error_offset_1</A></td><td>TLB_RX_C Status 1</td></tr>
<tr>
<td align=center>0xd1fe</td><td><A HREF="#TLB_RX_C_count_histogram_error_offset_0">TLB_RX_C_count_histogram_error_offset_0</A></td><td>TLB_RX_C Status 0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TLB_RX_C_tlb_rx_c_config_0">TLB_RX_C_tlb_rx_c_config_0 - TLB_RX_C Control 0</a></b><br>
Address Offset = 32'h0000_d1f0<br>
Physical Address = 32'h0000_d1f0<br>
Verilog CL45 Address = {`TLB_RX_C_A, `tlb_rx_c_config_0_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `tlb_rx_c_config_0_A<br>
Reset Value = 16'h440c<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_fec_size</td>
<td align=left>
 Defines the size of the FEC frame.<br>
 Valid values for this field must be >= 6 <br>
 The frame size = (tlb_err_fec_size * 320) bits <br>
 To get 5440 bits FEC, N = 5440/320 = 17.<br>
Reset value is 0x11.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_fec_l_r_en</td>
<td align=left>
 If 1 implies that two fecs are processing the rx data. The error analyzer looks at only 20 bits out of a 40 bit word.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_fec_l_en</td>
<td align=left>
 If 1 implies that 20 MSBs of the 40 bit word are processed else 20 LSBs are processed.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_ignore_back_channel</td>
<td align=left>
 By setting this bit, the frame counter in the error analyzer continues count when back channel word arrives. <br>
 When back channel word arrives, the error analyzer treats it like a valid prbs code but assumes zero errors.<br>
 This is a debug feature. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_error_count_thresh</td>
<td align=left>
 Error threshold number beyond which the error analyzer would count a bad frame. <br>
 Valid values for this field are from 3-15 <br>
Reset value is 0x3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>tlb_err_clear_error_analyzer_status</td>
<td align=left>
 When a write is executed in this register, it will clear all the error analyzer registers.<br>
 This register is self-clear.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_tlb_rx_c_config_1">TLB_RX_C_tlb_rx_c_config_1 - TLB_RX_B Control 1</a></b><br>
Address Offset = 32'h0000_d1f1<br>
Physical Address = 32'h0000_d1f1<br>
Verilog CL45 Address = {`TLB_RX_C_A, `tlb_rx_c_config_1_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `tlb_rx_c_config_1_A<br>
Reset Value = 16'h0003<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_clear_status_on_read</td>
<td align=left>
 Enables read on clear for all error status counters <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_histogram_error_thresh</td>
<td align=left>
 Counts the number of errors in frames for x, x+1,..,x+7 errors in the FEC frames <br>
 Valid values for this field are from 3-8 <br>
Reset value is 0x3.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_num_errors_in_fec_frames_status_hi">TLB_RX_C_num_errors_in_fec_frames_status_hi - TLB_RX_C Status 8</a></b><br>
Address Offset = 32'h0000_d1f5<br>
Physical Address = 32'h0000_d1f5<br>
Verilog CL45 Address = {`TLB_RX_C_A, `num_errors_in_fec_frames_status_hi_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `num_errors_in_fec_frames_status_hi_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_error_hi</td>
<td align=left>
 Top 4 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames. <br>
 tlb_err_count_error_lo needs to be read before this status register to read the correct value <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_num_errors_in_fec_frames_status_lo">TLB_RX_C_num_errors_in_fec_frames_status_lo - TLB_RX_C Status 7</a></b><br>
Address Offset = 32'h0000_d1f6<br>
Physical Address = 32'h0000_d1f6<br>
Verilog CL45 Address = {`TLB_RX_C_A, `num_errors_in_fec_frames_status_lo_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `num_errors_in_fec_frames_status_lo_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_error_lo</td>
<td align=left>
 Bottom 16 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_7">TLB_RX_C_count_histogram_error_offset_7 - TLB_RX_C Status 7</a></b><br>
Address Offset = 32'h0000_d1f7<br>
Physical Address = 32'h0000_d1f7<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_7_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_7_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_7</td>
<td align=left>
 Number of times 'N+7' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_6">TLB_RX_C_count_histogram_error_offset_6 - TLB_RX_C Status 6</a></b><br>
Address Offset = 32'h0000_d1f8<br>
Physical Address = 32'h0000_d1f8<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_6_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_6_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_6</td>
<td align=left>
 Number of times 'N+6' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_5">TLB_RX_C_count_histogram_error_offset_5 - TLB_RX_C Status 5</a></b><br>
Address Offset = 32'h0000_d1f9<br>
Physical Address = 32'h0000_d1f9<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_5_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_5_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_5</td>
<td align=left>
 Number of times 'N+5' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_4">TLB_RX_C_count_histogram_error_offset_4 - TLB_RX_C Status 4</a></b><br>
Address Offset = 32'h0000_d1fa<br>
Physical Address = 32'h0000_d1fa<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_4_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_4_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_4</td>
<td align=left>
 Number of times 'N+4' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_3">TLB_RX_C_count_histogram_error_offset_3 - TLB_RX_C Status 3</a></b><br>
Address Offset = 32'h0000_d1fb<br>
Physical Address = 32'h0000_d1fb<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_3_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_3_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_3</td>
<td align=left>
 Number of times 'N+3' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_2">TLB_RX_C_count_histogram_error_offset_2 - TLB_RX_C Status 2</a></b><br>
Address Offset = 32'h0000_d1fc<br>
Physical Address = 32'h0000_d1fc<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_2_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_2</td>
<td align=left>
 Number of times 'N+2' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_1">TLB_RX_C_count_histogram_error_offset_1 - TLB_RX_C Status 1</a></b><br>
Address Offset = 32'h0000_d1fd<br>
Physical Address = 32'h0000_d1fd<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_1_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_1</td>
<td align=left>
 Number of times 'N+1' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<b><a NAME="TLB_RX_C_count_histogram_error_offset_0">TLB_RX_C_count_histogram_error_offset_0 - TLB_RX_C Status 0</a></b><br>
Address Offset = 32'h0000_d1fe<br>
Physical Address = 32'h0000_d1fe<br>
Verilog CL45 Address = {`TLB_RX_C_A, `count_histogram_error_offset_0_Adr}<br>
Verilog CL22 Address = {`TLB_RX_C_A, 4'h0}, `count_histogram_error_offset_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_count_histogram_error_offset_0</td>
<td align=left>
 Number of times 'N' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_RX_C Registers">Return to TLB_RX_C: per lane register block [8 copies] Table</A><p>
<H1><a NAME="MICRO_A Registers">MICRO_A: micro common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd200</td><td><A HREF="#MICRO_A_clock_control0">MICRO_A_clock_control0</A></td><td>Clock control registers 0</td></tr>
<tr>
<td align=center>0xd201</td><td><A HREF="#MICRO_A_reset_control0">MICRO_A_reset_control0</A></td><td>Reset control registers 0</td></tr>
<tr>
<td align=center>0xd202</td><td><A HREF="#MICRO_A_ahb_control0">MICRO_A_ahb_control0</A></td><td>rmi to ahb control registers 0</td></tr>
<tr>
<td align=center>0xd203</td><td><A HREF="#MICRO_A_ahb_status0">MICRO_A_ahb_status0</A></td><td>rmi to ahb status registers 0</td></tr>
<tr>
<td align=center>0xd204</td><td><A HREF="#MICRO_A_ahb_wraddr_lsw">MICRO_A_ahb_wraddr_lsw</A></td><td>rmi to ahb write address LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd205</td><td><A HREF="#MICRO_A_ahb_wraddr_msw">MICRO_A_ahb_wraddr_msw</A></td><td>rmi to ahb write address MSW (bits 31:16) register</td></tr>
<tr>
<td align=center>0xd206</td><td><A HREF="#MICRO_A_ahb_wrdata_lsw">MICRO_A_ahb_wrdata_lsw</A></td><td>rmi to ahb write data LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd207</td><td><A HREF="#MICRO_A_ahb_wrdata_msw">MICRO_A_ahb_wrdata_msw</A></td><td>rmi to ahb write data MSW (bits 31:16) register</td></tr>
<tr>
<td align=center>0xd208</td><td><A HREF="#MICRO_A_ahb_rdaddr_lsw">MICRO_A_ahb_rdaddr_lsw</A></td><td>rmi to ahb read address LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd209</td><td><A HREF="#MICRO_A_ahb_rdaddr_msw">MICRO_A_ahb_rdaddr_msw</A></td><td>rmi to ahb read address MSW (bits 31:16) register</td></tr>
<tr>
<td align=center>0xd20a</td><td><A HREF="#MICRO_A_ahb_rddata_lsw">MICRO_A_ahb_rddata_lsw</A></td><td>rmi to ahb read data LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd20b</td><td><A HREF="#MICRO_A_ahb_rddata_msw">MICRO_A_ahb_rddata_msw</A></td><td>rmi to ahb read data MSW (bits 31:16) register</td></tr>
<tr>
<td align=center>0xd20c</td><td><A HREF="#MICRO_A_pramif_control0">MICRO_A_pramif_control0</A></td><td>pram i/f to ahb control registers 0</td></tr>
<tr>
<td align=center>0xd20d</td><td><A HREF="#MICRO_A_pramif_ahb_wraddr_lsw">MICRO_A_pramif_ahb_wraddr_lsw</A></td><td>pram i/f to ahb write address LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd20e</td><td><A HREF="#MICRO_A_pramif_ahb_wraddr_msw">MICRO_A_pramif_ahb_wraddr_msw</A></td><td>pram i/f to ahb write address MSW (bits 31:16) register</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="MICRO_A_clock_control0">MICRO_A_clock_control0 - Clock control registers 0</a></b><br>
Address Offset = 32'h0000_d200<br>
Physical Address = 32'h0000_d200<br>
Verilog CL45 Address = {`MICRO_A_A, `clock_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `clock_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_master_clk_en</td>
<td align=left>
master clock enable:<br>
By default the clock to micro sub-system is disabled and <br>
only the micro control and status registers can be accessed through<br>
the RMIC interface. Setting this field to 1'b1 enable the master clock<br>
<br>
0 - disabled <br>
1 - enables <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_reset_control0">MICRO_A_reset_control0 - Reset control registers 0</a></b><br>
Address Offset = 32'h0000_d201<br>
Physical Address = 32'h0000_d201<br>
Verilog CL45 Address = {`MICRO_A_A, `reset_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `reset_control0_A<br>
Reset Value = 16'h4000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pram_if_rstb</td>
<td align=left>
PRAM interface reset :<br>
By default a reset to the PRAM interface is asserted, and&nbsp <br>
only the micro control and status registers can be accessed through<br>
the RMIC interface. Setting this field to 1'b1 de-assert a reset to the PRAM interface <br>
0 - asserted <br>
1 - de-asserted <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_sw_timestamp_timer_rstb</td>
<td align=left>
Timestamp timer software reset&nbsp <br>
This field allows the chip firmware to reset the timestamp timers in&nbsp <br>
"all Serdes cores to be be with 1 or 2 time units <br>
".<br>
"0 - asserted, Timestamp timer set 0<br>
".<br>
"1 - de-asserted,&nbsp normal operation <br>
".<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_master_rstb</td>
<td align=left>
master reset :<br>
By default a reset to micro controller sub-system is asserted, and&nbsp <br>
only the micro control and status registers can be accessed through<br>
the RMIC interface. Setting this field to 1'b1 de-assert a reset to the micro-subsystem<br>
<br>
0 - asserted <br>
1 - de-asserted <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_control0">MICRO_A_ahb_control0 - rmi to ahb control registers 0</a></b><br>
Address Offset = 32'h0000_d202<br>
Physical Address = 32'h0000_d202<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_autoinc_rdaddr_en</td>
<td align=left>
Automatic increment read address enable <br>
0 - disabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the constant address <br>
&nbsp &nbsp where the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds<br>
&nbsp &nbsp <br>
1 - enabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the start address <br>
&nbsp &nbsp where the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds<br>
&nbsp &nbsp the address automatically increments based on the micro_ra_rddatasize field after <br>
&nbsp &nbsp the read has been performed <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_autoinc_wraddr_en</td>
<td align=left>
Automatic increment write address enable <br>
0 - disabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the constant address <br>
&nbsp &nbsp where the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.<br>
&nbsp &nbsp <br>
1 - enabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the start address <br>
&nbsp &nbsp where the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.<br>
&nbsp &nbsp the address automatically increments based on the micro_ra_wrdatasize field after <br>
&nbsp &nbsp the write has been performed <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_init</td>
<td align=left>
Intialize code/data RAM<br>
2'b01: initailize code RAM - write zeroes to all locations<br>
2'b10: initialize data RAM - write zeroes to all loactions<br>
2'b00, 2'b11: ignored<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_rddatasize</td>
<td align=left>
read data size select <br>
'd0 : 8-bit&nbsp &nbsp <br>
'd1 : 16-bit&nbsp&nbsp <br>
'd2 : 32-bit&nbsp&nbsp <br>
'd3 : reserved <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_wrdatasize</td>
<td align=left>
write data size select <br>
'd0 : 8-bit&nbsp &nbsp <br>
'd1 : 16-bit&nbsp&nbsp <br>
'd2 : 32-bit&nbsp&nbsp <br>
'd3 : reserved <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_status0">MICRO_A_ahb_status0 - rmi to ahb status registers 0</a></b><br>
Address Offset = 32'h0000_d203<br>
Physical Address = 32'h0000_d203<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_status0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_initdone</td>
<td align=left>
When this bit is set, it indicate that code/data RAM initialization process is complete<br>
This reamins set until <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_wraddr_lsw">MICRO_A_ahb_wraddr_lsw - rmi to ahb write address LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d204<br>
Physical Address = 32'h0000_d204<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_wraddr_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_wraddr_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_wraddr_lsw</td>
<td align=left>
These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during write transactions<br>
bit 0 is not used during 16-bit transactions and <br>
bits[1:0] are not used during 32-bit transactions <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_wraddr_msw">MICRO_A_ahb_wraddr_msw - rmi to ahb write address MSW (bits 31:16) register</a></b><br>
Address Offset = 32'h0000_d205<br>
Physical Address = 32'h0000_d205<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_wraddr_msw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_wraddr_msw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_wraddr_msw</td>
<td align=left>
These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during write transactions<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_wrdata_lsw">MICRO_A_ahb_wrdata_lsw - rmi to ahb write data LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d206<br>
Physical Address = 32'h0000_d206<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_wrdata_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_wrdata_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_wrdata_lsw</td>
<td align=left>
These bits are used to generate the lower 16-bits of the data on the AHB-Lite bus during write transactions<br>
Write transaction on the AHB-Lite is initiated when this register is written <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_wrdata_msw">MICRO_A_ahb_wrdata_msw - rmi to ahb write data MSW (bits 31:16) register</a></b><br>
Address Offset = 32'h0000_d207<br>
Physical Address = 32'h0000_d207<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_wrdata_msw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_wrdata_msw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_wrdata_msw</td>
<td align=left>
These bits are used&nbsp to generate the upper 16-bits of the data on the AHB-Lite bus during write transactions<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_rdaddr_lsw">MICRO_A_ahb_rdaddr_lsw - rmi to ahb read address LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d208<br>
Physical Address = 32'h0000_d208<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_rdaddr_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_rdaddr_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_rdaddr_lsw</td>
<td align=left>
These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during read transactions<br>
bit 0 is not used during 16-bit transactions and <br>
bits[1:0] are not used during 32-bit transactions <br>
Read transaction is initiated on the AHB-Lite when this register is written <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_rdaddr_msw">MICRO_A_ahb_rdaddr_msw - rmi to ahb read address MSW (bits 31:16) register</a></b><br>
Address Offset = 32'h0000_d209<br>
Physical Address = 32'h0000_d209<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_rdaddr_msw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_rdaddr_msw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_rdaddr_msw</td>
<td align=left>
These bits are used by to generate the upper 16-bits of the address on the AHB-Lite bus during read transactions<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_rddata_lsw">MICRO_A_ahb_rddata_lsw - rmi to ahb read data LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d20a<br>
Physical Address = 32'h0000_d20a<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_rddata_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_rddata_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_rddata_lsw</td>
<td align=left>
These are the lower 16-bits of the read data from the AHB-Lite slave device <br>
Read transaction is initiated on the AHB-Lite when this register is read <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_ahb_rddata_msw">MICRO_A_ahb_rddata_msw - rmi to ahb read data MSW (bits 31:16) register</a></b><br>
Address Offset = 32'h0000_d20b<br>
Physical Address = 32'h0000_d20b<br>
Verilog CL45 Address = {`MICRO_A_A, `ahb_rddata_msw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `ahb_rddata_msw_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_rddata_msw</td>
<td align=left>
These are the upper 16-bits of the read data from the AHB-Lite slave device <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_pramif_control0">MICRO_A_pramif_control0 - pram i/f to ahb control registers 0</a></b><br>
Address Offset = 32'h0000_d20c<br>
Physical Address = 32'h0000_d20c<br>
Verilog CL45 Address = {`MICRO_A_A, `pramif_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `pramif_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pramif_en</td>
<td align=left>
When this bit is set, pram if interface can generate write transactions on the&nbsp <br>
AHB-Lite bus, the start address of the transaction is specifield <br>
in the pramif_ahb_wraddr_lsw and pramif_ahb_wraddr_msw fields <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_pramif_ahb_wraddr_lsw">MICRO_A_pramif_ahb_wraddr_lsw - pram i/f to ahb write address LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d20d<br>
Physical Address = 32'h0000_d20d<br>
Verilog CL45 Address = {`MICRO_A_A, `pramif_ahb_wraddr_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `pramif_ahb_wraddr_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pramif_ahb_wraddr_lsw</td>
<td align=left>
These bits are used to generate the lower 14-bits of the address on the AHB-Lite bus during pram interface write transactions<br>
bits[1:0] are not used for 32 transactions <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_A_pramif_ahb_wraddr_msw">MICRO_A_pramif_ahb_wraddr_msw - pram i/f to ahb write address MSW (bits 31:16) register</a></b><br>
Address Offset = 32'h0000_d20e<br>
Physical Address = 32'h0000_d20e<br>
Verilog CL45 Address = {`MICRO_A_A, `pramif_ahb_wraddr_msw_Adr}<br>
Verilog CL22 Address = {`MICRO_A_A, 4'h0}, `pramif_ahb_wraddr_msw_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pramif_ahb_wraddr_msw</td>
<td align=left>
These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during pram interface write transactions<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_A Registers">Return to MICRO_A: micro common register block for all lanes Table</A><p>
<H1><a NAME="MICRO_B Registers">MICRO_B: micro common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd210</td><td><A HREF="#MICRO_B_pvt_status0">MICRO_B_pvt_status0</A></td><td>pvt temperature status register 0</td></tr>
<tr>
<td align=center>0xd211</td><td><A HREF="#MICRO_B_rmi_ahb_control1">MICRO_B_rmi_ahb_control1</A></td><td>ahb control register 1</td></tr>
<tr>
<td align=center>0xd212</td><td><A HREF="#MICRO_B_rmi_ahb_status1">MICRO_B_rmi_ahb_status1</A></td><td>ahb status register 1</td></tr>
<tr>
<td align=center>0xd213</td><td><A HREF="#MICRO_B_rmi_ra_autoinc_nxt_wraddr_lsw">MICRO_B_rmi_ra_autoinc_nxt_wraddr_lsw</A></td><td>rmi to ahb auto-incremented write address LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd214</td><td><A HREF="#MICRO_B_rmi_ra_autoinc_nxt_rdaddr_lsw">MICRO_B_rmi_ra_autoinc_nxt_rdaddr_lsw</A></td><td>rmi to ahb auto-incremented read address LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd215</td><td><A HREF="#MICRO_B_rmi_pr_autoinc_nxt_wraddr_lsw">MICRO_B_rmi_pr_autoinc_nxt_wraddr_lsw</A></td><td>pram i/f to ahb auto-incremented write address LSW (bits 15:0) register</td></tr>
<tr>
<td align=center>0xd216</td><td><A HREF="#MICRO_B_rmi_pvt_control0">MICRO_B_rmi_pvt_control0</A></td><td>rmi pvt temperature control register 0</td></tr>
<tr>
<td align=center>0xd217</td><td><A HREF="#MICRO_B_rmi_ram_cr_crccontrol0">MICRO_B_rmi_ram_cr_crccontrol0</A></td><td>code ram crc control 0 register</td></tr>
<tr>
<td align=center>0xd218</td><td><A HREF="#MICRO_B_rmi_ram_cr_crcstatus0">MICRO_B_rmi_ram_cr_crcstatus0</A></td><td>code ram crc status 0 register</td></tr>
<tr>
<td align=center>0xd219</td><td><A HREF="#MICRO_B_rmi_micro_hardfault_control0">MICRO_B_rmi_micro_hardfault_control0</A></td><td>micro hard fault control 0 register</td></tr>
<tr>
<td align=center>0xd21a</td><td><A HREF="#MICRO_B_rmi_micro_sdk_status0">MICRO_B_rmi_micro_sdk_status0</A></td><td>micro SDK status 0 register</td></tr>
<tr>
<td align=center>0xd21b</td><td><A HREF="#MICRO_B_rmi_micro_debugger_id_lsw">MICRO_B_rmi_micro_debugger_id_lsw</A></td><td>micro debugger id bits [15:0]</td></tr>
<tr>
<td align=center>0xd21c</td><td><A HREF="#MICRO_B_rmi_micro_debugger_id_msw">MICRO_B_rmi_micro_debugger_id_msw</A></td><td>micro debugger id bits [27:16]</td></tr>
<tr>
<td align=center>0xd21d</td><td><A HREF="#MICRO_B_rmi_micro_misc_status0">MICRO_B_rmi_micro_misc_status0</A></td><td>micro misc status register</td></tr>
<tr>
<td align=center>0xd21e</td><td><A HREF="#MICRO_B_rmi_micro_debugger_control0">MICRO_B_rmi_micro_debugger_control0</A></td><td>micro debugger control register 0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="MICRO_B_pvt_status0">MICRO_B_pvt_status0 - pvt temperature status register 0</a></b><br>
Address Offset = 32'h0000_d210<br>
Physical Address = 32'h0000_d210<br>
Verilog CL45 Address = {`MICRO_B_A, `pvt_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `pvt_status0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pvt_tempdata_rmi</td>
<td align=left>
&nbsp&nbsp temperature data <br>
&nbsp&nbsp {6'd0,tempearture_data[9:0]} <br>
&nbsp&nbsp reads the current value of the temperature data capatured <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_ahb_control1">MICRO_B_rmi_ahb_control1 - ahb control register 1</a></b><br>
Address Offset = 32'h0000_d211<br>
Physical Address = 32'h0000_d211<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_ahb_control1_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_ahb_control1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_arg_microblk_sel</td>
<td align=left>
select micro to access it's amba bus registers through the registers interface <br>
0 - select micro 0 amba registers <br>
1 - select micro 1 amba registers <br>
2 - select micro 2 amba registers <br>
3 - select micro 3 amba registers <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_ack_timeout_dis</td>
<td align=left>
pmi_hp_ack_timeout disable <br>
When micro initates a read/write transctions on the pmi_hp bus <br>
it allows upto 256 clock cycles for pmi_hp_ack to be asserted <br>
If pmi_hp_ack_* is not received within this time, then it&nbsp <br>
 1. terminates the current transactions on the pmi_hp bus <br>
 2. set the pmi_hp_ack_timeout_status field of the ahbcommon_pmi_hp_status0 register.<br>
 3. performs the response error signaling on the micro AHB bus when micro_m0p_hresp_en field is set to 1'b1 <br>
This timeout period/error reporting/reponse error signaling can be disabled by setting this field i.e.<br>
0: enabled&nbsp <br>
1: disabled <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_ahb_status1">MICRO_B_rmi_ahb_status1 - ahb status register 1</a></b><br>
Address Offset = 32'h0000_d212<br>
Physical Address = 32'h0000_d212<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_ahb_status1_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_ahb_status1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pr_default_slave_error</td>
<td align=left>
PRAM interface default slave error detected. PRAM interface attempted to access un-used address<br>
1 - error detected - latched high clear on read <br>
0 - no error <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_default_slave_error</td>
<td align=left>
register interface default slave error detected. Register interface attempted to access un-used address<br>
1 - error detected - latched high clear on read <br>
0 - no error <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_ra_autoinc_nxt_wraddr_lsw">MICRO_B_rmi_ra_autoinc_nxt_wraddr_lsw - rmi to ahb auto-incremented write address LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d213<br>
Physical Address = 32'h0000_d213<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_ra_autoinc_nxt_wraddr_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_ra_autoinc_nxt_wraddr_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_autoinc_nxt_wraddr_lsw</td>
<td align=left>
When the micro_autoinc_wraddr_en is set, then these bits <br>
indicate the lower 16-bits of the address that will be used <br>
during the next write transaction.&nbsp <br>
These bits allow address tracking when rmi interface auto address <br>
increment mode is used<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_ra_autoinc_nxt_rdaddr_lsw">MICRO_B_rmi_ra_autoinc_nxt_rdaddr_lsw - rmi to ahb auto-incremented read address LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d214<br>
Physical Address = 32'h0000_d214<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_ra_autoinc_nxt_rdaddr_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_ra_autoinc_nxt_rdaddr_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_autoinc_nxt_rdaddr_lsw</td>
<td align=left>
When the micro_autoinc_rdaddr_en is set, then these bits <br>
indicate the lower 16-bits of the address that will be used <br>
during the next read transaction.&nbsp <br>
These bits allow address tracking when rmi interface auto address <br>
increment mode is used<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_pr_autoinc_nxt_wraddr_lsw">MICRO_B_rmi_pr_autoinc_nxt_wraddr_lsw - pram i/f to ahb auto-incremented write address LSW (bits 15:0) register</a></b><br>
Address Offset = 32'h0000_d215<br>
Physical Address = 32'h0000_d215<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_pr_autoinc_nxt_wraddr_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_pr_autoinc_nxt_wraddr_lsw_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pr_autoinc_nxt_wraddr_lsw</td>
<td align=left>
When pram interface is used to write to the code/data RAM <br>
then these bits indicate the lower 16-bits of the address that will be used <br>
during the next write transaction.&nbsp <br>
These bits allow address tracking <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_pvt_control0">MICRO_B_rmi_pvt_control0 - rmi pvt temperature control register 0</a></b><br>
Address Offset = 32'h0000_d216<br>
Physical Address = 32'h0000_d216<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_pvt_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_pvt_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pvt_tempdata_frc</td>
<td align=left>
temperature dat force enable <br>
When micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcval<br>
field is used to set the temperature value. The temperature value can be read <br>
via micro_pvt_tempdata_rmi field of the pvt_status0 register or <br>
via ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pvt_tempdata_frcval</td>
<td align=left>
temperature data force value<br>
When micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcval<br>
field is used to set the temperature value. The temperature value can be read <br>
via micro_pvt_tempdata_rmi field of the pvt_status0 register or <br>
via ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_ram_cr_crccontrol0">MICRO_B_rmi_ram_cr_crccontrol0 - code ram crc control 0 register</a></b><br>
Address Offset = 32'h0000_d217<br>
Physical Address = 32'h0000_d217<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_ram_cr_crccontrol0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_ram_cr_crccontrol0_A<br>
Reset Value = 16'h0003<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_crc_prtsel</td>
<td align=left>
This field selects the Code RAM port to be used for CRC calculation&nbsp <br>
&nbsp 0 - Select Port A <br>
&nbsp 1 - Select Port B <br>
<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_crc_init</td>
<td align=left>
Code RAM CRC16 CCITT checksum initialize <br>
When thes micro_cr_crc_init is set to 1'b1, it initialize CRC16 CCITT checksum to 16'hFFFF <br>
{micro_cr_crc_init, micro_cr_crc_calc_en} <br>
2'b1x&nbsp&nbsp - initialize crc checksum to 16'hFFFF <br>
2'b01&nbsp&nbsp - update/calculate CRC upon writes to the code RAM <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_crc_calc_en</td>
<td align=left>
Calculate/Update Code RAM CRC16 CCITT checksum enable <br>
1: calculate new CRC16 CCITT checksum when code RAM is written <br>
0: do not calculate (or stop calculating) CRC16 CCITT checksum when code RAM is written <br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_ram_cr_crcstatus0">MICRO_B_rmi_ram_cr_crcstatus0 - code ram crc status 0 register</a></b><br>
Address Offset = 32'h0000_d218<br>
Physical Address = 32'h0000_d218<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_ram_cr_crcstatus0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_ram_cr_crcstatus0_A<br>
Reset Value = 16'hffff<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_cr_crc_checksum</td>
<td align=left>
 This field indicate the current crc16 ccitt checksum.&nbsp&nbsp <br>
Reset value is 0xffff.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_micro_hardfault_control0">MICRO_B_rmi_micro_hardfault_control0 - micro hard fault control 0 register</a></b><br>
Address Offset = 32'h0000_d219<br>
Physical Address = 32'h0000_d219<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_micro_hardfault_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_micro_hardfault_control0_A<br>
Reset Value = 16'h0e01<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_m0p_default_slave_error_hresp_en</td>
<td align=left>
Enable HRESP hard fault signaling when M0P detects default slave error. <br>
Default slave error are detected when M0P attempted to access un-used address<br>
1 - Enable <br>
0 - Disable <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_ack_timeout_hresp_en</td>
<td align=left>
Enable HRESP hard fault signaling&nbsp when pmi_hp_ack signal timeout on the pmi_hp bus <br>
does not toggle within 256 clock cycle <br>
1 - Enable <br>
0 - Disable <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_word_access_err_hresp_en</td>
<td align=left>
Enable HRESP hard fault signaling when M0P performs 32-bit operations to access on pmi_hp bus <br>
Only 8/16-bits operations are allowed <br>
1 - Enable interrupt on IRQ2<br>
0 - Disable <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_error_hresp_en</td>
<td align=left>
Enable HRESP hard fault signaling when pmi_hp_error signal is asserted by RMIC <br>
during pmi_hp bus tranactions <br>
1 - Enable <br>
0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_m0p_default_slave_error_intr_en</td>
<td align=left>
Enable interrupt on IRQ2 when M0P detects default slave error. <br>
Default slave error are detected when M0P attempted to access un-used address<br>
1 - Enable <br>
0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_ack_timeout_intr_en</td>
<td align=left>
Enable interrupt on IRQ2 when pmi_hp_ack signal timeout on the pmi_hp bus <br>
does not toggle within 256 clock cycle <br>
1 - Enable <br>
0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_word_access_err_intr_en</td>
<td align=left>
Enable interrupt on IRQ2 when M0P performs 32-bit operations to access on pmi_hp bus <br>
Only 8/16-bits operations are allowed <br>
1 - Enable interrupt on IRQ2<br>
0 - Disable <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_error_intr_en</td>
<td align=left>
Enable interrupt on IRQ2 when pmi_hp_error signal is asserted by RMIC <br>
during pmi_hp bus tranactions <br>
1 - Enable <br>
0 - Disable <br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_micro_sdk_status0">MICRO_B_rmi_micro_sdk_status0 - micro SDK status 0 register</a></b><br>
Address Offset = 32'h0000_d21a<br>
Physical Address = 32'h0000_d21a<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_micro_sdk_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_micro_sdk_status0_A<br>
Reset Value = 16'h4000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_num_uc_cores</td>
<td align=left>
Number of micro cores in the micro controller subsystem <br>
range is 1 to 15 <br>
Reset value is 4.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_uc_active_3</td>
<td align=left>
Indicates if micro core 3 is active <br>
1 - active <br>
0 - not active <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_uc_active_2</td>
<td align=left>
Indicates if micro core 2 is active <br>
1 - active <br>
0 - not active <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_uc_active_1</td>
<td align=left>
Indicates if micro core 1 is active <br>
1 - active <br>
0 - not active <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_uc_active_0</td>
<td align=left>
Indicates if micro core 0 is active <br>
1 - active <br>
0 - not active <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_micro_debugger_id_lsw">MICRO_B_rmi_micro_debugger_id_lsw - micro debugger id bits [15:0]</a></b><br>
Address Offset = 32'h0000_d21b<br>
Physical Address = 32'h0000_d21b<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_micro_debugger_id_lsw_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_micro_debugger_id_lsw_A<br>
Reset Value = 16'h617f<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_debugger_id_lsw</td>
<td align=left>
micro debugger id bits [15:0]<br>
32bit debugger id consists of [31:0] = {micro core instance_id[3:0], prtad_strap[4:0], revid0[10:0], brcm jtag id bits [11:0]} <br>
Where:<br>
&nbsp &nbsp micro core instance id[3:0]&nbsp = 0,1,2,3..15 for micro core 0,1,2,3..15. Maps to bits [31:28]. Please see micro_num_uc_cores <br>
&nbsp &nbsp prtad_strap[4:0]&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp = external input, shared with mdio controller. Maps to bits [27:23] <br>
&nbsp &nbsp revid0[10:0]&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp = revid0 bits [10:0]. Map bits[22:12] <br>
&nbsp &nbsp BRCM jtag ID[11:0]&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp = {JEP106 continuation[3:0], JEP106 identification[6:0], 1'b1} = 12'h17F. Maps to bits
[11:0] <br>
Reset value is 0x617f.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_micro_debugger_id_msw">MICRO_B_rmi_micro_debugger_id_msw - micro debugger id bits [27:16]</a></b><br>
Address Offset = 32'h0000_d21c<br>
Physical Address = 32'h0000_d21c<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_micro_debugger_id_msw_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_micro_debugger_id_msw_A<br>
Reset Value = 16'h0036<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_debugger_id_msw</td>
<td align=left>
micro debugger id bits [27:16] <br>
32bit debugger id consists of [31:0] = {micro core instance_id[3:0], prtad_strap[4:0], revid0[10:0], brcm jtag id bits [11:0]} <br>
Where:<br>
&nbsp &nbsp micro core instance id[3:0]&nbsp = 0,1,2,3..15 for micro core 0,1,2,3..15. Maps to bits [31:28]. Please see micro_num_uc_cores <br>
&nbsp &nbsp prtad_strap[4:0]&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp = external input, shared with mdio controller. Maps to bits [27:23] <br>
&nbsp &nbsp revid0[10:0]&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp = revid0 bits [10:0]. Map bits[22:12] <br>
&nbsp &nbsp BRCM jtag ID[11:0]&nbsp &nbsp &nbsp &nbsp &nbsp&nbsp = {JEP106 continuation[3:0], JEP106 identification[6:0], 1'b1} = 12'h17F. Maps to bits
[11:0] <br>
 Note: the default value assue prtad_strap = 5'd0 <br>
Reset value is 0x36.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_micro_misc_status0">MICRO_B_rmi_micro_misc_status0 - micro misc status register</a></b><br>
Address Offset = 32'h0000_d21d<br>
Physical Address = 32'h0000_d21d<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_micro_misc_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_micro_misc_status0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pr_autoinc_nxt_wraddr_msb</td>
<td align=left>
When pram interface is used to write to the code/data RAM <br>
then {micro_pr_autoinc_nxt_wraddr_msb, micro_pr_autoinc_nxt_wraddr_lsw[15:0]} <br>
indicate the address that will be used during the next write transaction.&nbsp <br>
These bits allow address tracking <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_autoinc_nxt_rdaddr_msb</td>
<td align=left>
When the micro_autoinc_rdaddr_en is set, then&nbsp <br>
{micro_ra_autoinc_nxt_rdaddr_msb, micro_ra_autoinc_nxt_rdaddr_lsw[15:0]} indicate <br>
{address that will be used during the next read transaction. <br>
These bits allow address tracking when rmi interface auto address <br>
increment mode is used<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_autoinc_nxt_wraddr_msb</td>
<td align=left>
When the micro_autoinc_wraddr_en is set to 1, then <br>
{micro_ra_autoinc_nxt_wraddr_msb, micro_ra_autoinc_nxt_wraddr_lsw[15:0]} <br>
indicate address that will be used during the next write transaction. <br>
These bits allow address tracking when rmi interface auto address <br>
increment mode is used<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_B_rmi_micro_debugger_control0">MICRO_B_rmi_micro_debugger_control0 - micro debugger control register 0</a></b><br>
Address Offset = 32'h0000_d21e<br>
Physical Address = 32'h0000_d21e<br>
Verilog CL45 Address = {`MICRO_B_A, `rmi_micro_debugger_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_B_A, 4'h0}, `rmi_micro_debugger_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_debugger_id_frc</td>
<td align=left>
micro debugger id force enable<br>
"micro_debugger_id_frc and micro_debugger_id_frcval are used to override portion of the micro debugger ID <br>
<br>
Please note that the debugger ID should only be changed while all of the micro cores are in reset i.e.&nbsp <br>
micro_master_rstb = 1'b0 to avoid any problems <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_debugger_id_frcval</td>
<td align=left>
micro debugger id bits [27:20] force value <br>
The micro debugger has 32bit id. Bit 27 to 20 can be forced to different value <br>
using micro_debugger_id_frc and micro_debugger_id_frcval fields i.e. <br>
&nbsp &nbsp micro_debugger_id[31:28]&nbsp = micro core instance id[3:0], i.e. 0,1,2,3 .... 15 <br>
&nbsp &nbsp micro_debugger_id[27:23]&nbsp = micro_debugger_id_frc ? micro_debugger_id_frcval[7:3] : prtad_strap[4:0];&nbsp <br>
&nbsp &nbsp micro_debugger_id[22:20]&nbsp = micro_debugger_id_frc ? micro_debugger_id_frcval[2:0] : revid0[10:8] <br>
&nbsp &nbsp micro_debugger_id[19:12]&nbsp = revid0[7:0] <br>
"&nbsp &nbsp micro_debugger_id[19:12]&nbsp = BRCM jtag ID[11:0] <br>
<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#MICRO_B Registers">Return to MICRO_B: micro common register block for all lanes Table</A><p>
<H1><a NAME="MICRO_C Registers">MICRO_C: micro common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd220</td><td><A HREF="#MICRO_C_ram_ecccontrol0">MICRO_C_ram_ecccontrol0</A></td><td>ram ecc control 0</td></tr>
<tr>
<td align=center>0xd221</td><td><A HREF="#MICRO_C_ram_ecccontrol1">MICRO_C_ram_ecccontrol1</A></td><td>ram ecc control 1</td></tr>
<tr>
<td align=center>0xd222</td><td><A HREF="#MICRO_C_ram_eccstatus0">MICRO_C_ram_eccstatus0</A></td><td>ram ecc status 0</td></tr>
<tr>
<td align=center>0xd223</td><td><A HREF="#MICRO_C_ram_eccstatus1">MICRO_C_ram_eccstatus1</A></td><td>ram ecc status 1</td></tr>
<tr>
<td align=center>0xd224</td><td><A HREF="#MICRO_C_ram_eccstatus2">MICRO_C_ram_eccstatus2</A></td><td>ram ecc status 2</td></tr>
<tr>
<td align=center>0xd225</td><td><A HREF="#MICRO_C_ram_testifcontrol0">MICRO_C_ram_testifcontrol0</A></td><td>ram test interface control 0</td></tr>
<tr>
<td align=center>0xd226</td><td><A HREF="#MICRO_C_ram_testifcontrol1">MICRO_C_ram_testifcontrol1</A></td><td>ram test interface control 1</td></tr>
<tr>
<td align=center>0xd227</td><td><A HREF="#MICRO_C_ram_control0">MICRO_C_ram_control0</A></td><td>ram configuration register 0</td></tr>
<tr>
<td align=center>0xd228</td><td><A HREF="#MICRO_C_ram_control1">MICRO_C_ram_control1</A></td><td>ram configuration register 1</td></tr>
<tr>
<td align=center>0xd229</td><td><A HREF="#MICRO_C_rmi_ext_intr_control0">MICRO_C_rmi_ext_intr_control0</A></td><td>rmi external interrupt control register 0</td></tr>
<tr>
<td align=center>0xd22a</td><td><A HREF="#MICRO_C_rmi_ext_intr_status0">MICRO_C_rmi_ext_intr_status0</A></td><td>rmi external interrupt status register 0</td></tr>
<tr>
<td align=center>0xd22b</td><td><A HREF="#MICRO_C_rmi_pmi_if_control0">MICRO_C_rmi_pmi_if_control0</A></td><td>pmi interface control register 0</td></tr>
<tr>
<td align=center>0xd22c</td><td><A HREF="#MICRO_C_rmi_silicon_debug_control0">MICRO_C_rmi_silicon_debug_control0</A></td><td>Silicon debug control register 0</td></tr>
<tr>
<td align=center>0xd22d</td><td><A HREF="#MICRO_C_rmi_silicon_debug_status0">MICRO_C_rmi_silicon_debug_status0</A></td><td>Silicon debug status register 0</td></tr>
<tr>
<td align=center>0xd22e</td><td><A HREF="#MICRO_C_ram_control2">MICRO_C_ram_control2</A></td><td>ram configuration register 2</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="MICRO_C_ram_ecccontrol0">MICRO_C_ram_ecccontrol0 - ram ecc control 0</a></b><br>
Address Offset = 32'h0000_d220<br>
Physical Address = 32'h0000_d220<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_ecccontrol0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_ecccontrol0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:13</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_ecc_debug_prtsel</td>
<td align=left>
The field selects the RAM port to used for ECC debug and software ECC mode: <br>
&nbsp 0 - Select Port A <br>
&nbsp 1 - Select Port B <br>
<br>
Assumptions: <br>
&nbsp a.&nbsp Only one RAM (code or data) is used during ECC debug, therefore <br>
&nbsp &nbsp &nbsp micro_ra_ecc_wrdata and micro_ra_ecc_rddata fields are shared&nbsp <br>
&nbsp &nbsp &nbsp between Code and Data RAM <br>
&nbsp b.&nbsp Only one port RAM (port A or port B) used during ECC debug, therefore <br>
&nbsp &nbsp &nbsp micro_dr_ecc_err_addr, micro_dr_ecc_corr_err, and micro_dr_ecc_corr_err <br>
&nbsp &nbsp &nbsp fields are shared between Port A and Port B <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_ecc_corrupt</td>
<td align=left>
This field allows the ecc codes to be corrupted in data RAM for testing.<br>
2'b00 - normal mode&nbsp <br>
2'b01 - corrupt the ECC code written into the data RAM <br>
2'b10 - corrupt data - add 1 bit data error on the RX side <br>
2'b11 - corrupt data - add 2 bit data error on the RA side <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_ecc_frc_disable</td>
<td align=left>
ecc force disable for data RAM <br>
0: ECC Enabled&nbsp - ECC error code generation determine by the micro_eccg_mode field <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp ECC error checking enabled in hardware mode only <br>
1: ECC Disabled - ECC error codes values written into the RAM set to zero <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp ECC error checking disabled <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_eccg_mode</td>
<td align=left>
ecc code generation mode for data RAM<br>
0: Hardware mode - ECC code generated by hardware, ECC error checking enabled<br>
1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAM<br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp ECC error checking disabled. This mode is only supported <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp when register interface is used <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_ecc_debug_prtsel</td>
<td align=left>
The field selects the RAM port to used for ECC debug and software ECC mode: <br>
&nbsp 0 - Select Port A <br>
&nbsp 1 - Select Port B <br>
<br>
Assumptions: <br>
&nbsp a.&nbsp Only one RAM (code or data) is used during ECC debug, therefore <br>
&nbsp &nbsp &nbsp micro_ra_ecc_wrdata and micro_ra_ecc_rddata fields are shared&nbsp <br>
&nbsp &nbsp &nbsp between Code and Data RAM <br>
&nbsp b.&nbsp Only one port RAM (port A or port B) used during ECC debug, therefore <br>
&nbsp &nbsp &nbsp micro_cr_ecc_err_addr, micro_cr_ecc_corr_err, and micro_cr_ecc_corr_err <br>
&nbsp &nbsp &nbsp fields are shared between Port A and Port B <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_ecc_corrupt</td>
<td align=left>
This field allows the ecc codes to be corrupted in code RAM for testing.<br>
2'b00 - normal mode&nbsp <br>
2'b01 - corrupt the ECC code written into the code/data RAM <br>
2'b10 - corrupt data - add 1 bit data error on the RX side <br>
2'b11 - corrupt data - add 2 bit data error on the RA side <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_ecc_frc_disable</td>
<td align=left>
ecc force disable for code RAM <br>
0: ECC Enabled&nbsp - ECC error code generation determine by the micro_eccg_mode field <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp ECC error checking enabled in hardware mode only <br>
1: ECC Disabled - ECC error codes values written into the RAM set to zero <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp ECC error checking disabled <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_eccg_mode</td>
<td align=left>
ecc code generation mode for code RAM <br>
0: Hardware mode - ECC code generated by hardware, ECC error checking enabled<br>
1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAM<br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp ECC error checking disabled. This mode is only supported <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp&nbsp when register interface is used <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_ecccontrol1">MICRO_C_ram_ecccontrol1 - ram ecc control 1</a></b><br>
Address Offset = 32'h0000_d221<br>
Physical Address = 32'h0000_d221<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_ecccontrol1_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_ecccontrol1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_ra_ecc_wrdata</td>
<td align=left>
This foield is used to write the ECC codes into the code/data RAM when ECC software modes is enabled <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_eccstatus0">MICRO_C_ram_eccstatus0 - ram ecc status 0</a></b><br>
Address Offset = 32'h0000_d222<br>
Physical Address = 32'h0000_d222<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_eccstatus0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_eccstatus0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_cr_ecc_address_status</td>
<td align=left>
First ecc error address detected in the Code RAM <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_eccstatus1">MICRO_C_ram_eccstatus1 - ram ecc status 1</a></b><br>
Address Offset = 32'h0000_d223<br>
Physical Address = 32'h0000_d223<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_eccstatus1_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_eccstatus1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_ra_ecc_rddata</td>
<td align=left>
 When the register interface is used to read code/data RAM, then this field provides <br>
 ECC codes currently stored in the code/data RAM<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_eccstatus2">MICRO_C_ram_eccstatus2 - ram ecc status 2</a></b><br>
Address Offset = 32'h0000_d224<br>
Physical Address = 32'h0000_d224<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_eccstatus2_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_eccstatus2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_dr_ecc_address_status</td>
<td align=left>
First ecc error address detected in the Data RAM <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_testifcontrol0">MICRO_C_ram_testifcontrol0 - ram test interface control 0</a></b><br>
Address Offset = 32'h0000_d225<br>
Physical Address = 32'h0000_d225<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_testifcontrol0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_testifcontrol0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_tm</td>
<td align=left>
Code RAM Test Mode. <br>
&nbsp These pins are used to put Code RAM the instance into various test <br>
&nbsp modes that can be used for a number of different purposes <br>
&nbsp including extended screening, yield improvement and debug. <br>
&nbsp The default mode of the instance is tm<?:0>='d0. It is&nbsp <br>
&nbsp highly recommended that the user has control over all the <br>
&nbsp tm<?:0> inputs. All tm<?:0> inputs are asynchronous. See&nbsp <br>
&nbsp the Test Modes section of the on line M16SP Web&nbsp <br>
&nbsp Specification for further details. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_testifcontrol1">MICRO_C_ram_testifcontrol1 - ram test interface control 1</a></b><br>
Address Offset = 32'h0000_d226<br>
Physical Address = 32'h0000_d226<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_testifcontrol1_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_testifcontrol1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:09</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_tm</td>
<td align=left>
Data RAM Test Mode. <br>
&nbsp These pins are used to put Code RAM the instance into various test <br>
&nbsp modes that can be used for a number of different purposes <br>
&nbsp including extended screening, yield improvement and debug. <br>
&nbsp The default mode of the instance is tm<?:0>='d0. It is&nbsp <br>
&nbsp highly recommended that the user has control over all the <br>
&nbsp tm<?:0> inputs. All tm<?:0> inputs are asynchronous. See&nbsp <br>
&nbsp the Test Modes section of the on line M16SP Web&nbsp <br>
&nbsp Specification for further details. <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_control0">MICRO_C_ram_control0 - ram configuration register 0</a></b><br>
Address Offset = 32'h0000_d227<br>
Physical Address = 32'h0000_d227<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_control0_A<br>
Reset Value = 16'h8382<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_lowpower_en</td>
<td align=left>
Data RAM low power enable<br>
1 - Enabled. Gate of the chip select to the Data RAM when memory is not being acccessed to save dynamic power <br>
&nbsp &nbsp (i.e. mem_cs = ~rg_dr_lowpower_en & rg_master_rstb & rg_dr_access_en). <br>
0 - Disabled<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_prif_prtsel</td>
<td align=left>
Selects Data RAM Port to used when writing memory through the PRAM interface <br>
0 - Port A <br>
1 - Port B <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_raif_prtsel</td>
<td align=left>
Selects Data RAM Port to used when accessing the memory through the register interface <br>
0 - Port A <br>
1 - Port B <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_ignore_micro_code_writes</td>
<td align=left>
Data RAM ignore micro writes to the code portion of the RAM <br>
0 - Allow writes <br>
1 - Ignore writes <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_access_en</td>
<td align=left>
Data RAM access enable <br>
0 - Disabled. RAM address, data, chip select and write enable are set to inactive state <br>
&nbsp &nbsp to prevent timing violations from corrupting the contents of the RAM <br>
&nbsp &nbsp The API software should clear this field before loading the firmware and also re-starting the micro<br>
1 - Enabled.&nbsp <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_lowpower_en</td>
<td align=left>
Code RAM low power enable<br>
1 - Enabled. Gate of the chip select to the Code RAM when memory is not being acccessed to save dynamic power <br>
&nbsp &nbsp (i.e. mem_cs = ~rg_cr_lowpower_en & rg_master_rstb & rg_cr_access_en). <br>
0 - Disabled<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_prif_prtsel</td>
<td align=left>
Selects Code RAM Port to used when writing memory through the PRAM interface <br>
0 - Port A <br>
1 - Port B <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_raif_prtsel</td>
<td align=left>
Selects Code RAM Port to used when accessing the memory through the register interface <br>
0 - Port A <br>
1 - Port B <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_ignore_micro_code_writes</td>
<td align=left>
Code RAM ignore micro writes to the code portion of the RAM <br>
0 - Allow writes <br>
1 - Ignore writes <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_access_en</td>
<td align=left>
Code RAM access enable <br>
0 - Disabled. RAM address, data, chip select and write enable are set to inactive state <br>
&nbsp &nbsp to prevent timing violations from corrupting the contents of the RAM <br>
&nbsp &nbsp The API software should clear this field before loading the firmware and also re-starting the micro<br>
1 - Enabled.&nbsp <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_control1">MICRO_C_ram_control1 - ram configuration register 1</a></b><br>
Address Offset = 32'h0000_d228<br>
Physical Address = 32'h0000_d228<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_control1_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_control1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dr_code_size</td>
<td align=left>
Data RAM - allocation for code storgae <br>
The DATA_RAM_SIZE=32KB and this field is used to allocate data RAM for code storgae on a 1KB granualarity <br>
7'd0&nbsp : data RAM allocation for code = 0KB,&nbsp data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code <br>
7'd1&nbsp : data RAM allocation for code = 1KB,&nbsp data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code <br>
7'd2&nbsp : data RAM allocation for code = 2KB,&nbsp data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code <br>
...&nbsp&nbsp : data RAM allocation for code = .. ,&nbsp data RAM allocation for data = ..&nbsp <br>
...&nbsp&nbsp : data RAM allocation for code = .. ,&nbsp data RAM allocation for data = ..&nbsp <br>
7'd31 : data RAM allocation for code = 31KB, data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code <br>
7'd32 : data RAM allocation for code = 32KB, data RAM allocation for data = DATA_RAM_SIZE - data RAM allocation for code <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_cr_data_size</td>
<td align=left>
Code RAM - allocation for data storgae <br>
The CODE_RAM_SIZE=64KB and this field is used to allocate code RAM for data storgae on a 1KB granualarity <br>
7'd0&nbsp : code RAM allocation for data = 0KB,&nbsp code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data <br>
7'd1&nbsp : code RAM allocation for data = 1KB,&nbsp code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data <br>
7'd2&nbsp : code RAM allocation for data = 2KB,&nbsp code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data <br>
...&nbsp&nbsp : code RAM allocation for data = .. ,&nbsp code RAM allocation for code = ..&nbsp <br>
...&nbsp&nbsp : code RAM allocation for data = .. ,&nbsp code RAM allocation for code = ..&nbsp <br>
7'd63 : code RAM allocation for data = 63KB, code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data <br>
7'd64 : code RAM allocation for data = 64KB, code RAM allocation for code = CODE_RAM_SIZE - code RAM allocation for data <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_rmi_ext_intr_control0">MICRO_C_rmi_ext_intr_control0 - rmi external interrupt control register 0</a></b><br>
Address Offset = 32'h0000_d229<br>
Physical Address = 32'h0000_d229<br>
Verilog CL45 Address = {`MICRO_C_A, `rmi_ext_intr_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `rmi_ext_intr_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_mbox_msgout_intr_en</td>
<td align=left>
Mailbox memssage out Interrupt Enable <br>
When this field is set to 1'b1 then the micro_rmi_mbox_msgout_status_or field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_m0p_systemresetreq_intr_en</td>
<td align=left>
M0P systemresetreq interrupt enable<br>
When this field is set to 1'b1 then the micro_rmi_m0_systemresetreq_status_or field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_m0p_lockup_intr_en</td>
<td align=left>
M0P lockup interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_m0p_lockup_status_or field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_dr_ecc_multirow_err_intr_en</td>
<td align=left>
Data RAM ECC error on multiple row detect interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_dr_ecc_uncorr_err_intr_en</td>
<td align=left>
Data RAM ECC 2 bit un-correctable error detect interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_dr_ecc_corr_err_intr_en</td>
<td align=left>
Data RAM ECC 1 bit correctable error detect interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_cr_ecc_multirow_err_intr_en</td>
<td align=left>
Code RAM ECC error on multiple row detect interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_cr_ecc_uncorr_err_intr_en</td>
<td align=left>
Code RAM ECC 2 bit un-correctable error detect interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_rmi_cr_ecc_corr_err_intr_en</td>
<td align=left>
Code RAM ECC 1 bit correctable error detect interrupt enable <br>
When this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0<br>
registers generate an interrupt on the micro_ext_intr pin<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_rmi_ext_intr_status0">MICRO_C_rmi_ext_intr_status0 - rmi external interrupt status register 0</a></b><br>
Address Offset = 32'h0000_d22a<br>
Physical Address = 32'h0000_d22a<br>
Verilog CL45 Address = {`MICRO_C_A, `rmi_ext_intr_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `rmi_ext_intr_status0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_mbox_msgout_status_or</td>
<td align=left>
This is logic OR of the mbox_msgout_status field from all micro cores in the design<br>
It will remain set until "mbox_msgout_status" field for all micro cores are zero <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_m0p_systemresetreq_status_or</td>
<td align=left>
This is logic OR of the M0P systemresetreq status field from all micro cores in the design<br>
This field is set to 1'b1 when any of the M0P cores "systemresetreq" signal is set to 1'b 1<br>
It will remain set until "systemresetreq" signals from all M0P cores are zero and <br>
systemresetreq status field for all micro cores are zero <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_m0p_lockup_status_or</td>
<td align=left>
This is logic OR of the M0P lockup status from all micro cores in the design<br>
This field is set to 1'b1 when any of the M0P "lockup" signal is set to 1'b1<br>
It will remain set until M0P "lockup" signal from all M0P cores are zero and <br>
m0p_lockup_status field for all micro cores are zero <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_dr_ecc_multirow_err_status</td>
<td align=left>
Data RAM ECC error on multiple row detected&nbsp status <br>
This field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows. <br>
This bits remain remains set until this register is read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_dr_ecc_uncorr_err_status</td>
<td align=left>
Data RAM ECC 2 bit un-correctable error detected status <br>
This field is set to 1'b1 when the ECC logic detects one bit un-correctable error. <br>
This bits remain remains set until this register is read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_dr_ecc_corr_err_status</td>
<td align=left>
Data RAM ECC 1 bit correctable error detected status <br>
This field is set to 1'b1 when the ECC logic detects one bit correctable error. <br>
This bits remain remains set until this register is read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_cr_ecc_multirow_err_status</td>
<td align=left>
Code RAM ECC error on multiple row detected&nbsp status <br>
This field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows. <br>
This bits remain remains set until this register is read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_cr_ecc_uncorr_err_status</td>
<td align=left>
Code RAM ECC 2 bit un-correctable error detected status <br>
This field is set to 1'b1 when the ECC logic detects one bit un-correctable error. <br>
This bits remain remains set until this register is read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_cr_ecc_corr_err_status</td>
<td align=left>
Code RAM ECC 1 bit correctable error detected status <br>
This field is set to 1'b1 when the ECC logic detects one bit correctable error. <br>
This bits remain remains set until this register is read<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_rmi_pmi_if_control0">MICRO_C_rmi_pmi_if_control0 - pmi interface control register 0</a></b><br>
Address Offset = 32'h0000_d22b<br>
Physical Address = 32'h0000_d22b<br>
Verilog CL45 Address = {`MICRO_C_A, `rmi_pmi_if_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `rmi_pmi_if_control0_A<br>
Reset Value = 16'h0001<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_fast_bktobk_en</td>
<td align=left>
pmi hp interface fast back to back enable <br>
1 - skip over some of the states in the fsm during back to back transition <br>
0 - state transitions as in f28 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmi_hp_fast_read_en</td>
<td align=left>
pmi hp interface fast read enable <br>
1 - use pmi_hp_read_vld during read<br>
0 - use pmi_hp_ack during read<br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_rmi_silicon_debug_control0">MICRO_C_rmi_silicon_debug_control0 - Silicon debug control register 0</a></b><br>
Address Offset = 32'h0000_d22c<br>
Physical Address = 32'h0000_d22c<br>
Verilog CL45 Address = {`MICRO_C_A, `rmi_silicon_debug_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `rmi_silicon_debug_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_silicon_debug_status_mux_sel</td>
<td align=left>
This field is used to select the data to be muxed to rmi_silicon_debug_status0 registers&nbsp <br>
0 - register interface - {5'd0, init_req,&nbsp wraddr_changed,&nbsp write_req, <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp rdaddr_changed, read_req, ra_state[1:0], <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 1'b0, ra_his_state[2:0]} <br>
1 - pram interface&nbsp &nbsp&nbsp - {1'b0, pif_state_status[1:0], pif_his_state_status[3:0], <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp pr_hready, pr_dr_chipsel, pr_cr_chipsel, pr_state[1:0], 1'b0, <br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp pr_his_state[2:0]};<br>
2 - pmi_hp interface of micro_core 0&nbsp - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]} <br>
3 - pmi_hp interface of micro_core 1&nbsp - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]} <br>
4 - pmi_hp interface of micro_core 2&nbsp - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]} <br>
5 - pmi_hp interface of micro_core 3&nbsp - {1'b0, pmi_state[2:0], 4'h0, pmi_his_state[7:0]} <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_rmi_silicon_debug_status0">MICRO_C_rmi_silicon_debug_status0 - Silicon debug status register 0</a></b><br>
Address Offset = 32'h0000_d22d<br>
Physical Address = 32'h0000_d22d<br>
Verilog CL45 Address = {`MICRO_C_A, `rmi_silicon_debug_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `rmi_silicon_debug_status0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_silicon_debug_status_muxed_data</td>
<td align=left>
Muxed status data is made avaialable on this field.&nbsp <br>
micro_silicon_debug_status_mux_sel is used to select the data source <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_C_ram_control2">MICRO_C_ram_control2 - ram configuration register 2</a></b><br>
Address Offset = 32'h0000_d22e<br>
Physical Address = 32'h0000_d22e<br>
Verilog CL45 Address = {`MICRO_C_A, `ram_control2_Adr}<br>
Verilog CL22 Address = {`MICRO_C_A, 4'h0}, `ram_control2_A<br>
Reset Value = 16'h8400<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_stack_en</td>
<td align=left>
Micro Core Stack Enable <br>
1 - Enabled (default) - perform logical to physical address mapping un the data RAM for stack&nbsp <br>
0 - Disabled <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_stack_size</td>
<td align=left>
Micro Core Stack Size <br>
This field is used to set the stack size for a micro core on a 4 byte granualarity. <br>
All of the micro cores (Cortex-M0P) use the same stack size. The total amount of <br>
memory allocated for stack = number of cores * micro_core_stack_size. <br>
For 32K Data RAM, limiting the stack size to 8K. <br>
Reset value is 0x100.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01:00</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
</table><p>
<A HREF="#MICRO_C Registers">Return to MICRO_C: micro common register block for all lanes Table</A><p>
<H1><a NAME="MICRO_D Registers">MICRO_D: micro common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd230</td><td><A HREF="#MICRO_D_rmi_micro_msg_control0">MICRO_D_rmi_micro_msg_control0</A></td><td>micro message control register 0</td></tr>
<tr>
<td align=center>0xd231</td><td><A HREF="#MICRO_D_rmi_micro_msg_control1">MICRO_D_rmi_micro_msg_control1</A></td><td>micro message control register 1</td></tr>
<tr>
<td align=center>0xd232</td><td><A HREF="#MICRO_D_rmi_micro_msg_control2">MICRO_D_rmi_micro_msg_control2</A></td><td>micro message control register 2</td></tr>
<tr>
<td align=center>0xd233</td><td><A HREF="#MICRO_D_rmi_micro_msg_control3">MICRO_D_rmi_micro_msg_control3</A></td><td>micro message control register 3</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="MICRO_D_rmi_micro_msg_control0">MICRO_D_rmi_micro_msg_control0 - micro message control register 0</a></b><br>
Address Offset = 32'h0000_d230<br>
Physical Address = 32'h0000_d230<br>
Verilog CL45 Address = {`MICRO_D_A, `rmi_micro_msg_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_D_A, 4'h0}, `rmi_micro_msg_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_msg0</td>
<td align=left>
This field is used to exchange information between micro core(s) and chip level firmware <br>
Both the micro cores(s) and the chip level firmware can read/write this field <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_D Registers">Return to MICRO_D: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_D_rmi_micro_msg_control1">MICRO_D_rmi_micro_msg_control1 - micro message control register 1</a></b><br>
Address Offset = 32'h0000_d231<br>
Physical Address = 32'h0000_d231<br>
Verilog CL45 Address = {`MICRO_D_A, `rmi_micro_msg_control1_Adr}<br>
Verilog CL22 Address = {`MICRO_D_A, 4'h0}, `rmi_micro_msg_control1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_msg1</td>
<td align=left>
This field is used to exchange information between micro core(s) and chip level firmware <br>
Both the micro cores(s) and the chip level firmware can read/write this field <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_D Registers">Return to MICRO_D: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_D_rmi_micro_msg_control2">MICRO_D_rmi_micro_msg_control2 - micro message control register 2</a></b><br>
Address Offset = 32'h0000_d232<br>
Physical Address = 32'h0000_d232<br>
Verilog CL45 Address = {`MICRO_D_A, `rmi_micro_msg_control2_Adr}<br>
Verilog CL22 Address = {`MICRO_D_A, 4'h0}, `rmi_micro_msg_control2_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_msg2</td>
<td align=left>
This field is used to exchange information between micro core(s) and chip level firmware <br>
Both the micro cores(s) and the chip level firmware can read/write this field <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_D Registers">Return to MICRO_D: micro common register block for all lanes Table</A><p>
<b><a NAME="MICRO_D_rmi_micro_msg_control3">MICRO_D_rmi_micro_msg_control3 - micro message control register 3</a></b><br>
Address Offset = 32'h0000_d233<br>
Physical Address = 32'h0000_d233<br>
Verilog CL45 Address = {`MICRO_D_A, `rmi_micro_msg_control3_Adr}<br>
Verilog CL22 Address = {`MICRO_D_A, 4'h0}, `rmi_micro_msg_control3_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_msg3</td>
<td align=left>
This field is used to exchange information between micro core(s) and chip level firmware <br>
Both the micro cores(s) and the chip level firmware can read/write this field <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_D Registers">Return to MICRO_D: micro common register block for all lanes Table</A><p>
<H1><a NAME="MICRO_E Registers">MICRO_E: micro core register block (separate for each micro) Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd240</td><td><A HREF="#MICRO_E_micro_core_clock_control0">MICRO_E_micro_core_clock_control0</A></td><td>micro core clock control registers 0</td></tr>
<tr>
<td align=center>0xd241</td><td><A HREF="#MICRO_E_micro_core_reset_control0">MICRO_E_micro_core_reset_control0</A></td><td>micro core reset control registers 0</td></tr>
<tr>
<td align=center>0xd242</td><td><A HREF="#MICRO_E_micro_core_status0">MICRO_E_micro_core_status0</A></td><td>rmi micro core status register 0</td></tr>
<tr>
<td align=center>0xd243</td><td><A HREF="#MICRO_E_micro_core_control0">MICRO_E_micro_core_control0</A></td><td>rmi micro core control register 0</td></tr>
<tr>
<td align=center>0xd244</td><td><A HREF="#MICRO_E_micro_core_mbox_control0">MICRO_E_micro_core_mbox_control0</A></td><td>rmi micro core mail box control register 0</td></tr>
<tr>
<td align=center>0xd245</td><td><A HREF="#MICRO_E_micro_core_low_power_control0">MICRO_E_micro_core_low_power_control0</A></td><td>rmi micro core low power control register 0</td></tr>
<tr>
<td align=center>0xd246</td><td><A HREF="#MICRO_E_micro_core_low_power_status0">MICRO_E_micro_core_low_power_status0</A></td><td>rmi micro core low power status register 0</td></tr>
<tr>
<td align=center>0xd247</td><td><A HREF="#MICRO_E_micro_core_status1">MICRO_E_micro_core_status1</A></td><td>rmi micro core status register 1</td></tr>
<tr>
<td align=center>0xd248</td><td><A HREF="#MICRO_E_micro_core_status2">MICRO_E_micro_core_status2</A></td><td>rmi micro core status register 2</td></tr>
<tr>
<td align=center>0xd24d</td><td><A HREF="#MICRO_E_micro_core_cfg_fwapi_data0">MICRO_E_micro_core_cfg_fwapi_data0</A></td><td>micro core firmware/api data registers 0</td></tr>
<tr>
<td align=center>0xd24e</td><td><A HREF="#MICRO_E_micro_core_cfg_fw_api_data1">MICRO_E_micro_core_cfg_fw_api_data1</A></td><td>micro core firmware/api data registers 1</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="MICRO_E_micro_core_clock_control0">MICRO_E_micro_core_clock_control0 - micro core clock control registers 0</a></b><br>
Address Offset = 32'h0000_d240<br>
Physical Address = 32'h0000_d240<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_clock_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_clock_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_clk_en</td>
<td align=left>
micro core clock enable for core:<br>
While the micro-code is being loaded into the code RAM, the clock to <br>
micro_core is normally disabled and a reset is asserted<br>
0 - disabled <br>
1 - enables <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_reset_control0">MICRO_E_micro_core_reset_control0 - micro core reset control registers 0</a></b><br>
Address Offset = 32'h0000_d241<br>
Physical Address = 32'h0000_d241<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_reset_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_reset_control0_A<br>
Reset Value = 16'hc000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_sw_pmi_hp_rstb</td>
<td align=left>
Software reset pmi_hp interface logic <br>
This bit is to initialize the pmi_hp block <br>
0 - reset asserted <br>
1 - reset de-asserted <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dap_poreset_s_rstb</td>
<td align=left>
micro core dap software por reset:<br>
A reset on the M0P DAP PORESET pin is asserted when: <br>
&nbsp&nbsp 1) pmd_por_h_rstb pin = 0 (upon power-on) OR <br>
&nbsp&nbsp 2) micro_dap_poreset_s_rstb register filed = 0 (software reset) <br>
0 - asserted <br>
1 - de-asserted <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_rstb</td>
<td align=left>
micro core reset for core:<br>
While the micro-code is being loaded into the code RAM, the clock to <br>
micro_core (m0) is normally disabled and a reset is asserted.<br>
Setting this field to 1'b1 de-asserts a reset to the micro.<br>
0 - disabled <br>
1 - enables <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_status0">MICRO_E_micro_core_status0 - rmi micro core status register 0</a></b><br>
Address Offset = 32'h0000_d242<br>
Physical Address = 32'h0000_d242<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_status0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:04</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_m0p_default_slave_error_status</td>
<td align=left>
m0p default slave error detected. M0P attempted to access un-used address<br>
1 - error detected - latched high clear on read <br>
0 - no error <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pmi_hp_ack_timeout_status</td>
<td align=left>
This field is set when pmi_hp_ack signal on the pmi_hp bus does not toggle within 256 clock cycle <br>
This bit remains set, until this register is read (latch high, clear on read)<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pmi_hp_word_access_err_status</td>
<td align=left>
This field is set when 32-bit operation is perform to generate transations on the pmi_hp bus <br>
Only 8/16-bits operations are allowed <br>
This bit remains set, until this register is read (latch high, clear on read)<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pmi_hp_error_status</td>
<td align=left>
pmi_hp_error signal status <br>
This field is set when pmi_hp_error signal is asserted by RMIC during pmi_hp bus tranactions <br>
This bit remains set, until this register is read (latch high, clear on read) <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_control0">MICRO_E_micro_core_control0 - rmi micro core control register 0</a></b><br>
Address Offset = 32'h0000_d243<br>
Physical Address = 32'h0000_d243<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_control0_A<br>
Reset Value = 16'h0003<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_ln_sel</td>
<td align=left>
 This field indicates lanes that are selected for micro_core <br>
PLEASE NOTE:The default value of this register field for each micro core is unique. <br>
the default values are: <br>
micro core 0 - 8'h3 <br>
micro core 1 - 8'hC <br>
micro core 2 - 8'h30 <br>
micro core 3 - 8'hC0 <br>
Reset value is 0x3.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_mbox_control0">MICRO_E_micro_core_mbox_control0 - rmi micro core mail box control register 0</a></b><br>
Address Offset = 32'h0000_d244<br>
Physical Address = 32'h0000_d244<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_mbox_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_mbox_control0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_mbox_msgin_intr</td>
<td align=left>
mailbox message in interrupt for micro <br>
Set by the MDIO/PMI_LP, cleared by the micro via PMI HP <br>
Drive the micro interrupt pin <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_low_power_control0">MICRO_E_micro_core_low_power_control0 - rmi micro core low power control register 0</a></b><br>
Address Offset = 32'h0000_d245<br>
Physical Address = 32'h0000_d245<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_low_power_control0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_low_power_control0_A<br>
Reset Value = 16'h000e<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_pmd_signal_detect_wakeup_en</td>
<td align=left>
M0P core - Enable wakeup event upon detecting a change on the lane pmd_signal_detect <br>
When this is set 1, and any bits in the micro_pmd_signal_detect_status_LH are set <br>
then M0P core RXEV pin is set to 1'b1 to wake-up M0P from WFE sleep state <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_dp_rclk20_rst_wakeup_en</td>
<td align=left>
M0P core - Enable wakeup event upon detecting a change on the lane dp_rclk20_rst <br>
When this is set 1, and any bits in the micro_dp_rclk20_rst_status_LH are set <br>
then M0P core RXEV pin is set to 1'b1 to wake-up M0P from WFE sleep state <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>micro_m0p_wakeup</td>
<td align=left>
M0P core wakeupThis is self-clearing field. When this set 1, it generate a pulse<br>
on the M0P core RXEV pin to wakeup M0P from WFE sleep state <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_m0p_gclk_frc</td>
<td align=left>
M0P core clock gate force enableThe clock to the M0P core can be gated of in the low power mode <br>
using GATEHCLK signals for M0P core. The micro_m0p_gclk_frc and <br>
micro_m0p_gclk_frcval provides a mechanism override the clock gating <br>
{micro_m0p_gclk_frc, micro_m0p_gclk_frcval} <br>
2'b11 - GATEHCLK ignored. Clock gate bypass (default) <br>
2'b10 - GATEHCLK ignored. M0P hclk clock gated off&nbsp <br>
2'b0X - GATEHCLK used to gate M0P hclk clock <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_m0p_gclk_frcval</td>
<td align=left>
M0P core clock gate force valueThe clock to the M0P cores can be gated of in the low power mode <br>
using GATEHCLK signals for M0P core. The micro_m0p_gclk_frc and <br>
micro_m0p_gclk_frcval provides a mechanism override the clock gating <br>
{micro_m0p_gclk_frc, micro_m0p_gclk_frcval} <br>
2'b11 - GATEHCLK ignored. Clock gate bypass (default)<br>
2'b10 - GATEHCLK ignored. M0P hclk clock gated off&nbsp <br>
2'b0X - GATEHCLK used to gate M0P hclk clock <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_sleepholdreq_n</td>
<td align=left>
Request to extend the processor sleeping state regardless <br>
of wake-up events. If the processor acknowledges this request <br>
driving m0p_sleepholdack_n LOW, this guarantees the processor <br>
remains idle even on receipt of a wake-up event. <br>
This is used to safely shutdown the micro_core <br>
0 - request to extend deep sleep state <br>
1 - no request <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_wicenreq</td>
<td align=left>
WIC-based Deep Sleep request for micro core <br>
1 - request for Deep Sleep<br>
0 - no request <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_low_power_status0">MICRO_E_micro_core_low_power_status0 - rmi micro core low power status register 0</a></b><br>
Address Offset = 32'h0000_d246<br>
Physical Address = 32'h0000_d246<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_low_power_status0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_low_power_status0_A<br>
Reset Value = 16'h0002<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_sleepdeep_LH</td>
<td align=left>
Latch high sleepdeep. This field is set to 1'b1 when micro_sleepdeep is 1 <br>
It will remain set until micro_sleepdeep is set to 0 and <br>
and this register is read<br>
clear-on-read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_sleeping_LH</td>
<td align=left>
Latch high sleeping. This field is set to 1'b1 when micro_sleeping is 1 <br>
It will remain set until micro_sleeping is set to 0 and <br>
and this register is read<br>
clear-on-read<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_sleepdeep</td>
<td align=left>
Active only when micro_sleeping is 1 <br>
Indicates that the SLEEPDEEP bit in the NVIC is set to 1 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_sleeping</td>
<td align=left>
 for micro <br>
 1 - indicates the processor is idle, waiting for an interrupt <br>
&nbsp &nbsp&nbsp on the IRQ or internal SysTick. <br>
 0 - indicates that the processor is running or wants to leave sleep mode <br>
 If micro_sleepholdack_n is 0, then the processor <br>
 does not perform any fetches until micro_sleepholdreq_n is 1 <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_sleepholdack_n</td>
<td align=left>
Response to micro_sleepholdreq_n. <br>
If this signal is LOW, irrespective of the micro_sleeping <br>
signal value, the processor does not advance in execution <br>
and does not perform any memory operations. This is used to <br>
safely shutdown the micro_core <br>
0 - Acknowledge <br>
1 - none <br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_wicenack</td>
<td align=left>
Active HIGH acknowledge signal for micro_wicenreq<br>
1 - Acknowledge <br>
0 - none<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_status1">MICRO_E_micro_core_status1 - rmi micro core status register 1</a></b><br>
Address Offset = 32'h0000_d247<br>
Physical Address = 32'h0000_d247<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_status1_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_status1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:03</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_mbox_msgout_status</td>
<td align=left>
mailbox message out status<br>
This field is set to 1'b1 when the firmware set the ahbcommon_mbox_send_msgout to 1'b1 <br>
to send a message out <br>
It will remain set until this field is read <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_m0p_systemresetreq_status</td>
<td align=left>
M0P systemresetreq status<br>
This field is set to 1'b1 when M0P "systemresetreq" signal is set to 1'b1 <br>
It will remain set until systemresetreq is set to 1'b0 and this field is read <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_rmi_m0p_lockup_status</td>
<td align=left>
M0P lockup status <br>
This field is set to 1'b1 when M0P "lockup" signal is set to 1'b1 to indicate lockup<br>
It will remain set until M0P "lockup" signal goes to 1'b0 and this filed is read <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_status2">MICRO_E_micro_core_status2 - rmi micro core status register 2</a></b><br>
Address Offset = 32'h0000_d248<br>
Physical Address = 32'h0000_d248<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_status2_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_status2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:08</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_pmd_signal_detect_status_LH</td>
<td align=left>
Indicates a changes lane pmd_signal_detect detected&nbsp <br>
 1 - change detected. This can be used to&nbsp generate wake-up event <br>
&nbsp &nbsp&nbsp if micro_pmd_signal_detect_wakeup_en is set to 1'b1 <br>
 0 - no changes <br>
 clear-on-read <br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>micro_dp_rclk20_rst_status_LH</td>
<td align=left>
Indicatees a change on rx lane datapath reset detected&nbsp <br>
 1 - change detected. This can be used to&nbsp generate wake-up event <br>
&nbsp &nbsp&nbsp if micro_dp_rclk20_rst_wakeup_en is set to 1'b1 <br>
 0 - no changes <br>
 clear-on-read <br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_cfg_fwapi_data0">MICRO_E_micro_core_cfg_fwapi_data0 - micro core firmware/api data registers 0</a></b><br>
Address Offset = 32'h0000_d24d<br>
Physical Address = 32'h0000_d24d<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_cfg_fwapi_data0_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_cfg_fwapi_data0_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_cfg_fwapi_data0</td>
<td align=left>
Micro core firmware/API data 0<br>
This is a scratch register used by the firmware and API code to store and/or exchange <br>
micro core configuration information<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<b><a NAME="MICRO_E_micro_core_cfg_fw_api_data1">MICRO_E_micro_core_cfg_fw_api_data1 - micro core firmware/api data registers 1</a></b><br>
Address Offset = 32'h0000_d24e<br>
Physical Address = 32'h0000_d24e<br>
Verilog CL45 Address = {`MICRO_E_A, `micro_core_cfg_fw_api_data1_Adr}<br>
Verilog CL22 Address = {`MICRO_E_A, 4'h0}, `micro_core_cfg_fw_api_data1_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>micro_core_cfg_fwapi_data1</td>
<td align=left>
Micro core firmware/API data 1<br>
This is a scratch register used by the firmware and API code to store and/or exchange <br>
micro core configuration information<br>
Reset value is 0.</td></tr>
</table><p>
<A HREF="#MICRO_E Registers">Return to MICRO_E: micro core register block (separate for each micro) Table</A><p>
<H1><a NAME="DAC_TEST_COM Registers">DAC_TEST_COM: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd300</td><td><A HREF="#DAC_TEST_COM_readback_data_0">DAC_TEST_COM_readback_data_0</A></td><td>DAC Pattern Generator Readback Data Word 0</td></tr>
<tr>
<td align=center>0xd301</td><td><A HREF="#DAC_TEST_COM_readback_data_1">DAC_TEST_COM_readback_data_1</A></td><td>DAC Pattern Generator Readback Data Word 1</td></tr>
<tr>
<td align=center>0xd302</td><td><A HREF="#DAC_TEST_COM_readback_data_2">DAC_TEST_COM_readback_data_2</A></td><td>DAC Pattern Generator Readback Data Word 2</td></tr>
<tr>
<td align=center>0xd303</td><td><A HREF="#DAC_TEST_COM_readback_data_3">DAC_TEST_COM_readback_data_3</A></td><td>DAC Pattern Generator Readback Data Word 3</td></tr>
<tr>
<td align=center>0xd304</td><td><A HREF="#DAC_TEST_COM_readback_data_4">DAC_TEST_COM_readback_data_4</A></td><td>DAC Pattern Generator Readback Data Word 4</td></tr>
<tr>
<td align=center>0xd305</td><td><A HREF="#DAC_TEST_COM_readback_data_5">DAC_TEST_COM_readback_data_5</A></td><td>DAC Pattern Generator Readback Data Word 5</td></tr>
<tr>
<td align=center>0xd306</td><td><A HREF="#DAC_TEST_COM_readback_data_6">DAC_TEST_COM_readback_data_6</A></td><td>DAC Pattern Generator Readback Data Word 6</td></tr>
<tr>
<td align=center>0xd307</td><td><A HREF="#DAC_TEST_COM_readback_data_7">DAC_TEST_COM_readback_data_7</A></td><td>DAC Pattern Generator Readback Data Word 7</td></tr>
<tr>
<td align=center>0xd308</td><td><A HREF="#DAC_TEST_COM_readback_data_8">DAC_TEST_COM_readback_data_8</A></td><td>DAC Pattern Generator Readback Data Word 8</td></tr>
<tr>
<td align=center>0xd309</td><td><A HREF="#DAC_TEST_COM_readback_address">DAC_TEST_COM_readback_address</A></td><td>DAC Pattern Generator Readback Address</td></tr>
<tr>
<td align=center>0xd30a</td><td><A HREF="#DAC_TEST_COM_dac_test_control">DAC_TEST_COM_dac_test_control</A></td><td>DAC Pattern Generator Control Register</td></tr>
<tr>
<td align=center>0xd30b</td><td><A HREF="#DAC_TEST_COM_dac_test_mem_test">DAC_TEST_COM_dac_test_mem_test</A></td><td>DAC Test Memory Test Rgister</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_0">DAC_TEST_COM_readback_data_0 - DAC Pattern Generator Readback Data Word 0</a></b><br>
Address Offset = 32'h0000_d300<br>
Physical Address = 32'h0000_d300<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_0_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_0</td>
<td align=left>
DAC Pattern Generator readback Word 0. <br>
This register holds bits 15-0 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_1">DAC_TEST_COM_readback_data_1 - DAC Pattern Generator Readback Data Word 1</a></b><br>
Address Offset = 32'h0000_d301<br>
Physical Address = 32'h0000_d301<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_1_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_1</td>
<td align=left>
DAC Pattern Generator readback Word 1. <br>
This register holds bits 31-16 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_2">DAC_TEST_COM_readback_data_2 - DAC Pattern Generator Readback Data Word 2</a></b><br>
Address Offset = 32'h0000_d302<br>
Physical Address = 32'h0000_d302<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_2_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_2</td>
<td align=left>
DAC Pattern Generator readback Word 2. <br>
This register holds bits 47-32 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_3">DAC_TEST_COM_readback_data_3 - DAC Pattern Generator Readback Data Word 3</a></b><br>
Address Offset = 32'h0000_d303<br>
Physical Address = 32'h0000_d303<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_3_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_3_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_3</td>
<td align=left>
DAC Pattern Generator readback Word 3. <br>
This register holds bits 63-48 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_4">DAC_TEST_COM_readback_data_4 - DAC Pattern Generator Readback Data Word 4</a></b><br>
Address Offset = 32'h0000_d304<br>
Physical Address = 32'h0000_d304<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_4_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_4_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_4</td>
<td align=left>
DAC Pattern Generator readback Word 4. <br>
This register holds bits 79-64 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_5">DAC_TEST_COM_readback_data_5 - DAC Pattern Generator Readback Data Word 5</a></b><br>
Address Offset = 32'h0000_d305<br>
Physical Address = 32'h0000_d305<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_5_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_5_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_5</td>
<td align=left>
DAC Pattern Generator readback Word 5. <br>
This register holds bits 95-80 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_6">DAC_TEST_COM_readback_data_6 - DAC Pattern Generator Readback Data Word 6</a></b><br>
Address Offset = 32'h0000_d306<br>
Physical Address = 32'h0000_d306<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_6_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_6_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_6</td>
<td align=left>
DAC Pattern Generator readback Word 6. <br>
This register holds bits 111-96 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_7">DAC_TEST_COM_readback_data_7 - DAC Pattern Generator Readback Data Word 7</a></b><br>
Address Offset = 32'h0000_d307<br>
Physical Address = 32'h0000_d307<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_7_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_7_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_7</td>
<td align=left>
DAC Pattern Generator readback Word 7. <br>
This register holds bits 127-112 of the 140 bits read from the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_data_8">DAC_TEST_COM_readback_data_8 - DAC Pattern Generator Readback Data Word 8</a></b><br>
Address Offset = 32'h0000_d308<br>
Physical Address = 32'h0000_d308<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_data_8_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_data_8_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_data_8</td>
<td align=left>
DAC Pattern Generator readback Word 8. <br>
This register holds bits 139-128 of the 140 bits read from the 140x50 memory <br>
When the address match occurs for this register, the memory address pointer will automatically increment to the next address <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_readback_address">DAC_TEST_COM_readback_address - DAC Pattern Generator Readback Address</a></b><br>
Address Offset = 32'h0000_d309<br>
Physical Address = 32'h0000_d309<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `readback_address_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `readback_address_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>dac_test_readback_address</td>
<td align=left>
This register holds 6 bits current address of the 140x50 memory <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_dac_test_control">DAC_TEST_COM_dac_test_control - DAC Pattern Generator Control Register</a></b><br>
Address Offset = 32'h0000_d30a<br>
Physical Address = 32'h0000_d30a<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `dac_test_control_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `dac_test_control_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:12</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>dac_test_mem_write_pulse</td>
<td align=left>
Self Clearing bit <br>
DAC Pattern Generator Memory Write pulse. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dac_test_readback_en</td>
<td align=left>
DAC Pattern Generator Readback Enable. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dac_test_read_en</td>
<td align=left>
DAC Pattern Generator Read Enable. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dac_test_test_en</td>
<td align=left>
DAC Pattern Generator Block Enable. <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>07:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dac_test_lane_sel_en</td>
<td align=left>
DAC Pattern Generator Lane Select Enable. <br>
Set 1 bit only from bit 7 to bit 0. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<b><a NAME="DAC_TEST_COM_dac_test_mem_test">DAC_TEST_COM_dac_test_mem_test - DAC Test Memory Test Rgister</a></b><br>
Address Offset = 32'h0000_d30b<br>
Physical Address = 32'h0000_d30b<br>
Verilog CL45 Address = {`DAC_TEST_COM_A, `dac_test_mem_test_Adr}<br>
Verilog CL22 Address = {`DAC_TEST_COM_A, 4'h0}, `dac_test_mem_test_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>dac_test_mem_tm</td>
<td align=left>
DAC Test Memory tm registers. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#DAC_TEST_COM Registers">Return to DAC_TEST_COM: common register block for all lanes Table</A><p>
<H1><a NAME="TLB_ERR_AGGR Registers">TLB_ERR_AGGR: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xd310</td><td><A HREF="#TLB_ERR_AGGR_tlb_err_aggr_config_0">TLB_ERR_AGGR_tlb_err_aggr_config_0</A></td><td>tlb_err_aggr Control 0</td></tr>
<tr>
<td align=center>0xd311</td><td><A HREF="#TLB_ERR_AGGR_tlb_err_aggr_config_1">TLB_ERR_AGGR_tlb_err_aggr_config_1</A></td><td>TLB_RX_B Control 1</td></tr>
<tr>
<td align=center>0xd315</td><td><A HREF="#TLB_ERR_AGGR_num_errors_in_fec_frames_status_hi">TLB_ERR_AGGR_num_errors_in_fec_frames_status_hi</A></td><td>tlb_err_aggr Status 8</td></tr>
<tr>
<td align=center>0xd316</td><td><A HREF="#TLB_ERR_AGGR_num_errors_in_fec_frames_status_lo">TLB_ERR_AGGR_num_errors_in_fec_frames_status_lo</A></td><td>tlb_err_aggr Status 7</td></tr>
<tr>
<td align=center>0xd317</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_7">TLB_ERR_AGGR_count_histogram_error_offset_7</A></td><td>tlb_err_aggr Status 7</td></tr>
<tr>
<td align=center>0xd318</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_6">TLB_ERR_AGGR_count_histogram_error_offset_6</A></td><td>tlb_err_aggr Status 6</td></tr>
<tr>
<td align=center>0xd319</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_5">TLB_ERR_AGGR_count_histogram_error_offset_5</A></td><td>tlb_err_aggr Status 5</td></tr>
<tr>
<td align=center>0xd31a</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_4">TLB_ERR_AGGR_count_histogram_error_offset_4</A></td><td>tlb_err_aggr Status 4</td></tr>
<tr>
<td align=center>0xd31b</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_3">TLB_ERR_AGGR_count_histogram_error_offset_3</A></td><td>tlb_err_aggr Status 3</td></tr>
<tr>
<td align=center>0xd31c</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_2">TLB_ERR_AGGR_count_histogram_error_offset_2</A></td><td>tlb_err_aggr Status 2</td></tr>
<tr>
<td align=center>0xd31d</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_1">TLB_ERR_AGGR_count_histogram_error_offset_1</A></td><td>tlb_err_aggr Status 1</td></tr>
<tr>
<td align=center>0xd31e</td><td><A HREF="#TLB_ERR_AGGR_count_histogram_error_offset_0">TLB_ERR_AGGR_count_histogram_error_offset_0</A></td><td>tlb_err_aggr Status 0</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="TLB_ERR_AGGR_tlb_err_aggr_config_0">TLB_ERR_AGGR_tlb_err_aggr_config_0 - tlb_err_aggr Control 0</a></b><br>
Address Offset = 32'h0000_d310<br>
Physical Address = 32'h0000_d310<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `tlb_err_aggr_config_0_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `tlb_err_aggr_config_0_A<br>
Reset Value = 16'h000c<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_mode</td>
<td align=left>
 Defines how many lanes are being aggregated <br>
 00-not active (clock gated), 01 - bi lane, 10 - quad, 11 - octal <br>
 All the registers in this block required lane 0 TX in OSR1 mode <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_lanes_active</td>
<td align=left>
 Out of lanes 0-7, which lanes are chosen for aggregation <br>
00000001 - lane 0 active, 11111111 - all lanes active <br>
For a quad lane core, top 4 bits should be 0000 <br>
For a bi lane core, top 4 bits should be 000000 <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05:02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_error_count_thresh</td>
<td align=left>
 Error threshold number beyond which the error analyzer would count a bad frame. <br>
 Valid values for this field are from 3-15 <br>
Reset value is 0x3.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>SC</td>
<td align=left valign=top>tlb_err_aggr_clear_error_analyzer_status</td>
<td align=left>
 When a write is executed in this register, it will clear all the error analyzer registers.<br>
 This register is self-clear.<br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_en</td>
<td align=left>
 Enables the multi lane error aggregation to start perfoming error analysis<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_tlb_err_aggr_config_1">TLB_ERR_AGGR_tlb_err_aggr_config_1 - TLB_RX_B Control 1</a></b><br>
Address Offset = 32'h0000_d311<br>
Physical Address = 32'h0000_d311<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `tlb_err_aggr_config_1_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `tlb_err_aggr_config_1_A<br>
Reset Value = 16'h00a3<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_en_force</td>
<td align=left>
 Enables the aggregation block by force even when the pattern is not matched <br>
 0 - This is a debug feature <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:12</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_delay_data_capture</td>
<td align=left>
 From when the error data launches, delay the capturing of data <br>
 0 - 3 clks, 1 - 4 clks, 2 - 5 clks, 3 - 6 clks <br>
 0 - clk by default is clk16. There is a feature to make the clock clk32 <br>
 0 - This is a debug feature <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>11:09</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_clk_out_of_sync_pattern_depth</td>
<td align=left>
 These bits define the depth of pattern recognition for enabling the tlb error aggregation block <br>
 0 - Out of sync 4 clk_16s, 1 - Out of sync 5 clk_16s, 2 - Out of sync 6 clk_16s, 3 - Out of sync 7 clk_16s <br>
 4 - Out of sync 8 clk_16s, 5 - Out of sync 9 clk_16s, 6 - Out of sync 10 clk_16s, 7 - Out of sync 11 clk_16s <br>
 0 - This is a debug feature <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>08:06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_active_pattern_depth</td>
<td align=left>
 These bits define the depth of pattern recognition for enabling the tlb error aggregation block <br>
 0 - Detects 9'bxxxxxxx10, 1 - Detects 9'bxxxxxx100, 2 - Detects 9'bxxxxx1000, 3 - Detects 9'bxxxx10000. <br>
 4 - Detects 9'bxxx100000, 5 - Detects 9'bxx1000000, 6 - Detects 9'bx10000000, 7 - Detects 9'b100000000. <br>
 0 - This is a debug feature <br>
Reset value is 0x2.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_gclk_div2_en_ignore</td>
<td align=left>
 When this bit is unset, it slows down the sampling of lane stable single from each lane by half - clk_32. <br>
 This mode should only be used in PAM4 OS2 mode. This is a debug feature. <br>
Reset value is 0x1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_clear_status_on_read</td>
<td align=left>
 Enables read on clear for all error status counters <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>tlb_err_aggr_histogram_error_thresh</td>
<td align=left>
 Counts the number of errors in frames for x, x+1,..,x+7 errors in the FEC frames <br>
 Valid values for this field are from 3-8 <br>
Reset value is 0x3.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_num_errors_in_fec_frames_status_hi">TLB_ERR_AGGR_num_errors_in_fec_frames_status_hi - tlb_err_aggr Status 8</a></b><br>
Address Offset = 32'h0000_d315<br>
Physical Address = 32'h0000_d315<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `num_errors_in_fec_frames_status_hi_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `num_errors_in_fec_frames_status_hi_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:06</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_clks_out_of_sync_status</td>
<td align=left>
This bit indicates that a clocks out of sync scenario is detected due to clock wander <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_active_status</td>
<td align=left>
 This bit is set when the tlb error aggregation feature is enabled after pattern recognition <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_error_hi</td>
<td align=left>
 Top 4 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames. <br>
 tlb_err_aggr_count_error_lo needs to be read before this status register to read the correct value <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_num_errors_in_fec_frames_status_lo">TLB_ERR_AGGR_num_errors_in_fec_frames_status_lo - tlb_err_aggr Status 7</a></b><br>
Address Offset = 32'h0000_d316<br>
Physical Address = 32'h0000_d316<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `num_errors_in_fec_frames_status_lo_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `num_errors_in_fec_frames_status_lo_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_error_lo</td>
<td align=left>
 Bottom 16 bits out of 20 bit register that stores the status of how many errors have occurred in FEC frames. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_7">TLB_ERR_AGGR_count_histogram_error_offset_7 - tlb_err_aggr Status 7</a></b><br>
Address Offset = 32'h0000_d317<br>
Physical Address = 32'h0000_d317<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_7_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_7_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_7</td>
<td align=left>
 Number of times 'N+7' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_6">TLB_ERR_AGGR_count_histogram_error_offset_6 - tlb_err_aggr Status 6</a></b><br>
Address Offset = 32'h0000_d318<br>
Physical Address = 32'h0000_d318<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_6_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_6_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_6</td>
<td align=left>
 Number of times 'N+6' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_5">TLB_ERR_AGGR_count_histogram_error_offset_5 - tlb_err_aggr Status 5</a></b><br>
Address Offset = 32'h0000_d319<br>
Physical Address = 32'h0000_d319<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_5_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_5_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_5</td>
<td align=left>
 Number of times 'N+5' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_4">TLB_ERR_AGGR_count_histogram_error_offset_4 - tlb_err_aggr Status 4</a></b><br>
Address Offset = 32'h0000_d31a<br>
Physical Address = 32'h0000_d31a<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_4_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_4_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_4</td>
<td align=left>
 Number of times 'N+4' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_3">TLB_ERR_AGGR_count_histogram_error_offset_3 - tlb_err_aggr Status 3</a></b><br>
Address Offset = 32'h0000_d31b<br>
Physical Address = 32'h0000_d31b<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_3_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_3_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_3</td>
<td align=left>
 Number of times 'N+3' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_2">TLB_ERR_AGGR_count_histogram_error_offset_2 - tlb_err_aggr Status 2</a></b><br>
Address Offset = 32'h0000_d31c<br>
Physical Address = 32'h0000_d31c<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_2_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_2_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_2</td>
<td align=left>
 Number of times 'N+2' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_1">TLB_ERR_AGGR_count_histogram_error_offset_1 - tlb_err_aggr Status 1</a></b><br>
Address Offset = 32'h0000_d31d<br>
Physical Address = 32'h0000_d31d<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_1_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_1_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_1</td>
<td align=left>
 Number of times 'N+1' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<b><a NAME="TLB_ERR_AGGR_count_histogram_error_offset_0">TLB_ERR_AGGR_count_histogram_error_offset_0 - tlb_err_aggr Status 0</a></b><br>
Address Offset = 32'h0000_d31e<br>
Physical Address = 32'h0000_d31e<br>
Verilog CL45 Address = {`TLB_ERR_AGGR_A, `count_histogram_error_offset_0_Adr}<br>
Verilog CL22 Address = {`TLB_ERR_AGGR_A, 4'h0}, `count_histogram_error_offset_0_A<br>
Reset Value = 16'h0000<br>
Access = RO (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:00</td>
<td align=left valign=top>RO</td>
<td align=left valign=top>tlb_err_aggr_count_histogram_error_offset_0</td>
<td align=left>
 Number of times 'N' errors occurr in FEC frames, where N is defined by the register hist_start_error_count. <br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#TLB_ERR_AGGR Registers">Return to TLB_ERR_AGGR: common register block for all lanes Table</A><p>
<H1><a NAME="MDIO_MMDSEL_AER_COM Registers">MDIO_MMDSEL_AER_COM: common register block for all lanes Registers</a></H1>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><td align=center width=10%><b>Offset (Bytes)</b></td><td align=center width=30%><b>Register Name </b></td><td align=center width=60%><b>Description</b></td></tr>
<tr>
<td align=center>0xffdc</td><td><A HREF="#MDIO_MMDSEL_AER_COM_mdio_brcst_port_addr">MDIO_MMDSEL_AER_COM_mdio_brcst_port_addr</A></td><td>Broadcast Port Address</td></tr>
<tr>
<td align=center>0xffdd</td><td><A HREF="#MDIO_MMDSEL_AER_COM_mdio_mmd_select">MDIO_MMDSEL_AER_COM_mdio_mmd_select</A></td><td>MMD Select</td></tr>
<tr>
<td align=center>0xffde</td><td><A HREF="#MDIO_MMDSEL_AER_COM_mdio_aer">MDIO_MMDSEL_AER_COM_mdio_aer</A></td><td>AER</td></tr>
</table><p>
<A HREF="#blackhawk_8x_pll2x_v1p0">Return to blackhawk_8x_pll2x_v1p0 Table</A><p>
<b><a NAME="MDIO_MMDSEL_AER_COM_mdio_brcst_port_addr">MDIO_MMDSEL_AER_COM_mdio_brcst_port_addr - Broadcast Port Address</a></b><br>
Address Offset = 32'h0000_ffdc<br>
Physical Address = 32'h0000_ffdc<br>
Verilog CL45 Address = {`MDIO_MMDSEL_AER_COM_A, `mdio_brcst_port_addr_Adr}<br>
Verilog CL22 Address = {`MDIO_MMDSEL_AER_COM_A, 4'h0}, `mdio_brcst_port_addr_A<br>
Reset Value = 16'h001f<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_drv_comclk</td>
<td align=left>
Debug control bit to select between mdio_clk and comclk to drive out mdio_out and mdio_oeb signals. <br>
0=mdio_clk, 1=comclk <br>
Reset value is 0x0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14:05</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_brcst_port_addr</td>
<td align=left>
Braodcast port address that can be used to broadcast mdio commands <br>
to multiple controllers connected to the same mdio station manager <br>
Reset value is 0x1f.</td></tr>
</table><p>
<A HREF="#MDIO_MMDSEL_AER_COM Registers">Return to MDIO_MMDSEL_AER_COM: common register block for all lanes Table</A><p>
<b><a NAME="MDIO_MMDSEL_AER_COM_mdio_mmd_select">MDIO_MMDSEL_AER_COM_mdio_mmd_select - MMD Select</a></b><br>
Address Offset = 32'h0000_ffdd<br>
Physical Address = 32'h0000_ffdd<br>
Verilog CL45 Address = {`MDIO_MMDSEL_AER_COM_A, `mdio_mmd_select_Adr}<br>
Verilog CL22 Address = {`MDIO_MMDSEL_AER_COM_A, 4'h0}, `mdio_mmd_select_A<br>
Reset Value = 16'h404d<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_multi_prts_en</td>
<td align=left>
When set enables multiple prtad functionality.&nbsp Each of the lanes' <br>
mmds can be accessed with consecutive PRTADs.&nbsp Lane 0 is accessed <br>
with PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2 <br>
and lane 3 with PRTAD_STRAP+3.<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>14</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_multi_mmds_en</td>
<td align=left>
When set enables the multiple MMD functionality.&nbsp MD_ST is ignored and <br>
each device can be accessed directly with the appropriate CL45 <br>
protocol.<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>13:07</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>06</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_dev_pcs_en</td>
<td align=left>
When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directly <br>
accessed through the MDIO serial data stream.<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>05</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_dev_dte_en</td>
<td align=left>
When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directly <br>
accessed through the MDIO serial data stream.<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>04</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_dev_phy_en</td>
<td align=left>
When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directly <br>
accessed through the MDIO serial data stream.<br>
Reset value is 0.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>03</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_dev_an_en</td>
<td align=left>
When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directly <br>
accessed through the MDIO serial data stream.<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>02</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_dev_pmd_en</td>
<td align=left>
When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directly <br>
accessed through the MDIO serial data stream.<br>
Reset value is 1.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>01</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bit must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_dev_id0_en</td>
<td align=left>
When set and mdio_multi_mmds_en=1 then device id 0 registers can be directly <br>
accessed through the MDIO serial data stream.<br>
Reset value is 1.</td></tr>
</table><p>
<A HREF="#MDIO_MMDSEL_AER_COM Registers">Return to MDIO_MMDSEL_AER_COM: common register block for all lanes Table</A><p>
<b><a NAME="MDIO_MMDSEL_AER_COM_mdio_aer">MDIO_MMDSEL_AER_COM_mdio_aer - AER</a></b><br>
Address Offset = 32'h0000_ffde<br>
Physical Address = 32'h0000_ffde<br>
Verilog CL45 Address = {`MDIO_MMDSEL_AER_COM_A, `mdio_aer_Adr}<br>
Verilog CL22 Address = {`MDIO_MMDSEL_AER_COM_A, 4'h0}, `mdio_aer_A<br>
Reset Value = 16'h0000<br>
Access = RW (16-bit only)<br>
<table border=1 align=center width=100% cellpadding=0>
<tr bgcolor="#C0CFF0"><th align=center width=5%>Bit Field</th><th align=center width=5%>Bit Access </th><th align=center width=25%>Field Name</th><th align=center width=65%>Description</th></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>15:11</td>
<td align=left valign=top>RSVD</td>
<td align=left valign=top>Reserved</td>
<td align=left>
Reserved bits must be written with 0.&nbsp A read returns an unknown value.</td></tr>
<tr bgcolor=WHITE>
<td bgcolor=WHITE align=center valign=top>10:00</td>
<td align=left valign=top>RW</td>
<td align=left valign=top>mdio_aer</td>
<td align=left>
Provides 11-bits of 32-bit address for clause45 mdio transactions<br>
Reset value is 0x0.</td></tr>
</table><p>
<A HREF="#MDIO_MMDSEL_AER_COM Registers">Return to MDIO_MMDSEL_AER_COM: common register block for all lanes Table</A><p>
